2023-09-01 12:45:55:988 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACT (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE NULO (BLOCK (ALT 'nil'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE RANGO (BLOCK (ALT '...'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNCION (BLOCK (ALT 'func'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE AT (BLOCK (ALT 'at'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE CADENA (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET '"'))))) '"'))) (RULE ID_VALIDO (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER (BLOCK (ALT '\'' (BLOCK (ALT ESCAPE) (ALT (~ (SET ['\\\r\n])))) '\''))) (RULE ESCAPE (RULEMODIFIERS fragment) (BLOCK (ALT '\\' [\\'tnr]))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE IG (BLOCK (ALT '='))) (RULE DOS_PUNTOS (BLOCK (ALT ':'))) (RULE PUNTOCOMA (BLOCK (ALT ';'))) (RULE CIERRE_INTE (BLOCK (ALT '?'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE SUMA (BLOCK (ALT '+='))) (RULE RESTA (BLOCK (ALT '-='))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE RETORNO (BLOCK (ALT '->'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE GUIONBAJO (BLOCK (ALT '_'))) (RULE CORCHIZQ (BLOCK (ALT '['))) (RULE CORCHDER (BLOCK (ALT ']'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-09-01 12:45:56:002 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE STRING (BLOCK (ALT 'String'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE CHARACT (BLOCK (ALT 'Character'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE NULO (BLOCK (ALT 'nil'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE RANGO (BLOCK (ALT '...'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE FUNCION (BLOCK (ALT 'func'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE AT (BLOCK (ALT 'at'))) (RULE REPEATING (BLOCK (ALT 'repeating'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE CADENA (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET '"'))))) '"'))) (RULE ID_VALIDO (BLOCK (ALT (BLOCK (ALT [a-zA-Z_])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE CHARACTER (BLOCK (ALT '\'' (BLOCK (ALT ESCAPE) (ALT (~ (SET ['\\\r\n])))) '\''))) (RULE ESCAPE (RULEMODIFIERS fragment) (BLOCK (ALT '\\' [\\'tnr]))) (RULE WS (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \t\r\n])))) skip))) (RULE IG (BLOCK (ALT '='))) (RULE DOS_PUNTOS (BLOCK (ALT ':'))) (RULE PUNTOCOMA (BLOCK (ALT ';'))) (RULE CIERRE_INTE (BLOCK (ALT '?'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MODULO (BLOCK (ALT '%'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE SUMA (BLOCK (ALT '+='))) (RULE RESTA (BLOCK (ALT '-='))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE RETORNO (BLOCK (ALT '->'))) (RULE COMA (BLOCK (ALT ','))) (RULE PUNTO (BLOCK (ALT '.'))) (RULE GUIONBAJO (BLOCK (ALT '_'))) (RULE CORCHIZQ (BLOCK (ALT '['))) (RULE CORCHDER (BLOCK (ALT ']'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-09-01 12:45:56:356 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $inst = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $inst = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $inst = $switchcontrol.mySwitch}) (ALT whilecontrol { $inst = $whilecontrol.whict}) (ALT forcontrol { $inst = $forcontrol.forct}) (ALT guardcontrol { $inst = $guardcontrol.guct}) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $vectorcontrol.vect }) (ALT vectoragregar { $inst = $vectoragregar.veadct }) (ALT vectorremover { $inst = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $inst = $printstmt.prnt}) (ALT matrizcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizcontrol.matct}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizasignacion.matasig}))) (RULE blockinterno (returns []interface{} blkint) (@ init {
    $blkint = []interface{}{}
    var listInt []IInstructionintContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= insint instructionint)))) {
        listInt = localctx.(*BlockinternoContext).GetInsint()
        for _, e := range listInt {
            $blkint = append($blkint, e.GetInsint())
        }
    }))) (RULE instructionint (returns interfaces.Instruction insint) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $insint = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $insint = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $insint = $switchcontrol.mySwitch}) (ALT whilecontrol { $insint = $whilecontrol.whict}) (ALT forcontrol { $insint = $forcontrol.forct}) (ALT guardcontrol { $insint = $guardcontrol.guct}) (ALT continuee (? (BLOCK (ALT PUNTOCOMA))) { $insint = $continuee.coct}) (ALT breakk (? (BLOCK (ALT PUNTOCOMA))) { $insint = $breakk.brkct}) (ALT retornos (? (BLOCK (ALT PUNTOCOMA))) { $insint = $retornos.rect }) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorcontrol.vect }) (ALT vectoragregar (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectoragregar.veadct }) (ALT vectorremover (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $insint = $printstmt.prnt}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $insint = $matrizasignacion.matasig}))) (RULE declavarible (returns interfaces.Instruction decvbl) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS tipodato IG expr {$decvbl = instructions.NewVariableDeclaration($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT VAR ID_VALIDO IG expr {$decvbl = instructions.NewVariableDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text, $expr.e)}) (ALT VAR ID_VALIDO DOS_PUNTOS tipodato CIERRE_INTE {$decvbl = instructions.NewVariableDeclaracionSinExp($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo)}))) (RULE declaconstante (returns interfaces.Instruction deccon) (BLOCK (ALT LET ID_VALIDO DOS_PUNTOS tipodato IG expr {$deccon = instructions.NewConstanteDeclaration($LET.line, $LET.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT LET ID_VALIDO IG expr {$deccon = instructions.NewConstanteDeclaracionSinTipo($LET.line, $LET.pos, $ID_VALIDO.text, $expr.e)}))) (RULE asignacionvariable (returns interfaces.Instruction asgvbl) (BLOCK (ALT ID_VALIDO IG expr { $asgvbl = instructions.NewAsignacionVariable($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO SUMA expr { $asgvbl = instructions.NewAsignacionSuma($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO RESTA expr { $asgvbl = instructions.NewAsignacionResta($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE tipodato (returns environment.TipoExpresion tipo) (BLOCK (ALT INT { $tipo = environment.INTEGER }) (ALT FLOAT { $tipo = environment.FLOAT }) (ALT STRING { $tipo = environment.STRING }) (ALT BOOL { $tipo = environment.BOOLEAN }) (ALT CHARACT { $tipo = environment.CHARACTER }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= op NOT) (= right expr) { $e = expressions.NewOperation($right.start.GetLine(), $right.start.GetColumn(), $right.e, $op.text, $right.e) }) (ALT (= left expr) (= op MODULO) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT SUB NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num,environment.INTEGER)
        }
    }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }            
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT CADENA {
        str := $CADENA.text
        $e = expressions.NewPrimitive($CADENA.line, $CADENA.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }) (ALT CHARACTER { 
        str := $CHARACTER.text
        $e = expressions.NewPrimitive($CHARACTER.line, $CHARACTER.pos, str[1:len(str)-1], environment.CHARACTER) 
    }) (ALT ID_VALIDO {
        id := $ID_VALIDO.text
        $e = instructions.NewCallid($ID_VALIDO.line,$ID_VALIDO.pos,id)
    }) (ALT NULO {$e = expressions.NewPrimitive($NULO.line, $NULO.pos, $NULO.text,environment.NULL)}) (ALT vectorvacio { $e = $vectorvacio.veemct}) (ALT vectorcount { $e = $vectorcount.vecnct}) (ALT vectoraccess { $e = $vectoraccess.vepposct}) (ALT intembebida { $e = $intembebida.intemb}) (ALT floatembebida { $e = $floatembebida.floemb}) (ALT stringembebida { $e = $stringembebida.stremb}))) (RULE sentenciaifelse (returns interfaces.Instruction myIfElse) (BLOCK (ALT IF expr LLAVEIZQ blockinterno LLAVEDER { $myIfElse = instructions.NewSentenciaIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint)}) (ALT IF expr LLAVEIZQ (= ifop blockinterno) LLAVEDER ELSE LLAVEIZQ (= elseop blockinterno) LLAVEDER { $myIfElse = instructions.NewSentenciaIfElse($IF.line, $IF.pos, $expr.e, $ifop.blkint , $elseop.blkint)}) (ALT IF expr LLAVEIZQ blockinterno LLAVEDER ELSE sentenciaifelse { $myIfElse = instructions.NewSentenciaIfElseIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint, $sentenciaifelse.myIfElse)}))) (RULE switchcontrol (returns interfaces.Instruction mySwitch) (BLOCK (ALT SWITCH expr LLAVEIZQ blockcase (? (BLOCK (ALT DEFAULT DOS_PUNTOS blockinterno))) LLAVEDER {
    if ($DEFAULT != nil) {
        $mySwitch = instructions.NewSentenciaSwitchDefault($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase, $blockinterno.blkint)
    } else {
        $mySwitch = instructions.NewSentenciaSwitch($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase)
    }
}))) (RULE blockcase (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listInt []IBloquecaseContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blocas bloquecase)))) {
    listInt = localctx.(*BlockcaseContext).GetBlocas()
    for _, e := range listInt {
        $blkcase = append($blkcase, e.GetBlocas())
    }
}))) (RULE bloquecase (returns interfaces.Instruction blocas) (BLOCK (ALT CASE expr DOS_PUNTOS blockinterno {
    $blocas=instructions.NewSentenciaSwitchCase($CASE.line ,$CASE.pos, $expr.e, $blockinterno.blkint)
}))) (RULE whilecontrol (returns interfaces.Instruction whict) (BLOCK (ALT WHILE expr LLAVEIZQ blockinterno LLAVEDER { $whict = instructions.NewSentenciaWhile($WHILE.line, $WHILE.pos, $expr.e, $blockinterno.blkint)}))) (RULE forcontrol (returns interfaces.Instruction forct) (BLOCK (ALT FOR ID_VALIDO IN (= left expr) RANGO (= right expr) LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForRango($FOR.line, $FOR.pos, $ID_VALIDO.text, $left.e, $right.e,$blockinterno.blkint)}) (ALT FOR ID_VALIDO IN expr LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForCadena($FOR.line, $FOR.pos, $ID_VALIDO.text, $expr.e, $blockinterno.blkint)}))) (RULE guardcontrol (returns interfaces.Instruction guct) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ blockinterno LLAVEDER { 
    $guct = instructions.NewSentenciaGuard($GUARD.line, $GUARD.pos, $expr.e, $blockinterno.blkint)
}))) (RULE continuee (returns interfaces.Instruction coct) (BLOCK (ALT CONTINUE {$coct = instructions.NewTransferenciaContinue($CONTINUE.line, $CONTINUE.pos)}))) (RULE breakk (returns interfaces.Instruction brkct) (BLOCK (ALT BREAK { $brkct = instructions.NewTransferenciaBreak($BREAK.line, $BREAK.pos)}))) (RULE retornos (returns interfaces.Instruction rect) (BLOCK (ALT RETURN {
    $rect = instructions.NewTransferenciaReturn($RETURN.line, $RETURN.pos);
}) (ALT RETURN (= op expr) {
    $rect = instructions.NewTransferenciaReturnExp($RETURN.line, $RETURN.pos, $op.e);
}))) (RULE vectorcontrol (returns interfaces.Instruction vect) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ blockparams CORCHDER { $vect = instructions.NewArregloDeclaracionLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo, $blockparams.blkpar)}) (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ CORCHDER { $vect = instructions.NewArregloDeclaracionSinLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo)}) (ALT VAR (= prin ID_VALIDO) DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG (= secu ID_VALIDO) { $vect = instructions.NewArregloDeclaracionId($VAR.line ,$VAR.pos, $prin.text , $tipodato.tipo, $secu.text)}))) (RULE blockparams (returns []interface{} blkpar) (@ init {
    $blkpar = []interface{}{}
    var listInt []IBloqueparamsContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blopas bloqueparams)))) {
    listInt = localctx.(*BlockparamsContext).GetBlopas()
    for _, e := range listInt {
        $blkpar = append($blkpar, e.GetBlopas())
    }
}))) (RULE bloqueparams (returns interfaces.Expression blopas) (BLOCK (ALT COMA expr {
    $blopas = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $blopas = instructions.NewArregloParametro($expr.e)
}))) (RULE vectoragregar (returns interfaces.Instruction veadct) (BLOCK (ALT ID_VALIDO PUNTO APPEND PARIZQ expr PARDER { $veadct = instructions.NewArregloAppend($ID_VALIDO.text , $expr.e)}) (ALT (= prin ID_VALIDO) CORCHIZQ (= pop expr) CORCHDER IG (= secu ID_VALIDO) CORCHIZQ (= sop expr) CORCHDER { $veadct = instructions.NewArregloAppendArreglo($prin.text , $pop.e, $secu.text, $sop.e)}) (ALT ID_VALIDO CORCHIZQ (= pop expr) CORCHDER IG (= sop expr) { $veadct = instructions.NewArregloAppendExp($ID_VALIDO.text , $pop.e, $sop.e)}))) (RULE vectorremover (returns interfaces.Instruction vermct) (BLOCK (ALT ID_VALIDO PUNTO REMOVELAST PARIZQ PARDER { $vermct = instructions.NewArregloRemoveLast($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}) (ALT ID_VALIDO PUNTO REMOVE PARIZQ AT DOS_PUNTOS expr PARDER { $vermct = instructions.NewArregloRemovePos($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE vectorvacio (returns interfaces.Expression veemct) (BLOCK (ALT ID_VALIDO PUNTO ISEMPTY { $veemct = instructions.NewArregloIsEmpty($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectorcount (returns interfaces.Expression vecnct) (BLOCK (ALT ID_VALIDO PUNTO COUNT { $vecnct = instructions.NewArregloCount($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectoraccess (returns interfaces.Expression vepposct) (BLOCK (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER listamatrizaddsubs { $masob = instructions.NewMatrizObtencionList($ID_VALIDO.text, $op1.e, $op2.e, $listamatrizaddsubs.blklimatas) }) (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER { $masob = instructions.NewMatrizObtencion($ID_VALIDO.text, $op1.e, $op2.e) }) (ALT ID_VALIDO CORCHIZQ expr CORCHDER { $vepposct = instructions.NewArregloAccess($CORCHDER.line, $CORCHDER.pos, $ID_VALIDO.text, $expr.e)}))) (RULE matrizcontrol (returns interfaces.Instruction matct) (BLOCK (ALT VAR ID_VALIDO (? (BLOCK (ALT DOS_PUNTOS tipomatriz))) IG defmatriz {
    if ($DOS_PUNTOS != nil) {
        $matct = instructions.NewMatrizDeclaracion($VAR.line, $VAR.pos, $ID_VALIDO.text ,$tipomatriz.tipomat, $defmatriz.defmat)
    } else {
        $matct = instructions.NewMatrizDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text , $defmatriz.defmat)
    }
}))) (RULE tipomatriz (returns interfaces.Expression tipomat) (BLOCK (ALT CORCHIZQ tipomatriz CORCHDER { 
    $tipomat = instructions.NewMatrizDimension($CORCHIZQ.line, $CORCHIZQ.pos, $tipomatriz.tipomat)
}) (ALT CORCHIZQ tipodato CORCHDER { 
    $tipomat = instructions.NewMatrizTipo($CORCHIZQ.line, $CORCHIZQ.pos, $tipodato.tipo)
}))) (RULE defmatriz (returns interfaces.Instruction defmat) (BLOCK (ALT listavaloresmat { $defmat = $listavaloresmat.listvlamat}))) (RULE listavaloresmat (returns interfaces.Instruction listvlamat) (BLOCK (ALT CORCHIZQ listavaloresmat2 CORCHDER { $listvlamat = $listavaloresmat2.mylisttmatt}) (ALT simplematriz { $listvlamat = $simplematriz.simmat}))) (RULE listavaloresmat2 (returns interfaces.Instruction mylisttmatt) (BLOCK (ALT (= op listavaloresmat2) COMA listavaloresmat { $mylisttmatt = instructions.NewMatrizListaExpresionList($op.mylisttmatt, $listavaloresmat.listvlamat)}) (ALT listavaloresmat { $mylisttmatt = instructions.NewMatrizListaNivel($listavaloresmat.listvlamat)}) (ALT listaexpresions { $mylisttmatt = instructions.NewMatrizListaExpresion($listaexpresions.blkparf)}))) (RULE listaexpresions (returns []interface{} blkparf) (@ init {
    $blkparf = []interface{}{}
    var listInt []IListaexpresionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= funpar listaexpresion)))) {
    listInt = localctx.(*ListaexpresionsContext).GetFunpar()
    for _, e := range listInt {
        $blkparf = append($blkparf, e.GetFunpar())
    }
}))) (RULE listaexpresion (returns interfaces.Expression funpar) (BLOCK (ALT COMA expr {
    $funpar = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $funpar = instructions.NewArregloParametro($expr.e)
}))) (RULE simplematriz (returns interfaces.Instruction simmat) (BLOCK (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS (= op simplematriz) COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleUno($tipomatriz.tipomat, $op.simmat, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}) (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS expr COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleDos($tipomatriz.tipomat, $expr.e, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}))) (RULE matrizasignacion (returns interfaces.Instruction matasig) (BLOCK (ALT ID_VALIDO CORCHIZQ expr CORCHDER listamatrizaddsubs IG expr { $matasig = instructions.NewMatrizAsiginacion($ID_VALIDO.text, $expr.e, $listamatrizaddsubs.blklimatas) }))) (RULE listamatrizaddsubs (returns []interface{} blklimatas) (@ init {
    $blklimatas = []interface{}{}
    var listInt []IListamatrizaddsubContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= lmas listamatrizaddsub)))) {
    listInt = localctx.(*ListamatrizaddsubsContext).GetLmas()
    for _, e := range listInt {
        $blklimatas = append($blklimatas, e.GetLmas())
    }
}))) (RULE listamatrizaddsub (returns interfaces.Expression lmas) (BLOCK (ALT CORCHIZQ expr CORCHDER {
    $lmas = instructions.NewArregloParametros($CORCHIZQ.line ,$CORCHIZQ.pos, $expr.e)
}))) (RULE funciondeclaracioncontrol (BLOCK (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER RETORNO tipodato LLAVEIZQ blockinterno LLAVEDER {}) (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER LLAVEIZQ blockinterno LLAVEDER {}))) (RULE listaparametros (BLOCK (ALT COMA (? (BLOCK (ALT ID_VALIDO) (ALT GUIONBAJO))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato listaparametros {}) (ALT (? (BLOCK (ALT ID_VALIDO) (ALT GUIONBAJO))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato {}))) (RULE funcionllamadacontrol (BLOCK (ALT ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametrosllamada))) PARIZQ {}))) (RULE listaparametrosllamada (BLOCK (ALT COMA (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr listaparametrosllamada {}) (ALT (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE intembebida (returns interfaces.Expression intemb) (BLOCK (ALT INT PARIZQ expr PARDER { $intemb = instructions.NewFuncionIntEmbebida($expr.e)}))) (RULE floatembebida (returns interfaces.Expression floemb) (BLOCK (ALT FLOAT PARIZQ expr PARDER { $floemb = instructions.NewFuncionFloatEmbebida($expr.e)}))) (RULE stringembebida (returns interfaces.Expression stremb) (BLOCK (ALT STRING PARIZQ expr PARDER { $stremb = instructions.NewFuncionStringEmbebida($expr.e)})))))
2023-09-01 12:45:56:367 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $inst = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $inst = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $inst = $switchcontrol.mySwitch}) (ALT whilecontrol { $inst = $whilecontrol.whict}) (ALT forcontrol { $inst = $forcontrol.forct}) (ALT guardcontrol { $inst = $guardcontrol.guct}) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $vectorcontrol.vect }) (ALT vectoragregar { $inst = $vectoragregar.veadct }) (ALT vectorremover { $inst = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $inst = $printstmt.prnt}) (ALT matrizcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizcontrol.matct}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizasignacion.matasig}))) (RULE blockinterno (returns []interface{} blkint) (@ init {
    $blkint = []interface{}{}
    var listInt []IInstructionintContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= insint instructionint)))) {
        listInt = localctx.(*BlockinternoContext).GetInsint()
        for _, e := range listInt {
            $blkint = append($blkint, e.GetInsint())
        }
    }))) (RULE instructionint (returns interfaces.Instruction insint) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $insint = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $insint = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $insint = $switchcontrol.mySwitch}) (ALT whilecontrol { $insint = $whilecontrol.whict}) (ALT forcontrol { $insint = $forcontrol.forct}) (ALT guardcontrol { $insint = $guardcontrol.guct}) (ALT continuee (? (BLOCK (ALT PUNTOCOMA))) { $insint = $continuee.coct}) (ALT breakk (? (BLOCK (ALT PUNTOCOMA))) { $insint = $breakk.brkct}) (ALT retornos (? (BLOCK (ALT PUNTOCOMA))) { $insint = $retornos.rect }) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorcontrol.vect }) (ALT vectoragregar (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectoragregar.veadct }) (ALT vectorremover (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $insint = $printstmt.prnt}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $insint = $matrizasignacion.matasig}))) (RULE declavarible (returns interfaces.Instruction decvbl) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS tipodato IG expr {$decvbl = instructions.NewVariableDeclaration($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT VAR ID_VALIDO IG expr {$decvbl = instructions.NewVariableDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text, $expr.e)}) (ALT VAR ID_VALIDO DOS_PUNTOS tipodato CIERRE_INTE {$decvbl = instructions.NewVariableDeclaracionSinExp($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo)}))) (RULE declaconstante (returns interfaces.Instruction deccon) (BLOCK (ALT LET ID_VALIDO DOS_PUNTOS tipodato IG expr {$deccon = instructions.NewConstanteDeclaration($LET.line, $LET.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT LET ID_VALIDO IG expr {$deccon = instructions.NewConstanteDeclaracionSinTipo($LET.line, $LET.pos, $ID_VALIDO.text, $expr.e)}))) (RULE asignacionvariable (returns interfaces.Instruction asgvbl) (BLOCK (ALT ID_VALIDO IG expr { $asgvbl = instructions.NewAsignacionVariable($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO SUMA expr { $asgvbl = instructions.NewAsignacionSuma($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO RESTA expr { $asgvbl = instructions.NewAsignacionResta($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE tipodato (returns environment.TipoExpresion tipo) (BLOCK (ALT INT { $tipo = environment.INTEGER }) (ALT FLOAT { $tipo = environment.FLOAT }) (ALT STRING { $tipo = environment.STRING }) (ALT BOOL { $tipo = environment.BOOLEAN }) (ALT CHARACT { $tipo = environment.CHARACTER }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= op NOT) (= right expr) { $e = expressions.NewOperation($right.start.GetLine(), $right.start.GetColumn(), $right.e, $op.text, $right.e) }) (ALT (= left expr) (= op MODULO) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT SUB NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num,environment.INTEGER)
        }
    }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }            
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT CADENA {
        str := $CADENA.text
        $e = expressions.NewPrimitive($CADENA.line, $CADENA.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }) (ALT CHARACTER { 
        str := $CHARACTER.text
        $e = expressions.NewPrimitive($CHARACTER.line, $CHARACTER.pos, str[1:len(str)-1], environment.CHARACTER) 
    }) (ALT ID_VALIDO {
        id := $ID_VALIDO.text
        $e = instructions.NewCallid($ID_VALIDO.line,$ID_VALIDO.pos,id)
    }) (ALT NULO {$e = expressions.NewPrimitive($NULO.line, $NULO.pos, $NULO.text,environment.NULL)}) (ALT vectorvacio { $e = $vectorvacio.veemct}) (ALT vectorcount { $e = $vectorcount.vecnct}) (ALT vectoraccess { $e = $vectoraccess.vepposct}) (ALT intembebida { $e = $intembebida.intemb}) (ALT floatembebida { $e = $floatembebida.floemb}) (ALT stringembebida { $e = $stringembebida.stremb}))) (RULE sentenciaifelse (returns interfaces.Instruction myIfElse) (BLOCK (ALT IF expr LLAVEIZQ blockinterno LLAVEDER { $myIfElse = instructions.NewSentenciaIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint)}) (ALT IF expr LLAVEIZQ (= ifop blockinterno) LLAVEDER ELSE LLAVEIZQ (= elseop blockinterno) LLAVEDER { $myIfElse = instructions.NewSentenciaIfElse($IF.line, $IF.pos, $expr.e, $ifop.blkint , $elseop.blkint)}) (ALT IF expr LLAVEIZQ blockinterno LLAVEDER ELSE sentenciaifelse { $myIfElse = instructions.NewSentenciaIfElseIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint, $sentenciaifelse.myIfElse)}))) (RULE switchcontrol (returns interfaces.Instruction mySwitch) (BLOCK (ALT SWITCH expr LLAVEIZQ blockcase (? (BLOCK (ALT DEFAULT DOS_PUNTOS blockinterno))) LLAVEDER {
    if ($DEFAULT != nil) {
        $mySwitch = instructions.NewSentenciaSwitchDefault($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase, $blockinterno.blkint)
    } else {
        $mySwitch = instructions.NewSentenciaSwitch($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase)
    }
}))) (RULE blockcase (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listInt []IBloquecaseContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blocas bloquecase)))) {
    listInt = localctx.(*BlockcaseContext).GetBlocas()
    for _, e := range listInt {
        $blkcase = append($blkcase, e.GetBlocas())
    }
}))) (RULE bloquecase (returns interfaces.Instruction blocas) (BLOCK (ALT CASE expr DOS_PUNTOS blockinterno {
    $blocas=instructions.NewSentenciaSwitchCase($CASE.line ,$CASE.pos, $expr.e, $blockinterno.blkint)
}))) (RULE whilecontrol (returns interfaces.Instruction whict) (BLOCK (ALT WHILE expr LLAVEIZQ blockinterno LLAVEDER { $whict = instructions.NewSentenciaWhile($WHILE.line, $WHILE.pos, $expr.e, $blockinterno.blkint)}))) (RULE forcontrol (returns interfaces.Instruction forct) (BLOCK (ALT FOR ID_VALIDO IN (= left expr) RANGO (= right expr) LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForRango($FOR.line, $FOR.pos, $ID_VALIDO.text, $left.e, $right.e,$blockinterno.blkint)}) (ALT FOR ID_VALIDO IN expr LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForCadena($FOR.line, $FOR.pos, $ID_VALIDO.text, $expr.e, $blockinterno.blkint)}))) (RULE guardcontrol (returns interfaces.Instruction guct) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ blockinterno LLAVEDER { 
    $guct = instructions.NewSentenciaGuard($GUARD.line, $GUARD.pos, $expr.e, $blockinterno.blkint)
}))) (RULE continuee (returns interfaces.Instruction coct) (BLOCK (ALT CONTINUE {$coct = instructions.NewTransferenciaContinue($CONTINUE.line, $CONTINUE.pos)}))) (RULE breakk (returns interfaces.Instruction brkct) (BLOCK (ALT BREAK { $brkct = instructions.NewTransferenciaBreak($BREAK.line, $BREAK.pos)}))) (RULE retornos (returns interfaces.Instruction rect) (BLOCK (ALT RETURN {
    $rect = instructions.NewTransferenciaReturn($RETURN.line, $RETURN.pos);
}) (ALT RETURN (= op expr) {
    $rect = instructions.NewTransferenciaReturnExp($RETURN.line, $RETURN.pos, $op.e);
}))) (RULE vectorcontrol (returns interfaces.Instruction vect) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ blockparams CORCHDER { $vect = instructions.NewArregloDeclaracionLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo, $blockparams.blkpar)}) (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ CORCHDER { $vect = instructions.NewArregloDeclaracionSinLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo)}) (ALT VAR (= prin ID_VALIDO) DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG (= secu ID_VALIDO) { $vect = instructions.NewArregloDeclaracionId($VAR.line ,$VAR.pos, $prin.text , $tipodato.tipo, $secu.text)}))) (RULE blockparams (returns []interface{} blkpar) (@ init {
    $blkpar = []interface{}{}
    var listInt []IBloqueparamsContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blopas bloqueparams)))) {
    listInt = localctx.(*BlockparamsContext).GetBlopas()
    for _, e := range listInt {
        $blkpar = append($blkpar, e.GetBlopas())
    }
}))) (RULE bloqueparams (returns interfaces.Expression blopas) (BLOCK (ALT COMA expr {
    $blopas = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $blopas = instructions.NewArregloParametro($expr.e)
}))) (RULE vectoragregar (returns interfaces.Instruction veadct) (BLOCK (ALT ID_VALIDO PUNTO APPEND PARIZQ expr PARDER { $veadct = instructions.NewArregloAppend($ID_VALIDO.text , $expr.e)}) (ALT (= prin ID_VALIDO) CORCHIZQ (= pop expr) CORCHDER IG (= secu ID_VALIDO) CORCHIZQ (= sop expr) CORCHDER { $veadct = instructions.NewArregloAppendArreglo($prin.text , $pop.e, $secu.text, $sop.e)}) (ALT ID_VALIDO CORCHIZQ (= pop expr) CORCHDER IG (= sop expr) { $veadct = instructions.NewArregloAppendExp($ID_VALIDO.text , $pop.e, $sop.e)}))) (RULE vectorremover (returns interfaces.Instruction vermct) (BLOCK (ALT ID_VALIDO PUNTO REMOVELAST PARIZQ PARDER { $vermct = instructions.NewArregloRemoveLast($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}) (ALT ID_VALIDO PUNTO REMOVE PARIZQ AT DOS_PUNTOS expr PARDER { $vermct = instructions.NewArregloRemovePos($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE vectorvacio (returns interfaces.Expression veemct) (BLOCK (ALT ID_VALIDO PUNTO ISEMPTY { $veemct = instructions.NewArregloIsEmpty($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectorcount (returns interfaces.Expression vecnct) (BLOCK (ALT ID_VALIDO PUNTO COUNT { $vecnct = instructions.NewArregloCount($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectoraccess (returns interfaces.Expression vepposct) (BLOCK (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER listamatrizaddsubs { $masob = instructions.NewMatrizObtencionList($ID_VALIDO.text, $op1.e, $op2.e, $listamatrizaddsubs.blklimatas) }) (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER { $masob = instructions.NewMatrizObtencion($ID_VALIDO.text, $op1.e, $op2.e) }) (ALT ID_VALIDO CORCHIZQ expr CORCHDER { $vepposct = instructions.NewArregloAccess($CORCHDER.line, $CORCHDER.pos, $ID_VALIDO.text, $expr.e)}))) (RULE matrizcontrol (returns interfaces.Instruction matct) (BLOCK (ALT VAR ID_VALIDO (? (BLOCK (ALT DOS_PUNTOS tipomatriz))) IG defmatriz {
    if ($DOS_PUNTOS != nil) {
        $matct = instructions.NewMatrizDeclaracion($VAR.line, $VAR.pos, $ID_VALIDO.text ,$tipomatriz.tipomat, $defmatriz.defmat)
    } else {
        $matct = instructions.NewMatrizDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text , $defmatriz.defmat)
    }
}))) (RULE tipomatriz (returns interfaces.Expression tipomat) (BLOCK (ALT CORCHIZQ tipomatriz CORCHDER { 
    $tipomat = instructions.NewMatrizDimension($CORCHIZQ.line, $CORCHIZQ.pos, $tipomatriz.tipomat)
}) (ALT CORCHIZQ tipodato CORCHDER { 
    $tipomat = instructions.NewMatrizTipo($CORCHIZQ.line, $CORCHIZQ.pos, $tipodato.tipo)
}))) (RULE defmatriz (returns interfaces.Instruction defmat) (BLOCK (ALT listavaloresmat { $defmat = $listavaloresmat.listvlamat}))) (RULE listavaloresmat (returns interfaces.Instruction listvlamat) (BLOCK (ALT CORCHIZQ listavaloresmat2 CORCHDER { $listvlamat = $listavaloresmat2.mylisttmatt}) (ALT simplematriz { $listvlamat = $simplematriz.simmat}))) (RULE listavaloresmat2 (returns interfaces.Instruction mylisttmatt) (BLOCK (ALT (= op listavaloresmat2) COMA listavaloresmat { $mylisttmatt = instructions.NewMatrizListaExpresionList($op.mylisttmatt, $listavaloresmat.listvlamat)}) (ALT listavaloresmat { $mylisttmatt = instructions.NewMatrizListaNivel($listavaloresmat.listvlamat)}) (ALT listaexpresions { $mylisttmatt = instructions.NewMatrizListaExpresion($listaexpresions.blkparf)}))) (RULE listaexpresions (returns []interface{} blkparf) (@ init {
    $blkparf = []interface{}{}
    var listInt []IListaexpresionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= funpar listaexpresion)))) {
    listInt = localctx.(*ListaexpresionsContext).GetFunpar()
    for _, e := range listInt {
        $blkparf = append($blkparf, e.GetFunpar())
    }
}))) (RULE listaexpresion (returns interfaces.Expression funpar) (BLOCK (ALT COMA expr {
    $funpar = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $funpar = instructions.NewArregloParametro($expr.e)
}))) (RULE simplematriz (returns interfaces.Instruction simmat) (BLOCK (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS (= op simplematriz) COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleUno($tipomatriz.tipomat, $op.simmat, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}) (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS expr COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleDos($tipomatriz.tipomat, $expr.e, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}))) (RULE matrizasignacion (returns interfaces.Instruction matasig) (BLOCK (ALT ID_VALIDO CORCHIZQ expr CORCHDER listamatrizaddsubs IG expr { $matasig = instructions.NewMatrizAsiginacion($ID_VALIDO.text, $expr.e, $listamatrizaddsubs.blklimatas) }))) (RULE listamatrizaddsubs (returns []interface{} blklimatas) (@ init {
    $blklimatas = []interface{}{}
    var listInt []IListamatrizaddsubContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= lmas listamatrizaddsub)))) {
    listInt = localctx.(*ListamatrizaddsubsContext).GetLmas()
    for _, e := range listInt {
        $blklimatas = append($blklimatas, e.GetLmas())
    }
}))) (RULE listamatrizaddsub (returns interfaces.Expression lmas) (BLOCK (ALT CORCHIZQ expr CORCHDER {
    $lmas = instructions.NewArregloParametros($CORCHIZQ.line ,$CORCHIZQ.pos, $expr.e)
}))) (RULE funciondeclaracioncontrol (BLOCK (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER RETORNO tipodato LLAVEIZQ blockinterno LLAVEDER {}) (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER LLAVEIZQ blockinterno LLAVEDER {}))) (RULE listaparametros (BLOCK (ALT COMA (? (BLOCK (ALT (SET ID_VALIDO GUIONBAJO)))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato listaparametros {}) (ALT (? (BLOCK (ALT (SET ID_VALIDO GUIONBAJO)))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato {}))) (RULE funcionllamadacontrol (BLOCK (ALT ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametrosllamada))) PARIZQ {}))) (RULE listaparametrosllamada (BLOCK (ALT COMA (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr listaparametrosllamada {}) (ALT (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE intembebida (returns interfaces.Expression intemb) (BLOCK (ALT INT PARIZQ expr PARDER { $intemb = instructions.NewFuncionIntEmbebida($expr.e)}))) (RULE floatembebida (returns interfaces.Expression floemb) (BLOCK (ALT FLOAT PARIZQ expr PARDER { $floemb = instructions.NewFuncionFloatEmbebida($expr.e)}))) (RULE stringembebida (returns interfaces.Expression stremb) (BLOCK (ALT STRING PARIZQ expr PARDER { $stremb = instructions.NewFuncionStringEmbebida($expr.e)})))))
2023-09-01 12:45:56:373 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $inst = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $inst = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $inst = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $inst = $switchcontrol.mySwitch}) (ALT whilecontrol { $inst = $whilecontrol.whict}) (ALT forcontrol { $inst = $forcontrol.forct}) (ALT guardcontrol { $inst = $guardcontrol.guct}) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $vectorcontrol.vect }) (ALT vectoragregar { $inst = $vectoragregar.veadct }) (ALT vectorremover { $inst = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $inst = $printstmt.prnt}) (ALT matrizcontrol (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizcontrol.matct}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $inst = $matrizasignacion.matasig}))) (RULE blockinterno (returns []interface{} blkint) (@ init {
    $blkint = []interface{}{}
    var listInt []IInstructionintContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= insint instructionint)))) {
        listInt = localctx.(*BlockinternoContext).GetInsint()
        for _, e := range listInt {
            $blkint = append($blkint, e.GetInsint())
        }
    }))) (RULE instructionint (returns interfaces.Instruction insint) (BLOCK (ALT declavarible (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declavarible.decvbl}) (ALT declaconstante (? (BLOCK (ALT PUNTOCOMA))) { $insint = $declaconstante.deccon}) (ALT asignacionvariable (? (BLOCK (ALT PUNTOCOMA))) { $insint = $asignacionvariable.asgvbl}) (ALT sentenciaifelse { $insint = $sentenciaifelse.myIfElse}) (ALT switchcontrol { $insint = $switchcontrol.mySwitch}) (ALT whilecontrol { $insint = $whilecontrol.whict}) (ALT forcontrol { $insint = $forcontrol.forct}) (ALT guardcontrol { $insint = $guardcontrol.guct}) (ALT continuee (? (BLOCK (ALT PUNTOCOMA))) { $insint = $continuee.coct}) (ALT breakk (? (BLOCK (ALT PUNTOCOMA))) { $insint = $breakk.brkct}) (ALT retornos (? (BLOCK (ALT PUNTOCOMA))) { $insint = $retornos.rect }) (ALT vectorcontrol (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorcontrol.vect }) (ALT vectoragregar (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectoragregar.veadct }) (ALT vectorremover (? (BLOCK (ALT PUNTOCOMA))) { $insint = $vectorremover.vermct }) (ALT printstmt (? (BLOCK (ALT PUNTOCOMA))) { $insint = $printstmt.prnt}) (ALT matrizasignacion (? (BLOCK (ALT PUNTOCOMA))) { $insint = $matrizasignacion.matasig}))) (RULE declavarible (returns interfaces.Instruction decvbl) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS tipodato IG expr {$decvbl = instructions.NewVariableDeclaration($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT VAR ID_VALIDO IG expr {$decvbl = instructions.NewVariableDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text, $expr.e)}) (ALT VAR ID_VALIDO DOS_PUNTOS tipodato CIERRE_INTE {$decvbl = instructions.NewVariableDeclaracionSinExp($VAR.line, $VAR.pos, $ID_VALIDO.text, $tipodato.tipo)}))) (RULE declaconstante (returns interfaces.Instruction deccon) (BLOCK (ALT LET ID_VALIDO DOS_PUNTOS tipodato IG expr {$deccon = instructions.NewConstanteDeclaration($LET.line, $LET.pos, $ID_VALIDO.text, $tipodato.tipo, $expr.e)}) (ALT LET ID_VALIDO IG expr {$deccon = instructions.NewConstanteDeclaracionSinTipo($LET.line, $LET.pos, $ID_VALIDO.text, $expr.e)}))) (RULE asignacionvariable (returns interfaces.Instruction asgvbl) (BLOCK (ALT ID_VALIDO IG expr { $asgvbl = instructions.NewAsignacionVariable($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO SUMA expr { $asgvbl = instructions.NewAsignacionSuma($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}) (ALT ID_VALIDO RESTA expr { $asgvbl = instructions.NewAsignacionResta($ID_VALIDO.line, $ID_VALIDO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE tipodato (returns environment.TipoExpresion tipo) (BLOCK (ALT INT { $tipo = environment.INTEGER }) (ALT FLOAT { $tipo = environment.FLOAT }) (ALT STRING { $tipo = environment.STRING }) (ALT BOOL { $tipo = environment.BOOLEAN }) (ALT CHARACT { $tipo = environment.CHARACTER }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= op NOT) (= right expr) { $e = expressions.NewOperation($right.start.GetLine(), $right.start.GetColumn(), $right.e, $op.text, $right.e) }) (ALT (= left expr) (= op MODULO) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT SUB NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num,environment.INTEGER)
        }
    }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }            
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT CADENA {
        str := $CADENA.text
        $e = expressions.NewPrimitive($CADENA.line, $CADENA.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }) (ALT CHARACTER { 
        str := $CHARACTER.text
        $e = expressions.NewPrimitive($CHARACTER.line, $CHARACTER.pos, str[1:len(str)-1], environment.CHARACTER) 
    }) (ALT ID_VALIDO {
        id := $ID_VALIDO.text
        $e = instructions.NewCallid($ID_VALIDO.line,$ID_VALIDO.pos,id)
    }) (ALT NULO {$e = expressions.NewPrimitive($NULO.line, $NULO.pos, $NULO.text,environment.NULL)}) (ALT vectorvacio { $e = $vectorvacio.veemct}) (ALT vectorcount { $e = $vectorcount.vecnct}) (ALT vectoraccess { $e = $vectoraccess.vepposct}) (ALT intembebida { $e = $intembebida.intemb}) (ALT floatembebida { $e = $floatembebida.floemb}) (ALT stringembebida { $e = $stringembebida.stremb}))) (RULE sentenciaifelse (returns interfaces.Instruction myIfElse) (BLOCK (ALT IF expr LLAVEIZQ blockinterno LLAVEDER { $myIfElse = instructions.NewSentenciaIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint)}) (ALT IF expr LLAVEIZQ (= ifop blockinterno) LLAVEDER ELSE LLAVEIZQ (= elseop blockinterno) LLAVEDER { $myIfElse = instructions.NewSentenciaIfElse($IF.line, $IF.pos, $expr.e, $ifop.blkint , $elseop.blkint)}) (ALT IF expr LLAVEIZQ blockinterno LLAVEDER ELSE sentenciaifelse { $myIfElse = instructions.NewSentenciaIfElseIf($IF.line, $IF.pos, $expr.e, $blockinterno.blkint, $sentenciaifelse.myIfElse)}))) (RULE switchcontrol (returns interfaces.Instruction mySwitch) (BLOCK (ALT SWITCH expr LLAVEIZQ blockcase (? (BLOCK (ALT DEFAULT DOS_PUNTOS blockinterno))) LLAVEDER {
    if ($DEFAULT != nil) {
        $mySwitch = instructions.NewSentenciaSwitchDefault($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase, $blockinterno.blkint)
    } else {
        $mySwitch = instructions.NewSentenciaSwitch($SWITCH.line, $SWITCH.pos, $expr.e, $blockcase.blkcase)
    }
}))) (RULE blockcase (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listInt []IBloquecaseContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blocas bloquecase)))) {
    listInt = localctx.(*BlockcaseContext).GetBlocas()
    for _, e := range listInt {
        $blkcase = append($blkcase, e.GetBlocas())
    }
}))) (RULE bloquecase (returns interfaces.Instruction blocas) (BLOCK (ALT CASE expr DOS_PUNTOS blockinterno {
    $blocas=instructions.NewSentenciaSwitchCase($CASE.line ,$CASE.pos, $expr.e, $blockinterno.blkint)
}))) (RULE whilecontrol (returns interfaces.Instruction whict) (BLOCK (ALT WHILE expr LLAVEIZQ blockinterno LLAVEDER { $whict = instructions.NewSentenciaWhile($WHILE.line, $WHILE.pos, $expr.e, $blockinterno.blkint)}))) (RULE forcontrol (returns interfaces.Instruction forct) (BLOCK (ALT FOR ID_VALIDO IN (= left expr) RANGO (= right expr) LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForRango($FOR.line, $FOR.pos, $ID_VALIDO.text, $left.e, $right.e,$blockinterno.blkint)}) (ALT FOR ID_VALIDO IN expr LLAVEIZQ blockinterno LLAVEDER { $forct = instructions.NewSentenciaForCadena($FOR.line, $FOR.pos, $ID_VALIDO.text, $expr.e, $blockinterno.blkint)}))) (RULE guardcontrol (returns interfaces.Instruction guct) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ blockinterno LLAVEDER { 
    $guct = instructions.NewSentenciaGuard($GUARD.line, $GUARD.pos, $expr.e, $blockinterno.blkint)
}))) (RULE continuee (returns interfaces.Instruction coct) (BLOCK (ALT CONTINUE {$coct = instructions.NewTransferenciaContinue($CONTINUE.line, $CONTINUE.pos)}))) (RULE breakk (returns interfaces.Instruction brkct) (BLOCK (ALT BREAK { $brkct = instructions.NewTransferenciaBreak($BREAK.line, $BREAK.pos)}))) (RULE retornos (returns interfaces.Instruction rect) (BLOCK (ALT RETURN {
    $rect = instructions.NewTransferenciaReturn($RETURN.line, $RETURN.pos);
}) (ALT RETURN (= op expr) {
    $rect = instructions.NewTransferenciaReturnExp($RETURN.line, $RETURN.pos, $op.e);
}))) (RULE vectorcontrol (returns interfaces.Instruction vect) (BLOCK (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ blockparams CORCHDER { $vect = instructions.NewArregloDeclaracionLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo, $blockparams.blkpar)}) (ALT VAR ID_VALIDO DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG CORCHIZQ CORCHDER { $vect = instructions.NewArregloDeclaracionSinLista($VAR.line ,$VAR.pos, $ID_VALIDO.text , $tipodato.tipo)}) (ALT VAR (= prin ID_VALIDO) DOS_PUNTOS CORCHIZQ tipodato CORCHDER IG (= secu ID_VALIDO) { $vect = instructions.NewArregloDeclaracionId($VAR.line ,$VAR.pos, $prin.text , $tipodato.tipo, $secu.text)}))) (RULE blockparams (returns []interface{} blkpar) (@ init {
    $blkpar = []interface{}{}
    var listInt []IBloqueparamsContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= blopas bloqueparams)))) {
    listInt = localctx.(*BlockparamsContext).GetBlopas()
    for _, e := range listInt {
        $blkpar = append($blkpar, e.GetBlopas())
    }
}))) (RULE bloqueparams (returns interfaces.Expression blopas) (BLOCK (ALT COMA expr {
    $blopas = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $blopas = instructions.NewArregloParametro($expr.e)
}))) (RULE vectoragregar (returns interfaces.Instruction veadct) (BLOCK (ALT ID_VALIDO PUNTO APPEND PARIZQ expr PARDER { $veadct = instructions.NewArregloAppend($ID_VALIDO.text , $expr.e)}) (ALT (= prin ID_VALIDO) CORCHIZQ (= pop expr) CORCHDER IG (= secu ID_VALIDO) CORCHIZQ (= sop expr) CORCHDER { $veadct = instructions.NewArregloAppendArreglo($prin.text , $pop.e, $secu.text, $sop.e)}) (ALT ID_VALIDO CORCHIZQ (= pop expr) CORCHDER IG (= sop expr) { $veadct = instructions.NewArregloAppendExp($ID_VALIDO.text , $pop.e, $sop.e)}))) (RULE vectorremover (returns interfaces.Instruction vermct) (BLOCK (ALT ID_VALIDO PUNTO REMOVELAST PARIZQ PARDER { $vermct = instructions.NewArregloRemoveLast($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}) (ALT ID_VALIDO PUNTO REMOVE PARIZQ AT DOS_PUNTOS expr PARDER { $vermct = instructions.NewArregloRemovePos($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text, $expr.e)}))) (RULE vectorvacio (returns interfaces.Expression veemct) (BLOCK (ALT ID_VALIDO PUNTO ISEMPTY { $veemct = instructions.NewArregloIsEmpty($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectorcount (returns interfaces.Expression vecnct) (BLOCK (ALT ID_VALIDO PUNTO COUNT { $vecnct = instructions.NewArregloCount($PUNTO.line, $PUNTO.pos, $ID_VALIDO.text)}))) (RULE vectoraccess (returns interfaces.Expression vepposct) (BLOCK (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER listamatrizaddsubs { $masob = instructions.NewMatrizObtencionList($ID_VALIDO.text, $op1.e, $op2.e, $listamatrizaddsubs.blklimatas) }) (ALT ID_VALIDO CORCHIZQ (= op1 expr) CORCHDER CORCHIZQ (= op2 expr) CORCHDER { $masob = instructions.NewMatrizObtencion($ID_VALIDO.text, $op1.e, $op2.e) }) (ALT ID_VALIDO CORCHIZQ expr CORCHDER { $vepposct = instructions.NewArregloAccess($CORCHDER.line, $CORCHDER.pos, $ID_VALIDO.text, $expr.e)}))) (RULE matrizcontrol (returns interfaces.Instruction matct) (BLOCK (ALT VAR ID_VALIDO (? (BLOCK (ALT DOS_PUNTOS tipomatriz))) IG defmatriz {
    if ($DOS_PUNTOS != nil) {
        $matct = instructions.NewMatrizDeclaracion($VAR.line, $VAR.pos, $ID_VALIDO.text ,$tipomatriz.tipomat, $defmatriz.defmat)
    } else {
        $matct = instructions.NewMatrizDeclaracionSinTipo($VAR.line, $VAR.pos, $ID_VALIDO.text , $defmatriz.defmat)
    }
}))) (RULE tipomatriz (returns interfaces.Expression tipomat) (BLOCK (ALT CORCHIZQ tipomatriz CORCHDER { 
    $tipomat = instructions.NewMatrizDimension($CORCHIZQ.line, $CORCHIZQ.pos, $tipomatriz.tipomat)
}) (ALT CORCHIZQ tipodato CORCHDER { 
    $tipomat = instructions.NewMatrizTipo($CORCHIZQ.line, $CORCHIZQ.pos, $tipodato.tipo)
}))) (RULE defmatriz (returns interfaces.Instruction defmat) (BLOCK (ALT listavaloresmat { $defmat = $listavaloresmat.listvlamat}))) (RULE listavaloresmat (returns interfaces.Instruction listvlamat) (BLOCK (ALT CORCHIZQ listavaloresmat2 CORCHDER { $listvlamat = $listavaloresmat2.mylisttmatt}) (ALT simplematriz { $listvlamat = $simplematriz.simmat}))) (RULE listavaloresmat2 (returns interfaces.Instruction mylisttmatt) (BLOCK (ALT (= op listavaloresmat2) COMA listavaloresmat { $mylisttmatt = instructions.NewMatrizListaExpresionList($op.mylisttmatt, $listavaloresmat.listvlamat)}) (ALT listavaloresmat { $mylisttmatt = instructions.NewMatrizListaNivel($listavaloresmat.listvlamat)}) (ALT listaexpresions { $mylisttmatt = instructions.NewMatrizListaExpresion($listaexpresions.blkparf)}))) (RULE listaexpresions (returns []interface{} blkparf) (@ init {
    $blkparf = []interface{}{}
    var listInt []IListaexpresionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= funpar listaexpresion)))) {
    listInt = localctx.(*ListaexpresionsContext).GetFunpar()
    for _, e := range listInt {
        $blkparf = append($blkparf, e.GetFunpar())
    }
}))) (RULE listaexpresion (returns interfaces.Expression funpar) (BLOCK (ALT COMA expr {
    $funpar = instructions.NewArregloParametros($COMA.line ,$COMA.pos, $expr.e)
}) (ALT expr {
    $funpar = instructions.NewArregloParametro($expr.e)
}))) (RULE simplematriz (returns interfaces.Instruction simmat) (BLOCK (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS (= op simplematriz) COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleUno($tipomatriz.tipomat, $op.simmat, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}) (ALT tipomatriz PARIZQ REPEATING DOS_PUNTOS expr COMA COUNT DOS_PUNTOS NUMBER PARDER { $simmat = instructions.NewMatrizSimpleDos($tipomatriz.tipomat, $expr.e, $NUMBER.text, $NUMBER.line,$NUMBER.pos)}))) (RULE matrizasignacion (returns interfaces.Instruction matasig) (BLOCK (ALT ID_VALIDO CORCHIZQ expr CORCHDER listamatrizaddsubs IG expr { $matasig = instructions.NewMatrizAsiginacion($ID_VALIDO.text, $expr.e, $listamatrizaddsubs.blklimatas) }))) (RULE listamatrizaddsubs (returns []interface{} blklimatas) (@ init {
    $blklimatas = []interface{}{}
    var listInt []IListamatrizaddsubContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= lmas listamatrizaddsub)))) {
    listInt = localctx.(*ListamatrizaddsubsContext).GetLmas()
    for _, e := range listInt {
        $blklimatas = append($blklimatas, e.GetLmas())
    }
}))) (RULE listamatrizaddsub (returns interfaces.Expression lmas) (BLOCK (ALT CORCHIZQ expr CORCHDER {
    $lmas = instructions.NewArregloParametros($CORCHIZQ.line ,$CORCHIZQ.pos, $expr.e)
}))) (RULE funciondeclaracioncontrol (BLOCK (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER RETORNO tipodato LLAVEIZQ blockinterno LLAVEDER {}) (ALT FUNCION ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametros))) PARDER LLAVEIZQ blockinterno LLAVEDER {}))) (RULE listaparametros (BLOCK (ALT COMA (? (BLOCK (ALT (SET ID_VALIDO GUIONBAJO)))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato listaparametros {}) (ALT (? (BLOCK (ALT (SET ID_VALIDO GUIONBAJO)))) ID_VALIDO DOS_PUNTOS (? (BLOCK (ALT INOUT))) tipodato {}))) (RULE funcionllamadacontrol (BLOCK (ALT ID_VALIDO PARIZQ (? (BLOCK (ALT listaparametrosllamada))) PARIZQ {}))) (RULE listaparametrosllamada (BLOCK (ALT COMA (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr listaparametrosllamada {}) (ALT (? (BLOCK (ALT ID_VALIDO DOS_PUNTOS))) (? (BLOCK (ALT '&'))) expr {}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE intembebida (returns interfaces.Expression intemb) (BLOCK (ALT INT PARIZQ expr PARDER { $intemb = instructions.NewFuncionIntEmbebida($expr.e)}))) (RULE floatembebida (returns interfaces.Expression floemb) (BLOCK (ALT FLOAT PARIZQ expr PARDER { $floemb = instructions.NewFuncionFloatEmbebida($expr.e)}))) (RULE stringembebida (returns interfaces.Expression stremb) (BLOCK (ALT STRING PARIZQ expr PARDER { $stremb = instructions.NewFuncionStringEmbebida($expr.e)})))))
2023-09-01 12:45:56:373 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"
}) (RULES (RULE T__0 (BLOCK (ALT '&')))))
2023-09-01 12:45:56:394 action-translator LogManager.java:25 translate 
    import "Backend/interfaces"
    import "Backend/environment"
    import "Backend/expressions"
    import "Backend/instructions"
    import "strings"

2023-09-01 12:45:56:480 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op=NOT<tokenIndex=558> right=expr<tokenIndex=562,p=24> { $e = expressions.NewOperation($right.start.GetLine(), $right.start.GetColumn(), $right.e, $op.text, $right.e) } 
        | PARIZQ<tokenIndex=716> expr<tokenIndex=718> PARDER<tokenIndex=720> { $e = $expr.e } 
        | SUB<tokenIndex=726> NUMBER<tokenIndex=728>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num,environment.INTEGER)
        }
    } 
        | NUMBER<tokenIndex=734>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }            
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | CADENA<tokenIndex=740>
    {
        str := $CADENA.text
        $e = expressions.NewPrimitive($CADENA.line, $CADENA.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=746> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=752> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        | CHARACTER<tokenIndex=758> 
    { 
        str := $CHARACTER.text
        $e = expressions.NewPrimitive($CHARACTER.line, $CHARACTER.pos, str[1:len(str)-1], environment.CHARACTER) 
    } 
        | ID_VALIDO<tokenIndex=763>
    {
        id := $ID_VALIDO.text
        $e = instructions.NewCallid($ID_VALIDO.line,$ID_VALIDO.pos,id)
    } 
        | NULO<tokenIndex=768> {$e = expressions.NewPrimitive($NULO.line, $NULO.pos, $NULO.text,environment.NULL)} 
        | vectorvacio<tokenIndex=774> { $e = $vectorvacio.veemct} 
        | vectorcount<tokenIndex=780> { $e = $vectorcount.vecnct} 
        | vectoraccess<tokenIndex=786> { $e = $vectoraccess.vepposct} 
        | intembebida<tokenIndex=792> { $e = $intembebida.intemb} 
        | floatembebida<tokenIndex=798> { $e = $floatembebida.floemb} 
        | stringembebida<tokenIndex=804> { $e = $stringembebida.stremb} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 23)}?<p=23> op=MODULO<tokenIndex=574> right=expr<tokenIndex=578,p=24> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 22)}?<p=22> op=(MUL<tokenIndex=591>|DIV<tokenIndex=593>) right=expr<tokenIndex=598,p=23> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 21)}?<p=21> op=(ADD<tokenIndex=611>|SUB<tokenIndex=613>) right=expr<tokenIndex=618,p=22> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 20)}?<p=20> op=(MAY_IG<tokenIndex=631>|MAYOR<tokenIndex=633>) right=expr<tokenIndex=638,p=21> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 19)}?<p=19> op=(MEN_IG<tokenIndex=651>|MENOR<tokenIndex=653>) right=expr<tokenIndex=658,p=20> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 18)}?<p=18> op=(IG_IG<tokenIndex=671>|DIF<tokenIndex=673>) right=expr<tokenIndex=678,p=19> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 17)}?<p=17> op=AND<tokenIndex=690> right=expr<tokenIndex=694,p=18> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> op=OR<tokenIndex=706> right=expr<tokenIndex=710,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-09-01 12:45:56:495 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 558)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 562) (= p 24)))) { $e = expressions.NewOperation($right.start.GetLine(), $right.start.GetColumn(), $right.e, $op.text, $right.e) }) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 716))) (expr (ELEMENT_OPTIONS (= tokenIndex 718))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 720))) { $e = $expr.e }) (ALT (SUB (ELEMENT_OPTIONS (= tokenIndex 726))) (NUMBER (ELEMENT_OPTIONS (= tokenIndex 728))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,-num,environment.INTEGER)
        }
    }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 734))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        num2 := fmt.Sprintf("%.6f", num)
            num3,err := strconv.ParseFloat(num2, 64);
            if err!= nil{
                fmt.Println(err)
            }
	        $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num3,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }            
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (CADENA (ELEMENT_OPTIONS (= tokenIndex 740))) {
        str := $CADENA.text
        $e = expressions.NewPrimitive($CADENA.line, $CADENA.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 746))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 752))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }) (ALT (CHARACTER (ELEMENT_OPTIONS (= tokenIndex 758))) { 
        str := $CHARACTER.text
        $e = expressions.NewPrimitive($CHARACTER.line, $CHARACTER.pos, str[1:len(str)-1], environment.CHARACTER) 
    }) (ALT (ID_VALIDO (ELEMENT_OPTIONS (= tokenIndex 763))) {
        id := $ID_VALIDO.text
        $e = instructions.NewCallid($ID_VALIDO.line,$ID_VALIDO.pos,id)
    }) (ALT (NULO (ELEMENT_OPTIONS (= tokenIndex 768))) {$e = expressions.NewPrimitive($NULO.line, $NULO.pos, $NULO.text,environment.NULL)}) (ALT (vectorvacio (ELEMENT_OPTIONS (= tokenIndex 774))) { $e = $vectorvacio.veemct}) (ALT (vectorcount (ELEMENT_OPTIONS (= tokenIndex 780))) { $e = $vectorcount.vecnct}) (ALT (vectoraccess (ELEMENT_OPTIONS (= tokenIndex 786))) { $e = $vectoraccess.vepposct}) (ALT (intembebida (ELEMENT_OPTIONS (= tokenIndex 792))) { $e = $intembebida.intemb}) (ALT (floatembebida (ELEMENT_OPTIONS (= tokenIndex 798))) { $e = $floatembebida.floemb}) (ALT (stringembebida (ELEMENT_OPTIONS (= tokenIndex 804))) { $e = $stringembebida.stremb})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 23)}? (ELEMENT_OPTIONS (= p 23))) (= op (MODULO (ELEMENT_OPTIONS (= tokenIndex 574)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 578) (= p 24)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 22)}? (ELEMENT_OPTIONS (= p 22))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 591))) (DIV (ELEMENT_OPTIONS (= tokenIndex 593))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 598) (= p 23)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 21)}? (ELEMENT_OPTIONS (= p 21))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 611))) (SUB (ELEMENT_OPTIONS (= tokenIndex 613))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 618) (= p 22)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 20)}? (ELEMENT_OPTIONS (= p 20))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 631))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 633))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 638) (= p 21)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 19)}? (ELEMENT_OPTIONS (= p 19))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 651))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 653))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 658) (= p 20)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 18)}? (ELEMENT_OPTIONS (= p 18))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 671))) (DIF (ELEMENT_OPTIONS (= tokenIndex 673))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 678) (= p 19)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 17)}? (ELEMENT_OPTIONS (= p 17))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 690)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 694) (= p 18)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 706)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 710) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-09-01 12:45:56:495 left-recursion LogManager.java:25 listavaloresmat2 returns [interfaces.Instruction mylisttmatt]
    :   ( {} listavaloresmat<tokenIndex=1552> { $mylisttmatt = instructions.NewMatrizListaNivel($listavaloresmat.listvlamat)} 
        | listaexpresions<tokenIndex=1558> { $mylisttmatt = instructions.NewMatrizListaExpresion($listaexpresions.blkparf)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 3)}?<p=3> COMA<tokenIndex=1544> listavaloresmat<tokenIndex=1546> { $mylisttmatt = instructions.NewMatrizListaExpresionList($op.mylisttmatt, $listavaloresmat.listvlamat)}
        )*
    ;
2023-09-01 12:45:56:498 grammar LogManager.java:25 added: (RULE listavaloresmat2 (returns interfaces.Instruction mylisttmatt) (BLOCK (ALT (BLOCK (ALT {} (listavaloresmat (ELEMENT_OPTIONS (= tokenIndex 1552))) { $mylisttmatt = instructions.NewMatrizListaNivel($listavaloresmat.listvlamat)}) (ALT (listaexpresions (ELEMENT_OPTIONS (= tokenIndex 1558))) { $mylisttmatt = instructions.NewMatrizListaExpresion($listaexpresions.blkparf)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 3)}? (ELEMENT_OPTIONS (= p 3))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1544))) (listavaloresmat (ELEMENT_OPTIONS (= tokenIndex 1546))) { $mylisttmatt = instructions.NewMatrizListaExpresionList($op.mylisttmatt, $listavaloresmat.listvlamat)}))))))
2023-09-01 12:45:56:511 grammar LogManager.java:25 import INT=1
2023-09-01 12:45:56:511 grammar LogManager.java:25 import FLOAT=2
2023-09-01 12:45:56:512 grammar LogManager.java:25 import STRING=3
2023-09-01 12:45:56:512 grammar LogManager.java:25 import BOOL=4
2023-09-01 12:45:56:512 grammar LogManager.java:25 import CHARACT=5
2023-09-01 12:45:56:512 grammar LogManager.java:25 import TRU=6
2023-09-01 12:45:56:512 grammar LogManager.java:25 import FAL=7
2023-09-01 12:45:56:513 grammar LogManager.java:25 import VAR=8
2023-09-01 12:45:56:513 grammar LogManager.java:25 import LET=9
2023-09-01 12:45:56:513 grammar LogManager.java:25 import NULO=10
2023-09-01 12:45:56:513 grammar LogManager.java:25 import IF=11
2023-09-01 12:45:56:514 grammar LogManager.java:25 import ELSE=12
2023-09-01 12:45:56:514 grammar LogManager.java:25 import SWITCH=13
2023-09-01 12:45:56:514 grammar LogManager.java:25 import CASE=14
2023-09-01 12:45:56:514 grammar LogManager.java:25 import DEFAULT=15
2023-09-01 12:45:56:514 grammar LogManager.java:25 import BREAK=16
2023-09-01 12:45:56:515 grammar LogManager.java:25 import CONTINUE=17
2023-09-01 12:45:56:515 grammar LogManager.java:25 import FOR=18
2023-09-01 12:45:56:515 grammar LogManager.java:25 import IN=19
2023-09-01 12:45:56:515 grammar LogManager.java:25 import RANGO=20
2023-09-01 12:45:56:515 grammar LogManager.java:25 import WHILE=21
2023-09-01 12:45:56:517 grammar LogManager.java:25 import GUARD=22
2023-09-01 12:45:56:517 grammar LogManager.java:25 import RETURN=23
2023-09-01 12:45:56:517 grammar LogManager.java:25 import FUNCION=24
2023-09-01 12:45:56:517 grammar LogManager.java:25 import PRINT=25
2023-09-01 12:45:56:517 grammar LogManager.java:25 import INOUT=26
2023-09-01 12:45:56:518 grammar LogManager.java:25 import APPEND=27
2023-09-01 12:45:56:518 grammar LogManager.java:25 import REMOVE=28
2023-09-01 12:45:56:518 grammar LogManager.java:25 import REMOVELAST=29
2023-09-01 12:45:56:519 grammar LogManager.java:25 import COUNT=30
2023-09-01 12:45:56:519 grammar LogManager.java:25 import ISEMPTY=31
2023-09-01 12:45:56:519 grammar LogManager.java:25 import AT=32
2023-09-01 12:45:56:519 grammar LogManager.java:25 import REPEATING=33
2023-09-01 12:45:56:519 grammar LogManager.java:25 import STRUCT=34
2023-09-01 12:45:56:519 grammar LogManager.java:25 import MUTATING=35
2023-09-01 12:45:56:519 grammar LogManager.java:25 import NUMBER=36
2023-09-01 12:45:56:520 grammar LogManager.java:25 import CADENA=37
2023-09-01 12:45:56:520 grammar LogManager.java:25 import ID_VALIDO=38
2023-09-01 12:45:56:520 grammar LogManager.java:25 import CHARACTER=39
2023-09-01 12:45:56:520 grammar LogManager.java:25 import WS=40
2023-09-01 12:45:56:520 grammar LogManager.java:25 import IG=41
2023-09-01 12:45:56:521 grammar LogManager.java:25 import DOS_PUNTOS=42
2023-09-01 12:45:56:521 grammar LogManager.java:25 import PUNTOCOMA=43
2023-09-01 12:45:56:521 grammar LogManager.java:25 import CIERRE_INTE=44
2023-09-01 12:45:56:521 grammar LogManager.java:25 import PARIZQ=45
2023-09-01 12:45:56:521 grammar LogManager.java:25 import PARDER=46
2023-09-01 12:45:56:522 grammar LogManager.java:25 import DIF=47
2023-09-01 12:45:56:522 grammar LogManager.java:25 import IG_IG=48
2023-09-01 12:45:56:522 grammar LogManager.java:25 import NOT=49
2023-09-01 12:45:56:522 grammar LogManager.java:25 import OR=50
2023-09-01 12:45:56:522 grammar LogManager.java:25 import AND=51
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MAY_IG=52
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MEN_IG=53
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MAYOR=54
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MENOR=55
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MODULO=56
2023-09-01 12:45:56:523 grammar LogManager.java:25 import MUL=57
2023-09-01 12:45:56:524 grammar LogManager.java:25 import DIV=58
2023-09-01 12:45:56:524 grammar LogManager.java:25 import ADD=59
2023-09-01 12:45:56:524 grammar LogManager.java:25 import SUB=60
2023-09-01 12:45:56:524 grammar LogManager.java:25 import SUMA=61
2023-09-01 12:45:56:524 grammar LogManager.java:25 import RESTA=62
2023-09-01 12:45:56:524 grammar LogManager.java:25 import LLAVEIZQ=63
2023-09-01 12:45:56:525 grammar LogManager.java:25 import LLAVEDER=64
2023-09-01 12:45:56:525 grammar LogManager.java:25 import RETORNO=65
2023-09-01 12:45:56:525 grammar LogManager.java:25 import COMA=66
2023-09-01 12:45:56:525 grammar LogManager.java:25 import PUNTO=67
2023-09-01 12:45:56:525 grammar LogManager.java:25 import GUIONBAJO=68
2023-09-01 12:45:56:525 grammar LogManager.java:25 import CORCHIZQ=69
2023-09-01 12:45:56:525 grammar LogManager.java:25 import CORCHDER=70
2023-09-01 12:45:56:525 grammar LogManager.java:25 import WHITESPACE=71
2023-09-01 12:45:56:525 grammar LogManager.java:25 import COMMENT=72
2023-09-01 12:45:56:525 grammar LogManager.java:25 import LINE_COMMENT=73
2023-09-01 12:45:56:525 grammar LogManager.java:25 import 'Int'=1
2023-09-01 12:45:56:525 grammar LogManager.java:25 import 'Float'=2
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'String'=3
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'Bool'=4
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'Character'=5
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'true'=6
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'false'=7
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'var'=8
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'let'=9
2023-09-01 12:45:56:527 grammar LogManager.java:25 import 'nil'=10
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'if'=11
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'else'=12
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'switch'=13
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'case'=14
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'default'=15
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'break'=16
2023-09-01 12:45:56:528 grammar LogManager.java:25 import 'continue'=17
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'for'=18
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'in'=19
2023-09-01 12:45:56:529 grammar LogManager.java:25 import '...'=20
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'while'=21
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'guard'=22
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'return'=23
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'func'=24
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'print'=25
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'inout'=26
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'append'=27
2023-09-01 12:45:56:529 grammar LogManager.java:25 import 'remove'=28
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'removeLast'=29
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'count'=30
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'isEmpty'=31
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'at'=32
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'repeating'=33
2023-09-01 12:45:56:530 grammar LogManager.java:25 import 'struct'=34
2023-09-01 12:45:56:531 grammar LogManager.java:25 import 'mutating'=35
2023-09-01 12:45:56:531 grammar LogManager.java:25 import '='=41
2023-09-01 12:45:56:531 grammar LogManager.java:25 import ':'=42
2023-09-01 12:45:56:531 grammar LogManager.java:25 import ';'=43
2023-09-01 12:45:56:531 grammar LogManager.java:25 import '?'=44
2023-09-01 12:45:56:531 grammar LogManager.java:25 import '('=45
2023-09-01 12:45:56:531 grammar LogManager.java:25 import ')'=46
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '!='=47
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '=='=48
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '!'=49
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '||'=50
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '&&'=51
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '>='=52
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '<='=53
2023-09-01 12:45:56:532 grammar LogManager.java:25 import '>'=54
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '<'=55
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '%'=56
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '*'=57
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '/'=58
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '+'=59
2023-09-01 12:45:56:533 grammar LogManager.java:25 import '-'=60
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '+='=61
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '-='=62
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '{'=63
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '}'=64
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '->'=65
2023-09-01 12:45:56:534 grammar LogManager.java:25 import ','=66
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '.'=67
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '_'=68
2023-09-01 12:45:56:534 grammar LogManager.java:25 import '['=69
2023-09-01 12:45:56:535 grammar LogManager.java:25 import ']'=70
2023-09-01 12:45:56:535 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACT=5, TRU=6, FAL=7, VAR=8, LET=9, NULO=10, IF=11, ELSE=12, SWITCH=13, CASE=14, DEFAULT=15, BREAK=16, CONTINUE=17, FOR=18, IN=19, RANGO=20, WHILE=21, GUARD=22, RETURN=23, FUNCION=24, PRINT=25, INOUT=26, APPEND=27, REMOVE=28, REMOVELAST=29, COUNT=30, ISEMPTY=31, AT=32, REPEATING=33, STRUCT=34, MUTATING=35, NUMBER=36, CADENA=37, ID_VALIDO=38, CHARACTER=39, WS=40, IG=41, DOS_PUNTOS=42, PUNTOCOMA=43, CIERRE_INTE=44, PARIZQ=45, PARDER=46, DIF=47, IG_IG=48, NOT=49, OR=50, AND=51, MAY_IG=52, MEN_IG=53, MAYOR=54, MENOR=55, MODULO=56, MUL=57, DIV=58, ADD=59, SUB=60, SUMA=61, RESTA=62, LLAVEIZQ=63, LLAVEDER=64, RETORNO=65, COMA=66, PUNTO=67, GUIONBAJO=68, CORCHIZQ=69, CORCHDER=70, WHITESPACE=71, COMMENT=72, LINE_COMMENT=73, 'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'var'=8, 'let'=9, 'nil'=10, 'if'=11, 'else'=12, 'switch'=13, 'case'=14, 'default'=15, 'break'=16, 'continue'=17, 'for'=18, 'in'=19, '...'=20, 'while'=21, 'guard'=22, 'return'=23, 'func'=24, 'print'=25, 'inout'=26, 'append'=27, 'remove'=28, 'removeLast'=29, 'count'=30, 'isEmpty'=31, 'at'=32, 'repeating'=33, 'struct'=34, 'mutating'=35, '='=41, ':'=42, ';'=43, '?'=44, '('=45, ')'=46, '!='=47, '=='=48, '!'=49, '||'=50, '&&'=51, '>='=52, '<='=53, '>'=54, '<'=55, '%'=56, '*'=57, '/'=58, '+'=59, '-'=60, '+='=61, '-='=62, '{'=63, '}'=64, '->'=65, ','=66, '.'=67, '_'=68, '['=69, ']'=70}
2023-09-01 12:45:56:535 semantics LogManager.java:25 tokens={EOF=-1, T__0=1, INT=1, FLOAT=2, STRING=3, BOOL=4, CHARACT=5, TRU=6, FAL=7, VAR=8, LET=9, NULO=10, IF=11, ELSE=12, SWITCH=13, CASE=14, DEFAULT=15, BREAK=16, CONTINUE=17, FOR=18, IN=19, RANGO=20, WHILE=21, GUARD=22, RETURN=23, FUNCION=24, PRINT=25, INOUT=26, APPEND=27, REMOVE=28, REMOVELAST=29, COUNT=30, ISEMPTY=31, AT=32, REPEATING=33, STRUCT=34, MUTATING=35, NUMBER=36, CADENA=37, ID_VALIDO=38, CHARACTER=39, WS=40, IG=41, DOS_PUNTOS=42, PUNTOCOMA=43, CIERRE_INTE=44, PARIZQ=45, PARDER=46, DIF=47, IG_IG=48, NOT=49, OR=50, AND=51, MAY_IG=52, MEN_IG=53, MAYOR=54, MENOR=55, MODULO=56, MUL=57, DIV=58, ADD=59, SUB=60, SUMA=61, RESTA=62, LLAVEIZQ=63, LLAVEDER=64, RETORNO=65, COMA=66, PUNTO=67, GUIONBAJO=68, CORCHIZQ=69, CORCHDER=70, WHITESPACE=71, COMMENT=72, LINE_COMMENT=73}
2023-09-01 12:45:56:535 semantics LogManager.java:25 strings={'&'=1, 'Int'=1, 'Float'=2, 'String'=3, 'Bool'=4, 'Character'=5, 'true'=6, 'false'=7, 'var'=8, 'let'=9, 'nil'=10, 'if'=11, 'else'=12, 'switch'=13, 'case'=14, 'default'=15, 'break'=16, 'continue'=17, 'for'=18, 'in'=19, '...'=20, 'while'=21, 'guard'=22, 'return'=23, 'func'=24, 'print'=25, 'inout'=26, 'append'=27, 'remove'=28, 'removeLast'=29, 'count'=30, 'isEmpty'=31, 'at'=32, 'repeating'=33, 'struct'=34, 'mutating'=35, '='=41, ':'=42, ';'=43, '?'=44, '('=45, ')'=46, '!='=47, '=='=48, '!'=49, '||'=50, '&&'=51, '>='=52, '<='=53, '>'=54, '<'=55, '%'=56, '*'=57, '/'=58, '+'=59, '-'=60, '+='=61, '-='=62, '{'=63, '}'=64, '->'=65, ','=66, '.'=67, '_'=68, '['=69, ']'=70}
