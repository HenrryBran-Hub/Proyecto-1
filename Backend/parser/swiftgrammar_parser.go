// Code generated from SwiftGrammar.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // SwiftGrammar
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

import "Backend/interfaces"
import "Backend/environment"
import "Backend/expressions"
import "Backend/instructions"
import "strings"

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type SwiftGrammarParser struct {
	*antlr.BaseParser
}

var SwiftGrammarParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func swiftgrammarParserInit() {
	staticData := &SwiftGrammarParserStaticData
	staticData.LiteralNames = []string{
		"", "'Int'", "'Float'", "'String'", "'Bool'", "'Character'", "'true'",
		"'false'", "'var'", "'let'", "'nil'", "'if'", "'else'", "'switch'",
		"'case'", "'default'", "'break'", "'continue'", "'for'", "'in'", "'...'",
		"'while'", "'guard'", "'return'", "'func'", "'print'", "'inout'", "'append'",
		"'remove'", "'removeLast'", "'count'", "'isEmpty'", "'at'", "'repeating'",
		"'struct'", "'mutating'", "'self'", "", "", "", "", "", "'='", "':'",
		"';'", "'?'", "'('", "')'", "'!='", "'=='", "'!'", "'||'", "'&&'", "'>='",
		"'<='", "'>'", "'<'", "'%'", "'*'", "'/'", "'+'", "'-'", "'+='", "'-='",
		"'{'", "'}'", "'->'", "','", "'.'", "'_'", "'['", "']'",
	}
	staticData.SymbolicNames = []string{
		"", "", "FLOAT", "STRING", "BOOL", "CHARACT", "TRU", "FAL", "VAR", "LET",
		"NULO", "IF", "ELSE", "SWITCH", "CASE", "DEFAULT", "BREAK", "CONTINUE",
		"FOR", "IN", "RANGO", "WHILE", "GUARD", "RETURN", "FUNCION", "PRINT",
		"INOUT", "APPEND", "REMOVE", "REMOVELAST", "COUNT", "ISEMPTY", "AT",
		"REPEATING", "STRUCT", "MUTATING", "SELF", "NUMBER", "CADENA", "ID_VALIDO",
		"CHARACTER", "WS", "IG", "DOS_PUNTOS", "PUNTOCOMA", "CIERRE_INTE", "PARIZQ",
		"PARDER", "DIF", "IG_IG", "NOT", "OR", "AND", "MAY_IG", "MEN_IG", "MAYOR",
		"MENOR", "MODULO", "MUL", "DIV", "ADD", "SUB", "SUMA", "RESTA", "LLAVEIZQ",
		"LLAVEDER", "RETORNO", "COMA", "PUNTO", "GUIONBAJO", "CORCHIZQ", "CORCHDER",
		"WHITESPACE", "COMMENT", "LINE_COMMENT",
	}
	staticData.RuleNames = []string{
		"s", "block", "instruction", "blockinterno", "instructionint", "declavarible",
		"declaconstante", "asignacionvariable", "tipodato", "expr", "sentenciaifelse",
		"switchcontrol", "blockcase", "bloquecase", "whilecontrol", "forcontrol",
		"guardcontrol", "continuee", "breakk", "retornos", "vectorcontrol",
		"blockparams", "bloqueparams", "vectoragregar", "vectorremover", "vectorvacio",
		"vectorcount", "vectoraccess", "matrizcontrol", "tipomatriz", "defmatriz",
		"listavaloresmat", "listavaloresmat2", "listaexpresions", "listaexpresion",
		"simplematriz", "listamatrizaddsubs", "listamatrizaddsub", "structcontrol",
		"listaatributos", "listaatributo", "structexpr", "l_dupla", "llamadastruct",
		"asignacionparametrostruct", "llamadafuncionstruct", "funciondeclaracioncontrol",
		"listaparametro", "funcionllamadacontrol", "listaparametrosllamada",
		"printstmt", "intembebida", "floatembebida", "stringembebida",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 74, 1036, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 4, 1, 114, 8, 1, 11, 1,
		12, 1, 115, 1, 1, 1, 1, 1, 2, 1, 2, 3, 2, 122, 8, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 3, 2, 128, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 134, 8, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 155, 8, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 167, 8, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 173, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 3, 2, 183, 8, 2, 1, 3, 4, 3, 186, 8, 3, 11, 3, 12, 3, 187, 1, 3, 1,
		3, 1, 4, 1, 4, 3, 4, 194, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 200, 8, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 206, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 227, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 233, 8, 4, 1,
		4, 1, 4, 1, 4, 1, 4, 3, 4, 239, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 245,
		8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 251, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4,
		3, 4, 257, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 263, 8, 4, 1, 4, 1, 4, 3,
		4, 267, 8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 290, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1,
		6, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 306, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 323,
		8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		335, 8, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 9,
		382, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 424, 8, 9, 10, 9, 12, 9, 427,
		9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10,
		1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 456, 8, 10, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 465, 8, 11, 1, 11,
		1, 11, 1, 11, 1, 12, 4, 12, 471, 8, 12, 11, 12, 12, 12, 472, 1, 12, 1,
		12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 3, 15, 510, 8, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 532, 8, 19, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20,
		1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 567,
		8, 20, 1, 21, 4, 21, 570, 8, 21, 11, 21, 12, 21, 571, 1, 21, 1, 21, 1,
		22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 583, 8, 22, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1,
		23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 635, 8, 23, 1,
		24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 653, 8, 24, 1, 25, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27,
		1, 27, 3, 27, 690, 8, 27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 696, 8, 28,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 3, 29, 712, 8, 29, 1, 30, 1, 30, 1, 30, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 725, 8, 31, 1,
		32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 734, 8, 32, 1, 32,
		1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 741, 8, 32, 10, 32, 12, 32, 744, 9,
		32, 1, 33, 4, 33, 747, 8, 33, 11, 33, 12, 33, 748, 1, 33, 1, 33, 1, 34,
		1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 760, 8, 34, 1, 35, 1,
		35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35,
		1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1,
		35, 1, 35, 3, 35, 786, 8, 35, 1, 36, 4, 36, 789, 8, 36, 11, 36, 12, 36,
		790, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 4, 39, 808, 8, 39, 11, 39, 12, 39,
		809, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 819, 8, 40,
		1, 40, 1, 40, 3, 40, 823, 8, 40, 1, 40, 3, 40, 826, 8, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 833, 8, 40, 1, 40, 3, 40, 836, 8, 40, 1, 40,
		1, 40, 3, 40, 840, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 845, 8, 40, 1, 41,
		1, 41, 1, 41, 1, 41, 3, 41, 851, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 856,
		8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 863, 8, 41, 1, 41, 1,
		41, 3, 41, 867, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 874, 8,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 880, 8, 41, 1, 42, 1, 42, 1, 42,
		4, 42, 885, 8, 42, 11, 42, 12, 42, 886, 1, 42, 1, 42, 1, 43, 1, 43, 1,
		43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 45,
		1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1,
		46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46,
		1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 952, 8, 46, 1, 47, 3,
		47, 955, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 960, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 968, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47,
		973, 8, 47, 1, 47, 1, 47, 1, 47, 3, 47, 978, 8, 47, 1, 48, 1, 48, 1, 48,
		3, 48, 983, 8, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 3, 49, 991,
		8, 49, 1, 49, 3, 49, 994, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		49, 3, 49, 1002, 8, 49, 1, 49, 3, 49, 1005, 8, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 1010, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51, 1,
		51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 0, 2, 18, 64, 54, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 0, 7, 1,
		0, 58, 59, 1, 0, 60, 61, 2, 0, 53, 53, 55, 55, 2, 0, 54, 54, 56, 56, 1,
		0, 48, 49, 1, 0, 8, 9, 2, 0, 39, 39, 69, 69, 1116, 0, 108, 1, 0, 0, 0,
		2, 113, 1, 0, 0, 0, 4, 182, 1, 0, 0, 0, 6, 185, 1, 0, 0, 0, 8, 266, 1,
		0, 0, 0, 10, 289, 1, 0, 0, 0, 12, 305, 1, 0, 0, 0, 14, 322, 1, 0, 0, 0,
		16, 334, 1, 0, 0, 0, 18, 381, 1, 0, 0, 0, 20, 455, 1, 0, 0, 0, 22, 457,
		1, 0, 0, 0, 24, 470, 1, 0, 0, 0, 26, 476, 1, 0, 0, 0, 28, 482, 1, 0, 0,
		0, 30, 509, 1, 0, 0, 0, 32, 511, 1, 0, 0, 0, 34, 519, 1, 0, 0, 0, 36, 522,
		1, 0, 0, 0, 38, 531, 1, 0, 0, 0, 40, 566, 1, 0, 0, 0, 42, 569, 1, 0, 0,
		0, 44, 582, 1, 0, 0, 0, 46, 634, 1, 0, 0, 0, 48, 652, 1, 0, 0, 0, 50, 654,
		1, 0, 0, 0, 52, 659, 1, 0, 0, 0, 54, 689, 1, 0, 0, 0, 56, 691, 1, 0, 0,
		0, 58, 711, 1, 0, 0, 0, 60, 713, 1, 0, 0, 0, 62, 724, 1, 0, 0, 0, 64, 733,
		1, 0, 0, 0, 66, 746, 1, 0, 0, 0, 68, 759, 1, 0, 0, 0, 70, 785, 1, 0, 0,
		0, 72, 788, 1, 0, 0, 0, 74, 794, 1, 0, 0, 0, 76, 799, 1, 0, 0, 0, 78, 807,
		1, 0, 0, 0, 80, 844, 1, 0, 0, 0, 82, 879, 1, 0, 0, 0, 84, 884, 1, 0, 0,
		0, 86, 890, 1, 0, 0, 0, 88, 895, 1, 0, 0, 0, 90, 902, 1, 0, 0, 0, 92, 951,
		1, 0, 0, 0, 94, 977, 1, 0, 0, 0, 96, 979, 1, 0, 0, 0, 98, 1009, 1, 0, 0,
		0, 100, 1011, 1, 0, 0, 0, 102, 1017, 1, 0, 0, 0, 104, 1023, 1, 0, 0, 0,
		106, 1029, 1, 0, 0, 0, 108, 109, 3, 2, 1, 0, 109, 110, 5, 0, 0, 1, 110,
		111, 6, 0, -1, 0, 111, 1, 1, 0, 0, 0, 112, 114, 3, 4, 2, 0, 113, 112, 1,
		0, 0, 0, 114, 115, 1, 0, 0, 0, 115, 113, 1, 0, 0, 0, 115, 116, 1, 0, 0,
		0, 116, 117, 1, 0, 0, 0, 117, 118, 6, 1, -1, 0, 118, 3, 1, 0, 0, 0, 119,
		121, 3, 10, 5, 0, 120, 122, 5, 44, 0, 0, 121, 120, 1, 0, 0, 0, 121, 122,
		1, 0, 0, 0, 122, 123, 1, 0, 0, 0, 123, 124, 6, 2, -1, 0, 124, 183, 1, 0,
		0, 0, 125, 127, 3, 12, 6, 0, 126, 128, 5, 44, 0, 0, 127, 126, 1, 0, 0,
		0, 127, 128, 1, 0, 0, 0, 128, 129, 1, 0, 0, 0, 129, 130, 6, 2, -1, 0, 130,
		183, 1, 0, 0, 0, 131, 133, 3, 14, 7, 0, 132, 134, 5, 44, 0, 0, 133, 132,
		1, 0, 0, 0, 133, 134, 1, 0, 0, 0, 134, 135, 1, 0, 0, 0, 135, 136, 6, 2,
		-1, 0, 136, 183, 1, 0, 0, 0, 137, 138, 3, 20, 10, 0, 138, 139, 6, 2, -1,
		0, 139, 183, 1, 0, 0, 0, 140, 141, 3, 22, 11, 0, 141, 142, 6, 2, -1, 0,
		142, 183, 1, 0, 0, 0, 143, 144, 3, 28, 14, 0, 144, 145, 6, 2, -1, 0, 145,
		183, 1, 0, 0, 0, 146, 147, 3, 30, 15, 0, 147, 148, 6, 2, -1, 0, 148, 183,
		1, 0, 0, 0, 149, 150, 3, 32, 16, 0, 150, 151, 6, 2, -1, 0, 151, 183, 1,
		0, 0, 0, 152, 154, 3, 40, 20, 0, 153, 155, 5, 44, 0, 0, 154, 153, 1, 0,
		0, 0, 154, 155, 1, 0, 0, 0, 155, 156, 1, 0, 0, 0, 156, 157, 6, 2, -1, 0,
		157, 183, 1, 0, 0, 0, 158, 159, 3, 46, 23, 0, 159, 160, 6, 2, -1, 0, 160,
		183, 1, 0, 0, 0, 161, 162, 3, 48, 24, 0, 162, 163, 6, 2, -1, 0, 163, 183,
		1, 0, 0, 0, 164, 166, 3, 100, 50, 0, 165, 167, 5, 44, 0, 0, 166, 165, 1,
		0, 0, 0, 166, 167, 1, 0, 0, 0, 167, 168, 1, 0, 0, 0, 168, 169, 6, 2, -1,
		0, 169, 183, 1, 0, 0, 0, 170, 172, 3, 56, 28, 0, 171, 173, 5, 44, 0, 0,
		172, 171, 1, 0, 0, 0, 172, 173, 1, 0, 0, 0, 173, 174, 1, 0, 0, 0, 174,
		175, 6, 2, -1, 0, 175, 183, 1, 0, 0, 0, 176, 177, 3, 76, 38, 0, 177, 178,
		6, 2, -1, 0, 178, 183, 1, 0, 0, 0, 179, 180, 3, 92, 46, 0, 180, 181, 6,
		2, -1, 0, 181, 183, 1, 0, 0, 0, 182, 119, 1, 0, 0, 0, 182, 125, 1, 0, 0,
		0, 182, 131, 1, 0, 0, 0, 182, 137, 1, 0, 0, 0, 182, 140, 1, 0, 0, 0, 182,
		143, 1, 0, 0, 0, 182, 146, 1, 0, 0, 0, 182, 149, 1, 0, 0, 0, 182, 152,
		1, 0, 0, 0, 182, 158, 1, 0, 0, 0, 182, 161, 1, 0, 0, 0, 182, 164, 1, 0,
		0, 0, 182, 170, 1, 0, 0, 0, 182, 176, 1, 0, 0, 0, 182, 179, 1, 0, 0, 0,
		183, 5, 1, 0, 0, 0, 184, 186, 3, 8, 4, 0, 185, 184, 1, 0, 0, 0, 186, 187,
		1, 0, 0, 0, 187, 185, 1, 0, 0, 0, 187, 188, 1, 0, 0, 0, 188, 189, 1, 0,
		0, 0, 189, 190, 6, 3, -1, 0, 190, 7, 1, 0, 0, 0, 191, 193, 3, 10, 5, 0,
		192, 194, 5, 44, 0, 0, 193, 192, 1, 0, 0, 0, 193, 194, 1, 0, 0, 0, 194,
		195, 1, 0, 0, 0, 195, 196, 6, 4, -1, 0, 196, 267, 1, 0, 0, 0, 197, 199,
		3, 12, 6, 0, 198, 200, 5, 44, 0, 0, 199, 198, 1, 0, 0, 0, 199, 200, 1,
		0, 0, 0, 200, 201, 1, 0, 0, 0, 201, 202, 6, 4, -1, 0, 202, 267, 1, 0, 0,
		0, 203, 205, 3, 14, 7, 0, 204, 206, 5, 44, 0, 0, 205, 204, 1, 0, 0, 0,
		205, 206, 1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 208, 6, 4, -1, 0, 208,
		267, 1, 0, 0, 0, 209, 210, 3, 20, 10, 0, 210, 211, 6, 4, -1, 0, 211, 267,
		1, 0, 0, 0, 212, 213, 3, 22, 11, 0, 213, 214, 6, 4, -1, 0, 214, 267, 1,
		0, 0, 0, 215, 216, 3, 28, 14, 0, 216, 217, 6, 4, -1, 0, 217, 267, 1, 0,
		0, 0, 218, 219, 3, 30, 15, 0, 219, 220, 6, 4, -1, 0, 220, 267, 1, 0, 0,
		0, 221, 222, 3, 32, 16, 0, 222, 223, 6, 4, -1, 0, 223, 267, 1, 0, 0, 0,
		224, 226, 3, 34, 17, 0, 225, 227, 5, 44, 0, 0, 226, 225, 1, 0, 0, 0, 226,
		227, 1, 0, 0, 0, 227, 228, 1, 0, 0, 0, 228, 229, 6, 4, -1, 0, 229, 267,
		1, 0, 0, 0, 230, 232, 3, 36, 18, 0, 231, 233, 5, 44, 0, 0, 232, 231, 1,
		0, 0, 0, 232, 233, 1, 0, 0, 0, 233, 234, 1, 0, 0, 0, 234, 235, 6, 4, -1,
		0, 235, 267, 1, 0, 0, 0, 236, 238, 3, 38, 19, 0, 237, 239, 5, 44, 0, 0,
		238, 237, 1, 0, 0, 0, 238, 239, 1, 0, 0, 0, 239, 240, 1, 0, 0, 0, 240,
		241, 6, 4, -1, 0, 241, 267, 1, 0, 0, 0, 242, 244, 3, 40, 20, 0, 243, 245,
		5, 44, 0, 0, 244, 243, 1, 0, 0, 0, 244, 245, 1, 0, 0, 0, 245, 246, 1, 0,
		0, 0, 246, 247, 6, 4, -1, 0, 247, 267, 1, 0, 0, 0, 248, 250, 3, 46, 23,
		0, 249, 251, 5, 44, 0, 0, 250, 249, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251,
		252, 1, 0, 0, 0, 252, 253, 6, 4, -1, 0, 253, 267, 1, 0, 0, 0, 254, 256,
		3, 48, 24, 0, 255, 257, 5, 44, 0, 0, 256, 255, 1, 0, 0, 0, 256, 257, 1,
		0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 259, 6, 4, -1, 0, 259, 267, 1, 0, 0,
		0, 260, 262, 3, 100, 50, 0, 261, 263, 5, 44, 0, 0, 262, 261, 1, 0, 0, 0,
		262, 263, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265, 6, 4, -1, 0, 265,
		267, 1, 0, 0, 0, 266, 191, 1, 0, 0, 0, 266, 197, 1, 0, 0, 0, 266, 203,
		1, 0, 0, 0, 266, 209, 1, 0, 0, 0, 266, 212, 1, 0, 0, 0, 266, 215, 1, 0,
		0, 0, 266, 218, 1, 0, 0, 0, 266, 221, 1, 0, 0, 0, 266, 224, 1, 0, 0, 0,
		266, 230, 1, 0, 0, 0, 266, 236, 1, 0, 0, 0, 266, 242, 1, 0, 0, 0, 266,
		248, 1, 0, 0, 0, 266, 254, 1, 0, 0, 0, 266, 260, 1, 0, 0, 0, 267, 9, 1,
		0, 0, 0, 268, 269, 5, 8, 0, 0, 269, 270, 5, 39, 0, 0, 270, 271, 5, 43,
		0, 0, 271, 272, 3, 16, 8, 0, 272, 273, 5, 42, 0, 0, 273, 274, 3, 18, 9,
		0, 274, 275, 6, 5, -1, 0, 275, 290, 1, 0, 0, 0, 276, 277, 5, 8, 0, 0, 277,
		278, 5, 39, 0, 0, 278, 279, 5, 42, 0, 0, 279, 280, 3, 18, 9, 0, 280, 281,
		6, 5, -1, 0, 281, 290, 1, 0, 0, 0, 282, 283, 5, 8, 0, 0, 283, 284, 5, 39,
		0, 0, 284, 285, 5, 43, 0, 0, 285, 286, 3, 16, 8, 0, 286, 287, 5, 45, 0,
		0, 287, 288, 6, 5, -1, 0, 288, 290, 1, 0, 0, 0, 289, 268, 1, 0, 0, 0, 289,
		276, 1, 0, 0, 0, 289, 282, 1, 0, 0, 0, 290, 11, 1, 0, 0, 0, 291, 292, 5,
		9, 0, 0, 292, 293, 5, 39, 0, 0, 293, 294, 5, 43, 0, 0, 294, 295, 3, 16,
		8, 0, 295, 296, 5, 42, 0, 0, 296, 297, 3, 18, 9, 0, 297, 298, 6, 6, -1,
		0, 298, 306, 1, 0, 0, 0, 299, 300, 5, 9, 0, 0, 300, 301, 5, 39, 0, 0, 301,
		302, 5, 42, 0, 0, 302, 303, 3, 18, 9, 0, 303, 304, 6, 6, -1, 0, 304, 306,
		1, 0, 0, 0, 305, 291, 1, 0, 0, 0, 305, 299, 1, 0, 0, 0, 306, 13, 1, 0,
		0, 0, 307, 308, 5, 39, 0, 0, 308, 309, 5, 42, 0, 0, 309, 310, 3, 18, 9,
		0, 310, 311, 6, 7, -1, 0, 311, 323, 1, 0, 0, 0, 312, 313, 5, 39, 0, 0,
		313, 314, 5, 62, 0, 0, 314, 315, 3, 18, 9, 0, 315, 316, 6, 7, -1, 0, 316,
		323, 1, 0, 0, 0, 317, 318, 5, 39, 0, 0, 318, 319, 5, 63, 0, 0, 319, 320,
		3, 18, 9, 0, 320, 321, 6, 7, -1, 0, 321, 323, 1, 0, 0, 0, 322, 307, 1,
		0, 0, 0, 322, 312, 1, 0, 0, 0, 322, 317, 1, 0, 0, 0, 323, 15, 1, 0, 0,
		0, 324, 325, 5, 1, 0, 0, 325, 335, 6, 8, -1, 0, 326, 327, 5, 2, 0, 0, 327,
		335, 6, 8, -1, 0, 328, 329, 5, 3, 0, 0, 329, 335, 6, 8, -1, 0, 330, 331,
		5, 4, 0, 0, 331, 335, 6, 8, -1, 0, 332, 333, 5, 5, 0, 0, 333, 335, 6, 8,
		-1, 0, 334, 324, 1, 0, 0, 0, 334, 326, 1, 0, 0, 0, 334, 328, 1, 0, 0, 0,
		334, 330, 1, 0, 0, 0, 334, 332, 1, 0, 0, 0, 335, 17, 1, 0, 0, 0, 336, 337,
		6, 9, -1, 0, 337, 338, 5, 50, 0, 0, 338, 339, 3, 18, 9, 24, 339, 340, 6,
		9, -1, 0, 340, 382, 1, 0, 0, 0, 341, 342, 5, 46, 0, 0, 342, 343, 3, 18,
		9, 0, 343, 344, 5, 47, 0, 0, 344, 345, 6, 9, -1, 0, 345, 382, 1, 0, 0,
		0, 346, 347, 5, 61, 0, 0, 347, 348, 5, 37, 0, 0, 348, 382, 6, 9, -1, 0,
		349, 350, 5, 37, 0, 0, 350, 382, 6, 9, -1, 0, 351, 352, 5, 38, 0, 0, 352,
		382, 6, 9, -1, 0, 353, 354, 5, 6, 0, 0, 354, 382, 6, 9, -1, 0, 355, 356,
		5, 7, 0, 0, 356, 382, 6, 9, -1, 0, 357, 358, 5, 40, 0, 0, 358, 382, 6,
		9, -1, 0, 359, 360, 5, 39, 0, 0, 360, 382, 6, 9, -1, 0, 361, 362, 5, 10,
		0, 0, 362, 382, 6, 9, -1, 0, 363, 364, 3, 50, 25, 0, 364, 365, 6, 9, -1,
		0, 365, 382, 1, 0, 0, 0, 366, 367, 3, 52, 26, 0, 367, 368, 6, 9, -1, 0,
		368, 382, 1, 0, 0, 0, 369, 370, 3, 54, 27, 0, 370, 371, 6, 9, -1, 0, 371,
		382, 1, 0, 0, 0, 372, 373, 3, 102, 51, 0, 373, 374, 6, 9, -1, 0, 374, 382,
		1, 0, 0, 0, 375, 376, 3, 104, 52, 0, 376, 377, 6, 9, -1, 0, 377, 382, 1,
		0, 0, 0, 378, 379, 3, 106, 53, 0, 379, 380, 6, 9, -1, 0, 380, 382, 1, 0,
		0, 0, 381, 336, 1, 0, 0, 0, 381, 341, 1, 0, 0, 0, 381, 346, 1, 0, 0, 0,
		381, 349, 1, 0, 0, 0, 381, 351, 1, 0, 0, 0, 381, 353, 1, 0, 0, 0, 381,
		355, 1, 0, 0, 0, 381, 357, 1, 0, 0, 0, 381, 359, 1, 0, 0, 0, 381, 361,
		1, 0, 0, 0, 381, 363, 1, 0, 0, 0, 381, 366, 1, 0, 0, 0, 381, 369, 1, 0,
		0, 0, 381, 372, 1, 0, 0, 0, 381, 375, 1, 0, 0, 0, 381, 378, 1, 0, 0, 0,
		382, 425, 1, 0, 0, 0, 383, 384, 10, 23, 0, 0, 384, 385, 5, 57, 0, 0, 385,
		386, 3, 18, 9, 24, 386, 387, 6, 9, -1, 0, 387, 424, 1, 0, 0, 0, 388, 389,
		10, 22, 0, 0, 389, 390, 7, 0, 0, 0, 390, 391, 3, 18, 9, 23, 391, 392, 6,
		9, -1, 0, 392, 424, 1, 0, 0, 0, 393, 394, 10, 21, 0, 0, 394, 395, 7, 1,
		0, 0, 395, 396, 3, 18, 9, 22, 396, 397, 6, 9, -1, 0, 397, 424, 1, 0, 0,
		0, 398, 399, 10, 20, 0, 0, 399, 400, 7, 2, 0, 0, 400, 401, 3, 18, 9, 21,
		401, 402, 6, 9, -1, 0, 402, 424, 1, 0, 0, 0, 403, 404, 10, 19, 0, 0, 404,
		405, 7, 3, 0, 0, 405, 406, 3, 18, 9, 20, 406, 407, 6, 9, -1, 0, 407, 424,
		1, 0, 0, 0, 408, 409, 10, 18, 0, 0, 409, 410, 7, 4, 0, 0, 410, 411, 3,
		18, 9, 19, 411, 412, 6, 9, -1, 0, 412, 424, 1, 0, 0, 0, 413, 414, 10, 17,
		0, 0, 414, 415, 5, 52, 0, 0, 415, 416, 3, 18, 9, 18, 416, 417, 6, 9, -1,
		0, 417, 424, 1, 0, 0, 0, 418, 419, 10, 16, 0, 0, 419, 420, 5, 51, 0, 0,
		420, 421, 3, 18, 9, 17, 421, 422, 6, 9, -1, 0, 422, 424, 1, 0, 0, 0, 423,
		383, 1, 0, 0, 0, 423, 388, 1, 0, 0, 0, 423, 393, 1, 0, 0, 0, 423, 398,
		1, 0, 0, 0, 423, 403, 1, 0, 0, 0, 423, 408, 1, 0, 0, 0, 423, 413, 1, 0,
		0, 0, 423, 418, 1, 0, 0, 0, 424, 427, 1, 0, 0, 0, 425, 423, 1, 0, 0, 0,
		425, 426, 1, 0, 0, 0, 426, 19, 1, 0, 0, 0, 427, 425, 1, 0, 0, 0, 428, 429,
		5, 11, 0, 0, 429, 430, 3, 18, 9, 0, 430, 431, 5, 64, 0, 0, 431, 432, 3,
		6, 3, 0, 432, 433, 5, 65, 0, 0, 433, 434, 6, 10, -1, 0, 434, 456, 1, 0,
		0, 0, 435, 436, 5, 11, 0, 0, 436, 437, 3, 18, 9, 0, 437, 438, 5, 64, 0,
		0, 438, 439, 3, 6, 3, 0, 439, 440, 5, 65, 0, 0, 440, 441, 5, 12, 0, 0,
		441, 442, 5, 64, 0, 0, 442, 443, 3, 6, 3, 0, 443, 444, 5, 65, 0, 0, 444,
		445, 6, 10, -1, 0, 445, 456, 1, 0, 0, 0, 446, 447, 5, 11, 0, 0, 447, 448,
		3, 18, 9, 0, 448, 449, 5, 64, 0, 0, 449, 450, 3, 6, 3, 0, 450, 451, 5,
		65, 0, 0, 451, 452, 5, 12, 0, 0, 452, 453, 3, 20, 10, 0, 453, 454, 6, 10,
		-1, 0, 454, 456, 1, 0, 0, 0, 455, 428, 1, 0, 0, 0, 455, 435, 1, 0, 0, 0,
		455, 446, 1, 0, 0, 0, 456, 21, 1, 0, 0, 0, 457, 458, 5, 13, 0, 0, 458,
		459, 3, 18, 9, 0, 459, 460, 5, 64, 0, 0, 460, 464, 3, 24, 12, 0, 461, 462,
		5, 15, 0, 0, 462, 463, 5, 43, 0, 0, 463, 465, 3, 6, 3, 0, 464, 461, 1,
		0, 0, 0, 464, 465, 1, 0, 0, 0, 465, 466, 1, 0, 0, 0, 466, 467, 5, 65, 0,
		0, 467, 468, 6, 11, -1, 0, 468, 23, 1, 0, 0, 0, 469, 471, 3, 26, 13, 0,
		470, 469, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472,
		473, 1, 0, 0, 0, 473, 474, 1, 0, 0, 0, 474, 475, 6, 12, -1, 0, 475, 25,
		1, 0, 0, 0, 476, 477, 5, 14, 0, 0, 477, 478, 3, 18, 9, 0, 478, 479, 5,
		43, 0, 0, 479, 480, 3, 6, 3, 0, 480, 481, 6, 13, -1, 0, 481, 27, 1, 0,
		0, 0, 482, 483, 5, 21, 0, 0, 483, 484, 3, 18, 9, 0, 484, 485, 5, 64, 0,
		0, 485, 486, 3, 6, 3, 0, 486, 487, 5, 65, 0, 0, 487, 488, 6, 14, -1, 0,
		488, 29, 1, 0, 0, 0, 489, 490, 5, 18, 0, 0, 490, 491, 5, 39, 0, 0, 491,
		492, 5, 19, 0, 0, 492, 493, 3, 18, 9, 0, 493, 494, 5, 20, 0, 0, 494, 495,
		3, 18, 9, 0, 495, 496, 5, 64, 0, 0, 496, 497, 3, 6, 3, 0, 497, 498, 5,
		65, 0, 0, 498, 499, 6, 15, -1, 0, 499, 510, 1, 0, 0, 0, 500, 501, 5, 18,
		0, 0, 501, 502, 5, 39, 0, 0, 502, 503, 5, 19, 0, 0, 503, 504, 3, 18, 9,
		0, 504, 505, 5, 64, 0, 0, 505, 506, 3, 6, 3, 0, 506, 507, 5, 65, 0, 0,
		507, 508, 6, 15, -1, 0, 508, 510, 1, 0, 0, 0, 509, 489, 1, 0, 0, 0, 509,
		500, 1, 0, 0, 0, 510, 31, 1, 0, 0, 0, 511, 512, 5, 22, 0, 0, 512, 513,
		3, 18, 9, 0, 513, 514, 5, 12, 0, 0, 514, 515, 5, 64, 0, 0, 515, 516, 3,
		6, 3, 0, 516, 517, 5, 65, 0, 0, 517, 518, 6, 16, -1, 0, 518, 33, 1, 0,
		0, 0, 519, 520, 5, 17, 0, 0, 520, 521, 6, 17, -1, 0, 521, 35, 1, 0, 0,
		0, 522, 523, 5, 16, 0, 0, 523, 524, 6, 18, -1, 0, 524, 37, 1, 0, 0, 0,
		525, 526, 5, 23, 0, 0, 526, 532, 6, 19, -1, 0, 527, 528, 5, 23, 0, 0, 528,
		529, 3, 18, 9, 0, 529, 530, 6, 19, -1, 0, 530, 532, 1, 0, 0, 0, 531, 525,
		1, 0, 0, 0, 531, 527, 1, 0, 0, 0, 532, 39, 1, 0, 0, 0, 533, 534, 5, 8,
		0, 0, 534, 535, 5, 39, 0, 0, 535, 536, 5, 43, 0, 0, 536, 537, 5, 70, 0,
		0, 537, 538, 3, 16, 8, 0, 538, 539, 5, 71, 0, 0, 539, 540, 5, 42, 0, 0,
		540, 541, 5, 70, 0, 0, 541, 542, 3, 42, 21, 0, 542, 543, 5, 71, 0, 0, 543,
		544, 6, 20, -1, 0, 544, 567, 1, 0, 0, 0, 545, 546, 5, 8, 0, 0, 546, 547,
		5, 39, 0, 0, 547, 548, 5, 43, 0, 0, 548, 549, 5, 70, 0, 0, 549, 550, 3,
		16, 8, 0, 550, 551, 5, 71, 0, 0, 551, 552, 5, 42, 0, 0, 552, 553, 5, 70,
		0, 0, 553, 554, 5, 71, 0, 0, 554, 555, 6, 20, -1, 0, 555, 567, 1, 0, 0,
		0, 556, 557, 5, 8, 0, 0, 557, 558, 5, 39, 0, 0, 558, 559, 5, 43, 0, 0,
		559, 560, 5, 70, 0, 0, 560, 561, 3, 16, 8, 0, 561, 562, 5, 71, 0, 0, 562,
		563, 5, 42, 0, 0, 563, 564, 5, 39, 0, 0, 564, 565, 6, 20, -1, 0, 565, 567,
		1, 0, 0, 0, 566, 533, 1, 0, 0, 0, 566, 545, 1, 0, 0, 0, 566, 556, 1, 0,
		0, 0, 567, 41, 1, 0, 0, 0, 568, 570, 3, 44, 22, 0, 569, 568, 1, 0, 0, 0,
		570, 571, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572,
		573, 1, 0, 0, 0, 573, 574, 6, 21, -1, 0, 574, 43, 1, 0, 0, 0, 575, 576,
		5, 67, 0, 0, 576, 577, 3, 18, 9, 0, 577, 578, 6, 22, -1, 0, 578, 583, 1,
		0, 0, 0, 579, 580, 3, 18, 9, 0, 580, 581, 6, 22, -1, 0, 581, 583, 1, 0,
		0, 0, 582, 575, 1, 0, 0, 0, 582, 579, 1, 0, 0, 0, 583, 45, 1, 0, 0, 0,
		584, 585, 5, 39, 0, 0, 585, 586, 5, 68, 0, 0, 586, 587, 5, 27, 0, 0, 587,
		588, 5, 46, 0, 0, 588, 589, 3, 18, 9, 0, 589, 590, 5, 47, 0, 0, 590, 591,
		6, 23, -1, 0, 591, 635, 1, 0, 0, 0, 592, 593, 5, 39, 0, 0, 593, 594, 5,
		70, 0, 0, 594, 595, 3, 18, 9, 0, 595, 596, 5, 71, 0, 0, 596, 597, 5, 42,
		0, 0, 597, 598, 5, 39, 0, 0, 598, 599, 5, 70, 0, 0, 599, 600, 3, 18, 9,
		0, 600, 601, 5, 71, 0, 0, 601, 602, 6, 23, -1, 0, 602, 635, 1, 0, 0, 0,
		603, 604, 5, 39, 0, 0, 604, 605, 5, 70, 0, 0, 605, 606, 3, 18, 9, 0, 606,
		607, 5, 71, 0, 0, 607, 608, 5, 70, 0, 0, 608, 609, 3, 18, 9, 0, 609, 610,
		5, 71, 0, 0, 610, 611, 3, 72, 36, 0, 611, 612, 5, 42, 0, 0, 612, 613, 3,
		18, 9, 0, 613, 614, 6, 23, -1, 0, 614, 635, 1, 0, 0, 0, 615, 616, 5, 39,
		0, 0, 616, 617, 5, 70, 0, 0, 617, 618, 3, 18, 9, 0, 618, 619, 5, 71, 0,
		0, 619, 620, 5, 70, 0, 0, 620, 621, 3, 18, 9, 0, 621, 622, 5, 71, 0, 0,
		622, 623, 5, 42, 0, 0, 623, 624, 3, 18, 9, 0, 624, 625, 6, 23, -1, 0, 625,
		635, 1, 0, 0, 0, 626, 627, 5, 39, 0, 0, 627, 628, 5, 70, 0, 0, 628, 629,
		3, 18, 9, 0, 629, 630, 5, 71, 0, 0, 630, 631, 5, 42, 0, 0, 631, 632, 3,
		18, 9, 0, 632, 633, 6, 23, -1, 0, 633, 635, 1, 0, 0, 0, 634, 584, 1, 0,
		0, 0, 634, 592, 1, 0, 0, 0, 634, 603, 1, 0, 0, 0, 634, 615, 1, 0, 0, 0,
		634, 626, 1, 0, 0, 0, 635, 47, 1, 0, 0, 0, 636, 637, 5, 39, 0, 0, 637,
		638, 5, 68, 0, 0, 638, 639, 5, 29, 0, 0, 639, 640, 5, 46, 0, 0, 640, 641,
		5, 47, 0, 0, 641, 653, 6, 24, -1, 0, 642, 643, 5, 39, 0, 0, 643, 644, 5,
		68, 0, 0, 644, 645, 5, 28, 0, 0, 645, 646, 5, 46, 0, 0, 646, 647, 5, 32,
		0, 0, 647, 648, 5, 43, 0, 0, 648, 649, 3, 18, 9, 0, 649, 650, 5, 47, 0,
		0, 650, 651, 6, 24, -1, 0, 651, 653, 1, 0, 0, 0, 652, 636, 1, 0, 0, 0,
		652, 642, 1, 0, 0, 0, 653, 49, 1, 0, 0, 0, 654, 655, 5, 39, 0, 0, 655,
		656, 5, 68, 0, 0, 656, 657, 5, 31, 0, 0, 657, 658, 6, 25, -1, 0, 658, 51,
		1, 0, 0, 0, 659, 660, 5, 39, 0, 0, 660, 661, 5, 68, 0, 0, 661, 662, 5,
		30, 0, 0, 662, 663, 6, 26, -1, 0, 663, 53, 1, 0, 0, 0, 664, 665, 5, 39,
		0, 0, 665, 666, 5, 70, 0, 0, 666, 667, 3, 18, 9, 0, 667, 668, 5, 71, 0,
		0, 668, 669, 5, 70, 0, 0, 669, 670, 3, 18, 9, 0, 670, 671, 5, 71, 0, 0,
		671, 672, 3, 72, 36, 0, 672, 673, 6, 27, -1, 0, 673, 690, 1, 0, 0, 0, 674,
		675, 5, 39, 0, 0, 675, 676, 5, 70, 0, 0, 676, 677, 3, 18, 9, 0, 677, 678,
		5, 71, 0, 0, 678, 679, 5, 70, 0, 0, 679, 680, 3, 18, 9, 0, 680, 681, 5,
		71, 0, 0, 681, 682, 6, 27, -1, 0, 682, 690, 1, 0, 0, 0, 683, 684, 5, 39,
		0, 0, 684, 685, 5, 70, 0, 0, 685, 686, 3, 18, 9, 0, 686, 687, 5, 71, 0,
		0, 687, 688, 6, 27, -1, 0, 688, 690, 1, 0, 0, 0, 689, 664, 1, 0, 0, 0,
		689, 674, 1, 0, 0, 0, 689, 683, 1, 0, 0, 0, 690, 55, 1, 0, 0, 0, 691, 692,
		5, 8, 0, 0, 692, 695, 5, 39, 0, 0, 693, 694, 5, 43, 0, 0, 694, 696, 3,
		58, 29, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 697, 1, 0,
		0, 0, 697, 698, 5, 42, 0, 0, 698, 699, 3, 60, 30, 0, 699, 700, 6, 28, -1,
		0, 700, 57, 1, 0, 0, 0, 701, 702, 5, 70, 0, 0, 702, 703, 3, 58, 29, 0,
		703, 704, 5, 71, 0, 0, 704, 705, 6, 29, -1, 0, 705, 712, 1, 0, 0, 0, 706,
		707, 5, 70, 0, 0, 707, 708, 3, 16, 8, 0, 708, 709, 5, 71, 0, 0, 709, 710,
		6, 29, -1, 0, 710, 712, 1, 0, 0, 0, 711, 701, 1, 0, 0, 0, 711, 706, 1,
		0, 0, 0, 712, 59, 1, 0, 0, 0, 713, 714, 3, 62, 31, 0, 714, 715, 6, 30,
		-1, 0, 715, 61, 1, 0, 0, 0, 716, 717, 5, 70, 0, 0, 717, 718, 3, 64, 32,
		0, 718, 719, 5, 71, 0, 0, 719, 720, 6, 31, -1, 0, 720, 725, 1, 0, 0, 0,
		721, 722, 3, 70, 35, 0, 722, 723, 6, 31, -1, 0, 723, 725, 1, 0, 0, 0, 724,
		716, 1, 0, 0, 0, 724, 721, 1, 0, 0, 0, 725, 63, 1, 0, 0, 0, 726, 727, 6,
		32, -1, 0, 727, 728, 3, 62, 31, 0, 728, 729, 6, 32, -1, 0, 729, 734, 1,
		0, 0, 0, 730, 731, 3, 66, 33, 0, 731, 732, 6, 32, -1, 0, 732, 734, 1, 0,
		0, 0, 733, 726, 1, 0, 0, 0, 733, 730, 1, 0, 0, 0, 734, 742, 1, 0, 0, 0,
		735, 736, 10, 3, 0, 0, 736, 737, 5, 67, 0, 0, 737, 738, 3, 62, 31, 0, 738,
		739, 6, 32, -1, 0, 739, 741, 1, 0, 0, 0, 740, 735, 1, 0, 0, 0, 741, 744,
		1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 65, 1, 0,
		0, 0, 744, 742, 1, 0, 0, 0, 745, 747, 3, 68, 34, 0, 746, 745, 1, 0, 0,
		0, 747, 748, 1, 0, 0, 0, 748, 746, 1, 0, 0, 0, 748, 749, 1, 0, 0, 0, 749,
		750, 1, 0, 0, 0, 750, 751, 6, 33, -1, 0, 751, 67, 1, 0, 0, 0, 752, 753,
		5, 67, 0, 0, 753, 754, 3, 18, 9, 0, 754, 755, 6, 34, -1, 0, 755, 760, 1,
		0, 0, 0, 756, 757, 3, 18, 9, 0, 757, 758, 6, 34, -1, 0, 758, 760, 1, 0,
		0, 0, 759, 752, 1, 0, 0, 0, 759, 756, 1, 0, 0, 0, 760, 69, 1, 0, 0, 0,
		761, 762, 3, 58, 29, 0, 762, 763, 5, 46, 0, 0, 763, 764, 5, 33, 0, 0, 764,
		765, 5, 43, 0, 0, 765, 766, 3, 70, 35, 0, 766, 767, 5, 67, 0, 0, 767, 768,
		5, 30, 0, 0, 768, 769, 5, 43, 0, 0, 769, 770, 5, 37, 0, 0, 770, 771, 5,
		47, 0, 0, 771, 772, 6, 35, -1, 0, 772, 786, 1, 0, 0, 0, 773, 774, 3, 58,
		29, 0, 774, 775, 5, 46, 0, 0, 775, 776, 5, 33, 0, 0, 776, 777, 5, 43, 0,
		0, 777, 778, 3, 18, 9, 0, 778, 779, 5, 67, 0, 0, 779, 780, 5, 30, 0, 0,
		780, 781, 5, 43, 0, 0, 781, 782, 5, 37, 0, 0, 782, 783, 5, 47, 0, 0, 783,
		784, 6, 35, -1, 0, 784, 786, 1, 0, 0, 0, 785, 761, 1, 0, 0, 0, 785, 773,
		1, 0, 0, 0, 786, 71, 1, 0, 0, 0, 787, 789, 3, 74, 37, 0, 788, 787, 1, 0,
		0, 0, 789, 790, 1, 0, 0, 0, 790, 788, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0,
		791, 792, 1, 0, 0, 0, 792, 793, 6, 36, -1, 0, 793, 73, 1, 0, 0, 0, 794,
		795, 5, 70, 0, 0, 795, 796, 3, 18, 9, 0, 796, 797, 5, 71, 0, 0, 797, 798,
		6, 37, -1, 0, 798, 75, 1, 0, 0, 0, 799, 800, 5, 34, 0, 0, 800, 801, 5,
		39, 0, 0, 801, 802, 5, 64, 0, 0, 802, 803, 3, 78, 39, 0, 803, 804, 5, 65,
		0, 0, 804, 805, 6, 38, -1, 0, 805, 77, 1, 0, 0, 0, 806, 808, 3, 80, 40,
		0, 807, 806, 1, 0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 807, 1, 0, 0, 0, 809,
		810, 1, 0, 0, 0, 810, 811, 1, 0, 0, 0, 811, 812, 6, 39, -1, 0, 812, 79,
		1, 0, 0, 0, 813, 814, 7, 5, 0, 0, 814, 815, 5, 39, 0, 0, 815, 818, 5, 43,
		0, 0, 816, 819, 3, 16, 8, 0, 817, 819, 5, 39, 0, 0, 818, 816, 1, 0, 0,
		0, 818, 817, 1, 0, 0, 0, 819, 822, 1, 0, 0, 0, 820, 821, 5, 42, 0, 0, 821,
		823, 3, 18, 9, 0, 822, 820, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 825,
		1, 0, 0, 0, 824, 826, 5, 44, 0, 0, 825, 824, 1, 0, 0, 0, 825, 826, 1, 0,
		0, 0, 826, 827, 1, 0, 0, 0, 827, 845, 6, 40, -1, 0, 828, 829, 7, 5, 0,
		0, 829, 832, 5, 39, 0, 0, 830, 831, 5, 42, 0, 0, 831, 833, 3, 18, 9, 0,
		832, 830, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 835, 1, 0, 0, 0, 834,
		836, 5, 44, 0, 0, 835, 834, 1, 0, 0, 0, 835, 836, 1, 0, 0, 0, 836, 837,
		1, 0, 0, 0, 837, 845, 6, 40, -1, 0, 838, 840, 5, 35, 0, 0, 839, 838, 1,
		0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 842, 3, 92, 46,
		0, 842, 843, 6, 40, -1, 0, 843, 845, 1, 0, 0, 0, 844, 813, 1, 0, 0, 0,
		844, 828, 1, 0, 0, 0, 844, 839, 1, 0, 0, 0, 845, 81, 1, 0, 0, 0, 846, 847,
		7, 5, 0, 0, 847, 850, 5, 39, 0, 0, 848, 849, 5, 43, 0, 0, 849, 851, 5,
		39, 0, 0, 850, 848, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851, 852, 1, 0, 0,
		0, 852, 853, 5, 42, 0, 0, 853, 855, 5, 39, 0, 0, 854, 856, 3, 84, 42, 0,
		855, 854, 1, 0, 0, 0, 855, 856, 1, 0, 0, 0, 856, 857, 1, 0, 0, 0, 857,
		880, 6, 41, -1, 0, 858, 859, 7, 5, 0, 0, 859, 862, 5, 39, 0, 0, 860, 861,
		5, 43, 0, 0, 861, 863, 5, 39, 0, 0, 862, 860, 1, 0, 0, 0, 862, 863, 1,
		0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 866, 5, 42, 0, 0, 865, 867, 5, 39,
		0, 0, 866, 865, 1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0,
		868, 880, 6, 41, -1, 0, 869, 870, 7, 5, 0, 0, 870, 873, 5, 39, 0, 0, 871,
		872, 5, 43, 0, 0, 872, 874, 5, 39, 0, 0, 873, 871, 1, 0, 0, 0, 873, 874,
		1, 0, 0, 0, 874, 875, 1, 0, 0, 0, 875, 876, 5, 42, 0, 0, 876, 877, 3, 18,
		9, 0, 877, 878, 6, 41, -1, 0, 878, 880, 1, 0, 0, 0, 879, 846, 1, 0, 0,
		0, 879, 858, 1, 0, 0, 0, 879, 869, 1, 0, 0, 0, 880, 83, 1, 0, 0, 0, 881,
		882, 5, 39, 0, 0, 882, 883, 5, 43, 0, 0, 883, 885, 3, 18, 9, 0, 884, 881,
		1, 0, 0, 0, 885, 886, 1, 0, 0, 0, 886, 884, 1, 0, 0, 0, 886, 887, 1, 0,
		0, 0, 887, 888, 1, 0, 0, 0, 888, 889, 6, 42, -1, 0, 889, 85, 1, 0, 0, 0,
		890, 891, 5, 39, 0, 0, 891, 892, 5, 68, 0, 0, 892, 893, 5, 39, 0, 0, 893,
		894, 6, 43, -1, 0, 894, 87, 1, 0, 0, 0, 895, 896, 5, 39, 0, 0, 896, 897,
		5, 68, 0, 0, 897, 898, 5, 39, 0, 0, 898, 899, 5, 42, 0, 0, 899, 900, 3,
		18, 9, 0, 900, 901, 6, 44, -1, 0, 901, 89, 1, 0, 0, 0, 902, 903, 5, 39,
		0, 0, 903, 904, 5, 68, 0, 0, 904, 905, 5, 39, 0, 0, 905, 906, 5, 46, 0,
		0, 906, 907, 5, 47, 0, 0, 907, 908, 6, 45, -1, 0, 908, 91, 1, 0, 0, 0,
		909, 910, 5, 24, 0, 0, 910, 911, 5, 39, 0, 0, 911, 912, 5, 46, 0, 0, 912,
		913, 3, 94, 47, 0, 913, 914, 5, 47, 0, 0, 914, 915, 5, 66, 0, 0, 915, 916,
		3, 16, 8, 0, 916, 917, 5, 64, 0, 0, 917, 918, 3, 6, 3, 0, 918, 919, 5,
		65, 0, 0, 919, 920, 6, 46, -1, 0, 920, 952, 1, 0, 0, 0, 921, 922, 5, 24,
		0, 0, 922, 923, 5, 39, 0, 0, 923, 924, 5, 46, 0, 0, 924, 925, 5, 47, 0,
		0, 925, 926, 5, 66, 0, 0, 926, 927, 3, 16, 8, 0, 927, 928, 5, 64, 0, 0,
		928, 929, 3, 6, 3, 0, 929, 930, 5, 65, 0, 0, 930, 931, 6, 46, -1, 0, 931,
		952, 1, 0, 0, 0, 932, 933, 5, 24, 0, 0, 933, 934, 5, 39, 0, 0, 934, 935,
		5, 46, 0, 0, 935, 936, 3, 94, 47, 0, 936, 937, 5, 47, 0, 0, 937, 938, 5,
		64, 0, 0, 938, 939, 3, 6, 3, 0, 939, 940, 5, 65, 0, 0, 940, 941, 6, 46,
		-1, 0, 941, 952, 1, 0, 0, 0, 942, 943, 5, 24, 0, 0, 943, 944, 5, 39, 0,
		0, 944, 945, 5, 46, 0, 0, 945, 946, 5, 47, 0, 0, 946, 947, 5, 64, 0, 0,
		947, 948, 3, 6, 3, 0, 948, 949, 5, 65, 0, 0, 949, 950, 6, 46, -1, 0, 950,
		952, 1, 0, 0, 0, 951, 909, 1, 0, 0, 0, 951, 921, 1, 0, 0, 0, 951, 932,
		1, 0, 0, 0, 951, 942, 1, 0, 0, 0, 952, 93, 1, 0, 0, 0, 953, 955, 7, 6,
		0, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0,
		956, 957, 5, 39, 0, 0, 957, 959, 5, 43, 0, 0, 958, 960, 5, 26, 0, 0, 959,
		958, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 961, 1, 0, 0, 0, 961, 962,
		3, 16, 8, 0, 962, 963, 5, 67, 0, 0, 963, 964, 3, 94, 47, 0, 964, 965, 6,
		47, -1, 0, 965, 978, 1, 0, 0, 0, 966, 968, 7, 6, 0, 0, 967, 966, 1, 0,
		0, 0, 967, 968, 1, 0, 0, 0, 968, 969, 1, 0, 0, 0, 969, 970, 5, 39, 0, 0,
		970, 972, 5, 43, 0, 0, 971, 973, 5, 26, 0, 0, 972, 971, 1, 0, 0, 0, 972,
		973, 1, 0, 0, 0, 973, 974, 1, 0, 0, 0, 974, 975, 3, 16, 8, 0, 975, 976,
		6, 47, -1, 0, 976, 978, 1, 0, 0, 0, 977, 954, 1, 0, 0, 0, 977, 967, 1,
		0, 0, 0, 978, 95, 1, 0, 0, 0, 979, 980, 5, 39, 0, 0, 980, 982, 5, 46, 0,
		0, 981, 983, 3, 98, 49, 0, 982, 981, 1, 0, 0, 0, 982, 983, 1, 0, 0, 0,
		983, 984, 1, 0, 0, 0, 984, 985, 5, 46, 0, 0, 985, 986, 6, 48, -1, 0, 986,
		97, 1, 0, 0, 0, 987, 990, 5, 67, 0, 0, 988, 989, 5, 39, 0, 0, 989, 991,
		5, 43, 0, 0, 990, 988, 1, 0, 0, 0, 990, 991, 1, 0, 0, 0, 991, 993, 1, 0,
		0, 0, 992, 994, 5, 1, 0, 0, 993, 992, 1, 0, 0, 0, 993, 994, 1, 0, 0, 0,
		994, 995, 1, 0, 0, 0, 995, 996, 3, 18, 9, 0, 996, 997, 3, 98, 49, 0, 997,
		998, 6, 49, -1, 0, 998, 1010, 1, 0, 0, 0, 999, 1000, 5, 39, 0, 0, 1000,
		1002, 5, 43, 0, 0, 1001, 999, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002,
		1004, 1, 0, 0, 0, 1003, 1005, 5, 1, 0, 0, 1004, 1003, 1, 0, 0, 0, 1004,
		1005, 1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 1007, 3, 18, 9, 0, 1007,
		1008, 6, 49, -1, 0, 1008, 1010, 1, 0, 0, 0, 1009, 987, 1, 0, 0, 0, 1009,
		1001, 1, 0, 0, 0, 1010, 99, 1, 0, 0, 0, 1011, 1012, 5, 25, 0, 0, 1012,
		1013, 5, 46, 0, 0, 1013, 1014, 3, 18, 9, 0, 1014, 1015, 5, 47, 0, 0, 1015,
		1016, 6, 50, -1, 0, 1016, 101, 1, 0, 0, 0, 1017, 1018, 5, 1, 0, 0, 1018,
		1019, 5, 46, 0, 0, 1019, 1020, 3, 18, 9, 0, 1020, 1021, 5, 47, 0, 0, 1021,
		1022, 6, 51, -1, 0, 1022, 103, 1, 0, 0, 0, 1023, 1024, 5, 2, 0, 0, 1024,
		1025, 5, 46, 0, 0, 1025, 1026, 3, 18, 9, 0, 1026, 1027, 5, 47, 0, 0, 1027,
		1028, 6, 52, -1, 0, 1028, 105, 1, 0, 0, 0, 1029, 1030, 5, 3, 0, 0, 1030,
		1031, 5, 46, 0, 0, 1031, 1032, 3, 18, 9, 0, 1032, 1033, 5, 47, 0, 0, 1033,
		1034, 6, 53, -1, 0, 1034, 107, 1, 0, 0, 0, 74, 115, 121, 127, 133, 154,
		166, 172, 182, 187, 193, 199, 205, 226, 232, 238, 244, 250, 256, 262, 266,
		289, 305, 322, 334, 381, 423, 425, 455, 464, 472, 509, 531, 566, 571, 582,
		634, 652, 689, 695, 711, 724, 733, 742, 748, 759, 785, 790, 809, 818, 822,
		825, 832, 835, 839, 844, 850, 855, 862, 866, 873, 879, 886, 951, 954, 959,
		967, 972, 977, 982, 990, 993, 1001, 1004, 1009,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// SwiftGrammarParserInit initializes any static state used to implement SwiftGrammarParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewSwiftGrammarParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func SwiftGrammarParserInit() {
	staticData := &SwiftGrammarParserStaticData
	staticData.once.Do(swiftgrammarParserInit)
}

// NewSwiftGrammarParser produces a new parser instance for the optional input antlr.TokenStream.
func NewSwiftGrammarParser(input antlr.TokenStream) *SwiftGrammarParser {
	SwiftGrammarParserInit()
	this := new(SwiftGrammarParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &SwiftGrammarParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "SwiftGrammar.g4"

	return this
}

// SwiftGrammarParser tokens.
const (
	SwiftGrammarParserEOF          = antlr.TokenEOF
	SwiftGrammarParserT__0         = 1
	SwiftGrammarParserINT          = 1
	SwiftGrammarParserFLOAT        = 2
	SwiftGrammarParserSTRING       = 3
	SwiftGrammarParserBOOL         = 4
	SwiftGrammarParserCHARACT      = 5
	SwiftGrammarParserTRU          = 6
	SwiftGrammarParserFAL          = 7
	SwiftGrammarParserVAR          = 8
	SwiftGrammarParserLET          = 9
	SwiftGrammarParserNULO         = 10
	SwiftGrammarParserIF           = 11
	SwiftGrammarParserELSE         = 12
	SwiftGrammarParserSWITCH       = 13
	SwiftGrammarParserCASE         = 14
	SwiftGrammarParserDEFAULT      = 15
	SwiftGrammarParserBREAK        = 16
	SwiftGrammarParserCONTINUE     = 17
	SwiftGrammarParserFOR          = 18
	SwiftGrammarParserIN           = 19
	SwiftGrammarParserRANGO        = 20
	SwiftGrammarParserWHILE        = 21
	SwiftGrammarParserGUARD        = 22
	SwiftGrammarParserRETURN       = 23
	SwiftGrammarParserFUNCION      = 24
	SwiftGrammarParserPRINT        = 25
	SwiftGrammarParserINOUT        = 26
	SwiftGrammarParserAPPEND       = 27
	SwiftGrammarParserREMOVE       = 28
	SwiftGrammarParserREMOVELAST   = 29
	SwiftGrammarParserCOUNT        = 30
	SwiftGrammarParserISEMPTY      = 31
	SwiftGrammarParserAT           = 32
	SwiftGrammarParserREPEATING    = 33
	SwiftGrammarParserSTRUCT       = 34
	SwiftGrammarParserMUTATING     = 35
	SwiftGrammarParserSELF         = 36
	SwiftGrammarParserNUMBER       = 37
	SwiftGrammarParserCADENA       = 38
	SwiftGrammarParserID_VALIDO    = 39
	SwiftGrammarParserCHARACTER    = 40
	SwiftGrammarParserWS           = 41
	SwiftGrammarParserIG           = 42
	SwiftGrammarParserDOS_PUNTOS   = 43
	SwiftGrammarParserPUNTOCOMA    = 44
	SwiftGrammarParserCIERRE_INTE  = 45
	SwiftGrammarParserPARIZQ       = 46
	SwiftGrammarParserPARDER       = 47
	SwiftGrammarParserDIF          = 48
	SwiftGrammarParserIG_IG        = 49
	SwiftGrammarParserNOT          = 50
	SwiftGrammarParserOR           = 51
	SwiftGrammarParserAND          = 52
	SwiftGrammarParserMAY_IG       = 53
	SwiftGrammarParserMEN_IG       = 54
	SwiftGrammarParserMAYOR        = 55
	SwiftGrammarParserMENOR        = 56
	SwiftGrammarParserMODULO       = 57
	SwiftGrammarParserMUL          = 58
	SwiftGrammarParserDIV          = 59
	SwiftGrammarParserADD          = 60
	SwiftGrammarParserSUB          = 61
	SwiftGrammarParserSUMA         = 62
	SwiftGrammarParserRESTA        = 63
	SwiftGrammarParserLLAVEIZQ     = 64
	SwiftGrammarParserLLAVEDER     = 65
	SwiftGrammarParserRETORNO      = 66
	SwiftGrammarParserCOMA         = 67
	SwiftGrammarParserPUNTO        = 68
	SwiftGrammarParserGUIONBAJO    = 69
	SwiftGrammarParserCORCHIZQ     = 70
	SwiftGrammarParserCORCHDER     = 71
	SwiftGrammarParserWHITESPACE   = 72
	SwiftGrammarParserCOMMENT      = 73
	SwiftGrammarParserLINE_COMMENT = 74
)

// SwiftGrammarParser rules.
const (
	SwiftGrammarParserRULE_s                         = 0
	SwiftGrammarParserRULE_block                     = 1
	SwiftGrammarParserRULE_instruction               = 2
	SwiftGrammarParserRULE_blockinterno              = 3
	SwiftGrammarParserRULE_instructionint            = 4
	SwiftGrammarParserRULE_declavarible              = 5
	SwiftGrammarParserRULE_declaconstante            = 6
	SwiftGrammarParserRULE_asignacionvariable        = 7
	SwiftGrammarParserRULE_tipodato                  = 8
	SwiftGrammarParserRULE_expr                      = 9
	SwiftGrammarParserRULE_sentenciaifelse           = 10
	SwiftGrammarParserRULE_switchcontrol             = 11
	SwiftGrammarParserRULE_blockcase                 = 12
	SwiftGrammarParserRULE_bloquecase                = 13
	SwiftGrammarParserRULE_whilecontrol              = 14
	SwiftGrammarParserRULE_forcontrol                = 15
	SwiftGrammarParserRULE_guardcontrol              = 16
	SwiftGrammarParserRULE_continuee                 = 17
	SwiftGrammarParserRULE_breakk                    = 18
	SwiftGrammarParserRULE_retornos                  = 19
	SwiftGrammarParserRULE_vectorcontrol             = 20
	SwiftGrammarParserRULE_blockparams               = 21
	SwiftGrammarParserRULE_bloqueparams              = 22
	SwiftGrammarParserRULE_vectoragregar             = 23
	SwiftGrammarParserRULE_vectorremover             = 24
	SwiftGrammarParserRULE_vectorvacio               = 25
	SwiftGrammarParserRULE_vectorcount               = 26
	SwiftGrammarParserRULE_vectoraccess              = 27
	SwiftGrammarParserRULE_matrizcontrol             = 28
	SwiftGrammarParserRULE_tipomatriz                = 29
	SwiftGrammarParserRULE_defmatriz                 = 30
	SwiftGrammarParserRULE_listavaloresmat           = 31
	SwiftGrammarParserRULE_listavaloresmat2          = 32
	SwiftGrammarParserRULE_listaexpresions           = 33
	SwiftGrammarParserRULE_listaexpresion            = 34
	SwiftGrammarParserRULE_simplematriz              = 35
	SwiftGrammarParserRULE_listamatrizaddsubs        = 36
	SwiftGrammarParserRULE_listamatrizaddsub         = 37
	SwiftGrammarParserRULE_structcontrol             = 38
	SwiftGrammarParserRULE_listaatributos            = 39
	SwiftGrammarParserRULE_listaatributo             = 40
	SwiftGrammarParserRULE_structexpr                = 41
	SwiftGrammarParserRULE_l_dupla                   = 42
	SwiftGrammarParserRULE_llamadastruct             = 43
	SwiftGrammarParserRULE_asignacionparametrostruct = 44
	SwiftGrammarParserRULE_llamadafuncionstruct      = 45
	SwiftGrammarParserRULE_funciondeclaracioncontrol = 46
	SwiftGrammarParserRULE_listaparametro            = 47
	SwiftGrammarParserRULE_funcionllamadacontrol     = 48
	SwiftGrammarParserRULE_listaparametrosllamada    = 49
	SwiftGrammarParserRULE_printstmt                 = 50
	SwiftGrammarParserRULE_intembebida               = 51
	SwiftGrammarParserRULE_floatembebida             = 52
	SwiftGrammarParserRULE_stringembebida            = 53
)

// ISContext is an interface to support dynamic dispatch.
type ISContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_block returns the _block rule contexts.
	Get_block() IBlockContext

	// Set_block sets the _block rule contexts.
	Set_block(IBlockContext)

	// GetCode returns the code attribute.
	GetCode() []interface{}

	// SetCode sets the code attribute.
	SetCode([]interface{})

	// Getter signatures
	Block() IBlockContext
	EOF() antlr.TerminalNode

	// IsSContext differentiates from other interfaces.
	IsSContext()
}

type SContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	code   []interface{}
	_block IBlockContext
}

func NewEmptySContext() *SContext {
	var p = new(SContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_s
	return p
}

func InitEmptySContext(p *SContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_s
}

func (*SContext) IsSContext() {}

func NewSContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SContext {
	var p = new(SContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_s

	return p
}

func (s *SContext) GetParser() antlr.Parser { return s.parser }

func (s *SContext) Get_block() IBlockContext { return s._block }

func (s *SContext) Set_block(v IBlockContext) { s._block = v }

func (s *SContext) GetCode() []interface{} { return s.code }

func (s *SContext) SetCode(v []interface{}) { s.code = v }

func (s *SContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *SContext) EOF() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserEOF, 0)
}

func (s *SContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterS(s)
	}
}

func (s *SContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitS(s)
	}
}

func (p *SwiftGrammarParser) S() (localctx ISContext) {
	localctx = NewSContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, SwiftGrammarParserRULE_s)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(108)

		var _x = p.Block()

		localctx.(*SContext)._block = _x
	}
	{
		p.SetState(109)
		p.Match(SwiftGrammarParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*SContext).code = localctx.(*SContext).Get_block().GetBlk()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instruction returns the _instruction rule contexts.
	Get_instruction() IInstructionContext

	// Set_instruction sets the _instruction rule contexts.
	Set_instruction(IInstructionContext)

	// GetIns returns the ins rule context list.
	GetIns() []IInstructionContext

	// SetIns sets the ins rule context list.
	SetIns([]IInstructionContext)

	// GetBlk returns the blk attribute.
	GetBlk() []interface{}

	// SetBlk sets the blk attribute.
	SetBlk([]interface{})

	// Getter signatures
	AllInstruction() []IInstructionContext
	Instruction(i int) IInstructionContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	blk          []interface{}
	_instruction IInstructionContext
	ins          []IInstructionContext
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) Get_instruction() IInstructionContext { return s._instruction }

func (s *BlockContext) Set_instruction(v IInstructionContext) { s._instruction = v }

func (s *BlockContext) GetIns() []IInstructionContext { return s.ins }

func (s *BlockContext) SetIns(v []IInstructionContext) { s.ins = v }

func (s *BlockContext) GetBlk() []interface{} { return s.blk }

func (s *BlockContext) SetBlk(v []interface{}) { s.blk = v }

func (s *BlockContext) AllInstruction() []IInstructionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstructionContext); ok {
			len++
		}
	}

	tst := make([]IInstructionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstructionContext); ok {
			tst[i] = t.(IInstructionContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Instruction(i int) IInstructionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (p *SwiftGrammarParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, SwiftGrammarParserRULE_block)

	localctx.(*BlockContext).blk = []interface{}{}
	var listInt []IInstructionContext

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&566992579328) != 0) {
		{
			p.SetState(112)

			var _x = p.Instruction()

			localctx.(*BlockContext)._instruction = _x
		}
		localctx.(*BlockContext).ins = append(localctx.(*BlockContext).ins, localctx.(*BlockContext)._instruction)

		p.SetState(115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt = localctx.(*BlockContext).GetIns()
	for _, e := range listInt {
		localctx.(*BlockContext).blk = append(localctx.(*BlockContext).blk, e.GetInst())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionContext is an interface to support dynamic dispatch.
type IInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_declavarible returns the _declavarible rule contexts.
	Get_declavarible() IDeclavaribleContext

	// Get_declaconstante returns the _declaconstante rule contexts.
	Get_declaconstante() IDeclaconstanteContext

	// Get_asignacionvariable returns the _asignacionvariable rule contexts.
	Get_asignacionvariable() IAsignacionvariableContext

	// Get_sentenciaifelse returns the _sentenciaifelse rule contexts.
	Get_sentenciaifelse() ISentenciaifelseContext

	// Get_switchcontrol returns the _switchcontrol rule contexts.
	Get_switchcontrol() ISwitchcontrolContext

	// Get_whilecontrol returns the _whilecontrol rule contexts.
	Get_whilecontrol() IWhilecontrolContext

	// Get_forcontrol returns the _forcontrol rule contexts.
	Get_forcontrol() IForcontrolContext

	// Get_guardcontrol returns the _guardcontrol rule contexts.
	Get_guardcontrol() IGuardcontrolContext

	// Get_vectorcontrol returns the _vectorcontrol rule contexts.
	Get_vectorcontrol() IVectorcontrolContext

	// Get_vectoragregar returns the _vectoragregar rule contexts.
	Get_vectoragregar() IVectoragregarContext

	// Get_vectorremover returns the _vectorremover rule contexts.
	Get_vectorremover() IVectorremoverContext

	// Get_printstmt returns the _printstmt rule contexts.
	Get_printstmt() IPrintstmtContext

	// Get_matrizcontrol returns the _matrizcontrol rule contexts.
	Get_matrizcontrol() IMatrizcontrolContext

	// Get_structcontrol returns the _structcontrol rule contexts.
	Get_structcontrol() IStructcontrolContext

	// Get_funciondeclaracioncontrol returns the _funciondeclaracioncontrol rule contexts.
	Get_funciondeclaracioncontrol() IFunciondeclaracioncontrolContext

	// Set_declavarible sets the _declavarible rule contexts.
	Set_declavarible(IDeclavaribleContext)

	// Set_declaconstante sets the _declaconstante rule contexts.
	Set_declaconstante(IDeclaconstanteContext)

	// Set_asignacionvariable sets the _asignacionvariable rule contexts.
	Set_asignacionvariable(IAsignacionvariableContext)

	// Set_sentenciaifelse sets the _sentenciaifelse rule contexts.
	Set_sentenciaifelse(ISentenciaifelseContext)

	// Set_switchcontrol sets the _switchcontrol rule contexts.
	Set_switchcontrol(ISwitchcontrolContext)

	// Set_whilecontrol sets the _whilecontrol rule contexts.
	Set_whilecontrol(IWhilecontrolContext)

	// Set_forcontrol sets the _forcontrol rule contexts.
	Set_forcontrol(IForcontrolContext)

	// Set_guardcontrol sets the _guardcontrol rule contexts.
	Set_guardcontrol(IGuardcontrolContext)

	// Set_vectorcontrol sets the _vectorcontrol rule contexts.
	Set_vectorcontrol(IVectorcontrolContext)

	// Set_vectoragregar sets the _vectoragregar rule contexts.
	Set_vectoragregar(IVectoragregarContext)

	// Set_vectorremover sets the _vectorremover rule contexts.
	Set_vectorremover(IVectorremoverContext)

	// Set_printstmt sets the _printstmt rule contexts.
	Set_printstmt(IPrintstmtContext)

	// Set_matrizcontrol sets the _matrizcontrol rule contexts.
	Set_matrizcontrol(IMatrizcontrolContext)

	// Set_structcontrol sets the _structcontrol rule contexts.
	Set_structcontrol(IStructcontrolContext)

	// Set_funciondeclaracioncontrol sets the _funciondeclaracioncontrol rule contexts.
	Set_funciondeclaracioncontrol(IFunciondeclaracioncontrolContext)

	// GetInst returns the inst attribute.
	GetInst() interfaces.Instruction

	// SetInst sets the inst attribute.
	SetInst(interfaces.Instruction)

	// Getter signatures
	Declavarible() IDeclavaribleContext
	PUNTOCOMA() antlr.TerminalNode
	Declaconstante() IDeclaconstanteContext
	Asignacionvariable() IAsignacionvariableContext
	Sentenciaifelse() ISentenciaifelseContext
	Switchcontrol() ISwitchcontrolContext
	Whilecontrol() IWhilecontrolContext
	Forcontrol() IForcontrolContext
	Guardcontrol() IGuardcontrolContext
	Vectorcontrol() IVectorcontrolContext
	Vectoragregar() IVectoragregarContext
	Vectorremover() IVectorremoverContext
	Printstmt() IPrintstmtContext
	Matrizcontrol() IMatrizcontrolContext
	Structcontrol() IStructcontrolContext
	Funciondeclaracioncontrol() IFunciondeclaracioncontrolContext

	// IsInstructionContext differentiates from other interfaces.
	IsInstructionContext()
}

type InstructionContext struct {
	antlr.BaseParserRuleContext
	parser                     antlr.Parser
	inst                       interfaces.Instruction
	_declavarible              IDeclavaribleContext
	_declaconstante            IDeclaconstanteContext
	_asignacionvariable        IAsignacionvariableContext
	_sentenciaifelse           ISentenciaifelseContext
	_switchcontrol             ISwitchcontrolContext
	_whilecontrol              IWhilecontrolContext
	_forcontrol                IForcontrolContext
	_guardcontrol              IGuardcontrolContext
	_vectorcontrol             IVectorcontrolContext
	_vectoragregar             IVectoragregarContext
	_vectorremover             IVectorremoverContext
	_printstmt                 IPrintstmtContext
	_matrizcontrol             IMatrizcontrolContext
	_structcontrol             IStructcontrolContext
	_funciondeclaracioncontrol IFunciondeclaracioncontrolContext
}

func NewEmptyInstructionContext() *InstructionContext {
	var p = new(InstructionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_instruction
	return p
}

func InitEmptyInstructionContext(p *InstructionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_instruction
}

func (*InstructionContext) IsInstructionContext() {}

func NewInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionContext {
	var p = new(InstructionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_instruction

	return p
}

func (s *InstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionContext) Get_declavarible() IDeclavaribleContext { return s._declavarible }

func (s *InstructionContext) Get_declaconstante() IDeclaconstanteContext { return s._declaconstante }

func (s *InstructionContext) Get_asignacionvariable() IAsignacionvariableContext {
	return s._asignacionvariable
}

func (s *InstructionContext) Get_sentenciaifelse() ISentenciaifelseContext { return s._sentenciaifelse }

func (s *InstructionContext) Get_switchcontrol() ISwitchcontrolContext { return s._switchcontrol }

func (s *InstructionContext) Get_whilecontrol() IWhilecontrolContext { return s._whilecontrol }

func (s *InstructionContext) Get_forcontrol() IForcontrolContext { return s._forcontrol }

func (s *InstructionContext) Get_guardcontrol() IGuardcontrolContext { return s._guardcontrol }

func (s *InstructionContext) Get_vectorcontrol() IVectorcontrolContext { return s._vectorcontrol }

func (s *InstructionContext) Get_vectoragregar() IVectoragregarContext { return s._vectoragregar }

func (s *InstructionContext) Get_vectorremover() IVectorremoverContext { return s._vectorremover }

func (s *InstructionContext) Get_printstmt() IPrintstmtContext { return s._printstmt }

func (s *InstructionContext) Get_matrizcontrol() IMatrizcontrolContext { return s._matrizcontrol }

func (s *InstructionContext) Get_structcontrol() IStructcontrolContext { return s._structcontrol }

func (s *InstructionContext) Get_funciondeclaracioncontrol() IFunciondeclaracioncontrolContext {
	return s._funciondeclaracioncontrol
}

func (s *InstructionContext) Set_declavarible(v IDeclavaribleContext) { s._declavarible = v }

func (s *InstructionContext) Set_declaconstante(v IDeclaconstanteContext) { s._declaconstante = v }

func (s *InstructionContext) Set_asignacionvariable(v IAsignacionvariableContext) {
	s._asignacionvariable = v
}

func (s *InstructionContext) Set_sentenciaifelse(v ISentenciaifelseContext) { s._sentenciaifelse = v }

func (s *InstructionContext) Set_switchcontrol(v ISwitchcontrolContext) { s._switchcontrol = v }

func (s *InstructionContext) Set_whilecontrol(v IWhilecontrolContext) { s._whilecontrol = v }

func (s *InstructionContext) Set_forcontrol(v IForcontrolContext) { s._forcontrol = v }

func (s *InstructionContext) Set_guardcontrol(v IGuardcontrolContext) { s._guardcontrol = v }

func (s *InstructionContext) Set_vectorcontrol(v IVectorcontrolContext) { s._vectorcontrol = v }

func (s *InstructionContext) Set_vectoragregar(v IVectoragregarContext) { s._vectoragregar = v }

func (s *InstructionContext) Set_vectorremover(v IVectorremoverContext) { s._vectorremover = v }

func (s *InstructionContext) Set_printstmt(v IPrintstmtContext) { s._printstmt = v }

func (s *InstructionContext) Set_matrizcontrol(v IMatrizcontrolContext) { s._matrizcontrol = v }

func (s *InstructionContext) Set_structcontrol(v IStructcontrolContext) { s._structcontrol = v }

func (s *InstructionContext) Set_funciondeclaracioncontrol(v IFunciondeclaracioncontrolContext) {
	s._funciondeclaracioncontrol = v
}

func (s *InstructionContext) GetInst() interfaces.Instruction { return s.inst }

func (s *InstructionContext) SetInst(v interfaces.Instruction) { s.inst = v }

func (s *InstructionContext) Declavarible() IDeclavaribleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclavaribleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclavaribleContext)
}

func (s *InstructionContext) PUNTOCOMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTOCOMA, 0)
}

func (s *InstructionContext) Declaconstante() IDeclaconstanteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaconstanteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaconstanteContext)
}

func (s *InstructionContext) Asignacionvariable() IAsignacionvariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsignacionvariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsignacionvariableContext)
}

func (s *InstructionContext) Sentenciaifelse() ISentenciaifelseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenciaifelseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenciaifelseContext)
}

func (s *InstructionContext) Switchcontrol() ISwitchcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchcontrolContext)
}

func (s *InstructionContext) Whilecontrol() IWhilecontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhilecontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhilecontrolContext)
}

func (s *InstructionContext) Forcontrol() IForcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForcontrolContext)
}

func (s *InstructionContext) Guardcontrol() IGuardcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardcontrolContext)
}

func (s *InstructionContext) Vectorcontrol() IVectorcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorcontrolContext)
}

func (s *InstructionContext) Vectoragregar() IVectoragregarContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectoragregarContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectoragregarContext)
}

func (s *InstructionContext) Vectorremover() IVectorremoverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorremoverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorremoverContext)
}

func (s *InstructionContext) Printstmt() IPrintstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintstmtContext)
}

func (s *InstructionContext) Matrizcontrol() IMatrizcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMatrizcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMatrizcontrolContext)
}

func (s *InstructionContext) Structcontrol() IStructcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructcontrolContext)
}

func (s *InstructionContext) Funciondeclaracioncontrol() IFunciondeclaracioncontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunciondeclaracioncontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunciondeclaracioncontrolContext)
}

func (s *InstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterInstruction(s)
	}
}

func (s *InstructionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitInstruction(s)
	}
}

func (p *SwiftGrammarParser) Instruction() (localctx IInstructionContext) {
	localctx = NewInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, SwiftGrammarParserRULE_instruction)
	var _la int

	p.SetState(182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(119)

			var _x = p.Declavarible()

			localctx.(*InstructionContext)._declavarible = _x
		}
		p.SetState(121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(120)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_declavarible().GetDecvbl()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(125)

			var _x = p.Declaconstante()

			localctx.(*InstructionContext)._declaconstante = _x
		}
		p.SetState(127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(126)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_declaconstante().GetDeccon()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(131)

			var _x = p.Asignacionvariable()

			localctx.(*InstructionContext)._asignacionvariable = _x
		}
		p.SetState(133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(132)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_asignacionvariable().GetAsgvbl()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(137)

			var _x = p.Sentenciaifelse()

			localctx.(*InstructionContext)._sentenciaifelse = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_sentenciaifelse().GetMyIfElse()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(140)

			var _x = p.Switchcontrol()

			localctx.(*InstructionContext)._switchcontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_switchcontrol().GetMySwitch()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(143)

			var _x = p.Whilecontrol()

			localctx.(*InstructionContext)._whilecontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_whilecontrol().GetWhict()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(146)

			var _x = p.Forcontrol()

			localctx.(*InstructionContext)._forcontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_forcontrol().GetForct()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(149)

			var _x = p.Guardcontrol()

			localctx.(*InstructionContext)._guardcontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_guardcontrol().GetGuct()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(152)

			var _x = p.Vectorcontrol()

			localctx.(*InstructionContext)._vectorcontrol = _x
		}
		p.SetState(154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(153)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_vectorcontrol().GetVect()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(158)

			var _x = p.Vectoragregar()

			localctx.(*InstructionContext)._vectoragregar = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_vectoragregar().GetVeadct()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(161)

			var _x = p.Vectorremover()

			localctx.(*InstructionContext)._vectorremover = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_vectorremover().GetVermct()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(164)

			var _x = p.Printstmt()

			localctx.(*InstructionContext)._printstmt = _x
		}
		p.SetState(166)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(165)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_printstmt().GetPrnt()

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(170)

			var _x = p.Matrizcontrol()

			localctx.(*InstructionContext)._matrizcontrol = _x
		}
		p.SetState(172)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(171)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_matrizcontrol().GetMatct()

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(176)

			var _x = p.Structcontrol()

			localctx.(*InstructionContext)._structcontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_structcontrol().GetStruck()

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(179)

			var _x = p.Funciondeclaracioncontrol()

			localctx.(*InstructionContext)._funciondeclaracioncontrol = _x
		}
		localctx.(*InstructionContext).inst = localctx.(*InstructionContext).Get_funciondeclaracioncontrol().GetFdc()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockinternoContext is an interface to support dynamic dispatch.
type IBlockinternoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_instructionint returns the _instructionint rule contexts.
	Get_instructionint() IInstructionintContext

	// Set_instructionint sets the _instructionint rule contexts.
	Set_instructionint(IInstructionintContext)

	// GetInsint returns the insint rule context list.
	GetInsint() []IInstructionintContext

	// SetInsint sets the insint rule context list.
	SetInsint([]IInstructionintContext)

	// GetBlkint returns the blkint attribute.
	GetBlkint() []interface{}

	// SetBlkint sets the blkint attribute.
	SetBlkint([]interface{})

	// Getter signatures
	AllInstructionint() []IInstructionintContext
	Instructionint(i int) IInstructionintContext

	// IsBlockinternoContext differentiates from other interfaces.
	IsBlockinternoContext()
}

type BlockinternoContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	blkint          []interface{}
	_instructionint IInstructionintContext
	insint          []IInstructionintContext
}

func NewEmptyBlockinternoContext() *BlockinternoContext {
	var p = new(BlockinternoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockinterno
	return p
}

func InitEmptyBlockinternoContext(p *BlockinternoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockinterno
}

func (*BlockinternoContext) IsBlockinternoContext() {}

func NewBlockinternoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockinternoContext {
	var p = new(BlockinternoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_blockinterno

	return p
}

func (s *BlockinternoContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockinternoContext) Get_instructionint() IInstructionintContext { return s._instructionint }

func (s *BlockinternoContext) Set_instructionint(v IInstructionintContext) { s._instructionint = v }

func (s *BlockinternoContext) GetInsint() []IInstructionintContext { return s.insint }

func (s *BlockinternoContext) SetInsint(v []IInstructionintContext) { s.insint = v }

func (s *BlockinternoContext) GetBlkint() []interface{} { return s.blkint }

func (s *BlockinternoContext) SetBlkint(v []interface{}) { s.blkint = v }

func (s *BlockinternoContext) AllInstructionint() []IInstructionintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstructionintContext); ok {
			len++
		}
	}

	tst := make([]IInstructionintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstructionintContext); ok {
			tst[i] = t.(IInstructionintContext)
			i++
		}
	}

	return tst
}

func (s *BlockinternoContext) Instructionint(i int) IInstructionintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstructionintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstructionintContext)
}

func (s *BlockinternoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockinternoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockinternoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBlockinterno(s)
	}
}

func (s *BlockinternoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBlockinterno(s)
	}
}

func (p *SwiftGrammarParser) Blockinterno() (localctx IBlockinternoContext) {
	localctx = NewBlockinternoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, SwiftGrammarParserRULE_blockinterno)

	localctx.(*BlockinternoContext).blkint = []interface{}{}
	var listInt []IInstructionintContext

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&549804518144) != 0) {
		{
			p.SetState(184)

			var _x = p.Instructionint()

			localctx.(*BlockinternoContext)._instructionint = _x
		}
		localctx.(*BlockinternoContext).insint = append(localctx.(*BlockinternoContext).insint, localctx.(*BlockinternoContext)._instructionint)

		p.SetState(187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt = localctx.(*BlockinternoContext).GetInsint()
	for _, e := range listInt {
		localctx.(*BlockinternoContext).blkint = append(localctx.(*BlockinternoContext).blkint, e.GetInsint())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstructionintContext is an interface to support dynamic dispatch.
type IInstructionintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_declavarible returns the _declavarible rule contexts.
	Get_declavarible() IDeclavaribleContext

	// Get_declaconstante returns the _declaconstante rule contexts.
	Get_declaconstante() IDeclaconstanteContext

	// Get_asignacionvariable returns the _asignacionvariable rule contexts.
	Get_asignacionvariable() IAsignacionvariableContext

	// Get_sentenciaifelse returns the _sentenciaifelse rule contexts.
	Get_sentenciaifelse() ISentenciaifelseContext

	// Get_switchcontrol returns the _switchcontrol rule contexts.
	Get_switchcontrol() ISwitchcontrolContext

	// Get_whilecontrol returns the _whilecontrol rule contexts.
	Get_whilecontrol() IWhilecontrolContext

	// Get_forcontrol returns the _forcontrol rule contexts.
	Get_forcontrol() IForcontrolContext

	// Get_guardcontrol returns the _guardcontrol rule contexts.
	Get_guardcontrol() IGuardcontrolContext

	// Get_continuee returns the _continuee rule contexts.
	Get_continuee() IContinueeContext

	// Get_breakk returns the _breakk rule contexts.
	Get_breakk() IBreakkContext

	// Get_retornos returns the _retornos rule contexts.
	Get_retornos() IRetornosContext

	// Get_vectorcontrol returns the _vectorcontrol rule contexts.
	Get_vectorcontrol() IVectorcontrolContext

	// Get_vectoragregar returns the _vectoragregar rule contexts.
	Get_vectoragregar() IVectoragregarContext

	// Get_vectorremover returns the _vectorremover rule contexts.
	Get_vectorremover() IVectorremoverContext

	// Get_printstmt returns the _printstmt rule contexts.
	Get_printstmt() IPrintstmtContext

	// Set_declavarible sets the _declavarible rule contexts.
	Set_declavarible(IDeclavaribleContext)

	// Set_declaconstante sets the _declaconstante rule contexts.
	Set_declaconstante(IDeclaconstanteContext)

	// Set_asignacionvariable sets the _asignacionvariable rule contexts.
	Set_asignacionvariable(IAsignacionvariableContext)

	// Set_sentenciaifelse sets the _sentenciaifelse rule contexts.
	Set_sentenciaifelse(ISentenciaifelseContext)

	// Set_switchcontrol sets the _switchcontrol rule contexts.
	Set_switchcontrol(ISwitchcontrolContext)

	// Set_whilecontrol sets the _whilecontrol rule contexts.
	Set_whilecontrol(IWhilecontrolContext)

	// Set_forcontrol sets the _forcontrol rule contexts.
	Set_forcontrol(IForcontrolContext)

	// Set_guardcontrol sets the _guardcontrol rule contexts.
	Set_guardcontrol(IGuardcontrolContext)

	// Set_continuee sets the _continuee rule contexts.
	Set_continuee(IContinueeContext)

	// Set_breakk sets the _breakk rule contexts.
	Set_breakk(IBreakkContext)

	// Set_retornos sets the _retornos rule contexts.
	Set_retornos(IRetornosContext)

	// Set_vectorcontrol sets the _vectorcontrol rule contexts.
	Set_vectorcontrol(IVectorcontrolContext)

	// Set_vectoragregar sets the _vectoragregar rule contexts.
	Set_vectoragregar(IVectoragregarContext)

	// Set_vectorremover sets the _vectorremover rule contexts.
	Set_vectorremover(IVectorremoverContext)

	// Set_printstmt sets the _printstmt rule contexts.
	Set_printstmt(IPrintstmtContext)

	// GetInsint returns the insint attribute.
	GetInsint() interfaces.Instruction

	// SetInsint sets the insint attribute.
	SetInsint(interfaces.Instruction)

	// Getter signatures
	Declavarible() IDeclavaribleContext
	PUNTOCOMA() antlr.TerminalNode
	Declaconstante() IDeclaconstanteContext
	Asignacionvariable() IAsignacionvariableContext
	Sentenciaifelse() ISentenciaifelseContext
	Switchcontrol() ISwitchcontrolContext
	Whilecontrol() IWhilecontrolContext
	Forcontrol() IForcontrolContext
	Guardcontrol() IGuardcontrolContext
	Continuee() IContinueeContext
	Breakk() IBreakkContext
	Retornos() IRetornosContext
	Vectorcontrol() IVectorcontrolContext
	Vectoragregar() IVectoragregarContext
	Vectorremover() IVectorremoverContext
	Printstmt() IPrintstmtContext

	// IsInstructionintContext differentiates from other interfaces.
	IsInstructionintContext()
}

type InstructionintContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	insint              interfaces.Instruction
	_declavarible       IDeclavaribleContext
	_declaconstante     IDeclaconstanteContext
	_asignacionvariable IAsignacionvariableContext
	_sentenciaifelse    ISentenciaifelseContext
	_switchcontrol      ISwitchcontrolContext
	_whilecontrol       IWhilecontrolContext
	_forcontrol         IForcontrolContext
	_guardcontrol       IGuardcontrolContext
	_continuee          IContinueeContext
	_breakk             IBreakkContext
	_retornos           IRetornosContext
	_vectorcontrol      IVectorcontrolContext
	_vectoragregar      IVectoragregarContext
	_vectorremover      IVectorremoverContext
	_printstmt          IPrintstmtContext
}

func NewEmptyInstructionintContext() *InstructionintContext {
	var p = new(InstructionintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_instructionint
	return p
}

func InitEmptyInstructionintContext(p *InstructionintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_instructionint
}

func (*InstructionintContext) IsInstructionintContext() {}

func NewInstructionintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstructionintContext {
	var p = new(InstructionintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_instructionint

	return p
}

func (s *InstructionintContext) GetParser() antlr.Parser { return s.parser }

func (s *InstructionintContext) Get_declavarible() IDeclavaribleContext { return s._declavarible }

func (s *InstructionintContext) Get_declaconstante() IDeclaconstanteContext { return s._declaconstante }

func (s *InstructionintContext) Get_asignacionvariable() IAsignacionvariableContext {
	return s._asignacionvariable
}

func (s *InstructionintContext) Get_sentenciaifelse() ISentenciaifelseContext {
	return s._sentenciaifelse
}

func (s *InstructionintContext) Get_switchcontrol() ISwitchcontrolContext { return s._switchcontrol }

func (s *InstructionintContext) Get_whilecontrol() IWhilecontrolContext { return s._whilecontrol }

func (s *InstructionintContext) Get_forcontrol() IForcontrolContext { return s._forcontrol }

func (s *InstructionintContext) Get_guardcontrol() IGuardcontrolContext { return s._guardcontrol }

func (s *InstructionintContext) Get_continuee() IContinueeContext { return s._continuee }

func (s *InstructionintContext) Get_breakk() IBreakkContext { return s._breakk }

func (s *InstructionintContext) Get_retornos() IRetornosContext { return s._retornos }

func (s *InstructionintContext) Get_vectorcontrol() IVectorcontrolContext { return s._vectorcontrol }

func (s *InstructionintContext) Get_vectoragregar() IVectoragregarContext { return s._vectoragregar }

func (s *InstructionintContext) Get_vectorremover() IVectorremoverContext { return s._vectorremover }

func (s *InstructionintContext) Get_printstmt() IPrintstmtContext { return s._printstmt }

func (s *InstructionintContext) Set_declavarible(v IDeclavaribleContext) { s._declavarible = v }

func (s *InstructionintContext) Set_declaconstante(v IDeclaconstanteContext) { s._declaconstante = v }

func (s *InstructionintContext) Set_asignacionvariable(v IAsignacionvariableContext) {
	s._asignacionvariable = v
}

func (s *InstructionintContext) Set_sentenciaifelse(v ISentenciaifelseContext) {
	s._sentenciaifelse = v
}

func (s *InstructionintContext) Set_switchcontrol(v ISwitchcontrolContext) { s._switchcontrol = v }

func (s *InstructionintContext) Set_whilecontrol(v IWhilecontrolContext) { s._whilecontrol = v }

func (s *InstructionintContext) Set_forcontrol(v IForcontrolContext) { s._forcontrol = v }

func (s *InstructionintContext) Set_guardcontrol(v IGuardcontrolContext) { s._guardcontrol = v }

func (s *InstructionintContext) Set_continuee(v IContinueeContext) { s._continuee = v }

func (s *InstructionintContext) Set_breakk(v IBreakkContext) { s._breakk = v }

func (s *InstructionintContext) Set_retornos(v IRetornosContext) { s._retornos = v }

func (s *InstructionintContext) Set_vectorcontrol(v IVectorcontrolContext) { s._vectorcontrol = v }

func (s *InstructionintContext) Set_vectoragregar(v IVectoragregarContext) { s._vectoragregar = v }

func (s *InstructionintContext) Set_vectorremover(v IVectorremoverContext) { s._vectorremover = v }

func (s *InstructionintContext) Set_printstmt(v IPrintstmtContext) { s._printstmt = v }

func (s *InstructionintContext) GetInsint() interfaces.Instruction { return s.insint }

func (s *InstructionintContext) SetInsint(v interfaces.Instruction) { s.insint = v }

func (s *InstructionintContext) Declavarible() IDeclavaribleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclavaribleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclavaribleContext)
}

func (s *InstructionintContext) PUNTOCOMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTOCOMA, 0)
}

func (s *InstructionintContext) Declaconstante() IDeclaconstanteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaconstanteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaconstanteContext)
}

func (s *InstructionintContext) Asignacionvariable() IAsignacionvariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsignacionvariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsignacionvariableContext)
}

func (s *InstructionintContext) Sentenciaifelse() ISentenciaifelseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenciaifelseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenciaifelseContext)
}

func (s *InstructionintContext) Switchcontrol() ISwitchcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchcontrolContext)
}

func (s *InstructionintContext) Whilecontrol() IWhilecontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhilecontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhilecontrolContext)
}

func (s *InstructionintContext) Forcontrol() IForcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForcontrolContext)
}

func (s *InstructionintContext) Guardcontrol() IGuardcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGuardcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGuardcontrolContext)
}

func (s *InstructionintContext) Continuee() IContinueeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueeContext)
}

func (s *InstructionintContext) Breakk() IBreakkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakkContext)
}

func (s *InstructionintContext) Retornos() IRetornosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetornosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetornosContext)
}

func (s *InstructionintContext) Vectorcontrol() IVectorcontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorcontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorcontrolContext)
}

func (s *InstructionintContext) Vectoragregar() IVectoragregarContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectoragregarContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectoragregarContext)
}

func (s *InstructionintContext) Vectorremover() IVectorremoverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorremoverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorremoverContext)
}

func (s *InstructionintContext) Printstmt() IPrintstmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintstmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintstmtContext)
}

func (s *InstructionintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstructionintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstructionintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterInstructionint(s)
	}
}

func (s *InstructionintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitInstructionint(s)
	}
}

func (p *SwiftGrammarParser) Instructionint() (localctx IInstructionintContext) {
	localctx = NewInstructionintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, SwiftGrammarParserRULE_instructionint)
	var _la int

	p.SetState(266)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(191)

			var _x = p.Declavarible()

			localctx.(*InstructionintContext)._declavarible = _x
		}
		p.SetState(193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(192)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_declavarible().GetDecvbl()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(197)

			var _x = p.Declaconstante()

			localctx.(*InstructionintContext)._declaconstante = _x
		}
		p.SetState(199)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(198)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_declaconstante().GetDeccon()

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(203)

			var _x = p.Asignacionvariable()

			localctx.(*InstructionintContext)._asignacionvariable = _x
		}
		p.SetState(205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(204)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_asignacionvariable().GetAsgvbl()

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(209)

			var _x = p.Sentenciaifelse()

			localctx.(*InstructionintContext)._sentenciaifelse = _x
		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_sentenciaifelse().GetMyIfElse()

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(212)

			var _x = p.Switchcontrol()

			localctx.(*InstructionintContext)._switchcontrol = _x
		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_switchcontrol().GetMySwitch()

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(215)

			var _x = p.Whilecontrol()

			localctx.(*InstructionintContext)._whilecontrol = _x
		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_whilecontrol().GetWhict()

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(218)

			var _x = p.Forcontrol()

			localctx.(*InstructionintContext)._forcontrol = _x
		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_forcontrol().GetForct()

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(221)

			var _x = p.Guardcontrol()

			localctx.(*InstructionintContext)._guardcontrol = _x
		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_guardcontrol().GetGuct()

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(224)

			var _x = p.Continuee()

			localctx.(*InstructionintContext)._continuee = _x
		}
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(225)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_continuee().GetCoct()

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(230)

			var _x = p.Breakk()

			localctx.(*InstructionintContext)._breakk = _x
		}
		p.SetState(232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(231)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_breakk().GetBrkct()

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(236)

			var _x = p.Retornos()

			localctx.(*InstructionintContext)._retornos = _x
		}
		p.SetState(238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(237)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_retornos().GetRect()

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(242)

			var _x = p.Vectorcontrol()

			localctx.(*InstructionintContext)._vectorcontrol = _x
		}
		p.SetState(244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(243)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_vectorcontrol().GetVect()

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(248)

			var _x = p.Vectoragregar()

			localctx.(*InstructionintContext)._vectoragregar = _x
		}
		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(249)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_vectoragregar().GetVeadct()

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(254)

			var _x = p.Vectorremover()

			localctx.(*InstructionintContext)._vectorremover = _x
		}
		p.SetState(256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(255)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_vectorremover().GetVermct()

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(260)

			var _x = p.Printstmt()

			localctx.(*InstructionintContext)._printstmt = _x
		}
		p.SetState(262)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(261)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		localctx.(*InstructionintContext).insint = localctx.(*InstructionintContext).Get_printstmt().GetPrnt()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclavaribleContext is an interface to support dynamic dispatch.
type IDeclavaribleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_VAR returns the _VAR token.
	Get_VAR() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_VAR sets the _VAR token.
	Set_VAR(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetDecvbl returns the decvbl attribute.
	GetDecvbl() interfaces.Instruction

	// SetDecvbl sets the decvbl attribute.
	SetDecvbl(interfaces.Instruction)

	// Getter signatures
	VAR() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	Tipodato() ITipodatoContext
	IG() antlr.TerminalNode
	Expr() IExprContext
	CIERRE_INTE() antlr.TerminalNode

	// IsDeclavaribleContext differentiates from other interfaces.
	IsDeclavaribleContext()
}

type DeclavaribleContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	decvbl     interfaces.Instruction
	_VAR       antlr.Token
	_ID_VALIDO antlr.Token
	_tipodato  ITipodatoContext
	_expr      IExprContext
}

func NewEmptyDeclavaribleContext() *DeclavaribleContext {
	var p = new(DeclavaribleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_declavarible
	return p
}

func InitEmptyDeclavaribleContext(p *DeclavaribleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_declavarible
}

func (*DeclavaribleContext) IsDeclavaribleContext() {}

func NewDeclavaribleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclavaribleContext {
	var p = new(DeclavaribleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_declavarible

	return p
}

func (s *DeclavaribleContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclavaribleContext) Get_VAR() antlr.Token { return s._VAR }

func (s *DeclavaribleContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *DeclavaribleContext) Set_VAR(v antlr.Token) { s._VAR = v }

func (s *DeclavaribleContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *DeclavaribleContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *DeclavaribleContext) Get_expr() IExprContext { return s._expr }

func (s *DeclavaribleContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *DeclavaribleContext) Set_expr(v IExprContext) { s._expr = v }

func (s *DeclavaribleContext) GetDecvbl() interfaces.Instruction { return s.decvbl }

func (s *DeclavaribleContext) SetDecvbl(v interfaces.Instruction) { s.decvbl = v }

func (s *DeclavaribleContext) VAR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserVAR, 0)
}

func (s *DeclavaribleContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *DeclavaribleContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *DeclavaribleContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *DeclavaribleContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *DeclavaribleContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeclavaribleContext) CIERRE_INTE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCIERRE_INTE, 0)
}

func (s *DeclavaribleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclavaribleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclavaribleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterDeclavarible(s)
	}
}

func (s *DeclavaribleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitDeclavarible(s)
	}
}

func (p *SwiftGrammarParser) Declavarible() (localctx IDeclavaribleContext) {
	localctx = NewDeclavaribleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, SwiftGrammarParserRULE_declavarible)
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(268)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*DeclavaribleContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(269)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*DeclavaribleContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(270)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(271)

			var _x = p.Tipodato()

			localctx.(*DeclavaribleContext)._tipodato = _x
		}
		{
			p.SetState(272)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(273)

			var _x = p.expr(0)

			localctx.(*DeclavaribleContext)._expr = _x
		}
		localctx.(*DeclavaribleContext).decvbl = instructions.NewVariableDeclaration((func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclavaribleContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*DeclavaribleContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*DeclavaribleContext).Get_tipodato().GetTipo(), localctx.(*DeclavaribleContext).Get_expr().GetE())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(276)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*DeclavaribleContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(277)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*DeclavaribleContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(279)

			var _x = p.expr(0)

			localctx.(*DeclavaribleContext)._expr = _x
		}
		localctx.(*DeclavaribleContext).decvbl = instructions.NewVariableDeclaracionSinTipo((func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclavaribleContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*DeclavaribleContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*DeclavaribleContext).Get_expr().GetE())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(282)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*DeclavaribleContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(283)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*DeclavaribleContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(284)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(285)

			var _x = p.Tipodato()

			localctx.(*DeclavaribleContext)._tipodato = _x
		}
		{
			p.SetState(286)
			p.Match(SwiftGrammarParserCIERRE_INTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*DeclavaribleContext).decvbl = instructions.NewVariableDeclaracionSinExp((func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclavaribleContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*DeclavaribleContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclavaribleContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*DeclavaribleContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*DeclavaribleContext).Get_tipodato().GetTipo())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclaconstanteContext is an interface to support dynamic dispatch.
type IDeclaconstanteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_LET returns the _LET token.
	Get_LET() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_LET sets the _LET token.
	Set_LET(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetDeccon returns the deccon attribute.
	GetDeccon() interfaces.Instruction

	// SetDeccon sets the deccon attribute.
	SetDeccon(interfaces.Instruction)

	// Getter signatures
	LET() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	Tipodato() ITipodatoContext
	IG() antlr.TerminalNode
	Expr() IExprContext

	// IsDeclaconstanteContext differentiates from other interfaces.
	IsDeclaconstanteContext()
}

type DeclaconstanteContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	deccon     interfaces.Instruction
	_LET       antlr.Token
	_ID_VALIDO antlr.Token
	_tipodato  ITipodatoContext
	_expr      IExprContext
}

func NewEmptyDeclaconstanteContext() *DeclaconstanteContext {
	var p = new(DeclaconstanteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_declaconstante
	return p
}

func InitEmptyDeclaconstanteContext(p *DeclaconstanteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_declaconstante
}

func (*DeclaconstanteContext) IsDeclaconstanteContext() {}

func NewDeclaconstanteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaconstanteContext {
	var p = new(DeclaconstanteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_declaconstante

	return p
}

func (s *DeclaconstanteContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaconstanteContext) Get_LET() antlr.Token { return s._LET }

func (s *DeclaconstanteContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *DeclaconstanteContext) Set_LET(v antlr.Token) { s._LET = v }

func (s *DeclaconstanteContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *DeclaconstanteContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *DeclaconstanteContext) Get_expr() IExprContext { return s._expr }

func (s *DeclaconstanteContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *DeclaconstanteContext) Set_expr(v IExprContext) { s._expr = v }

func (s *DeclaconstanteContext) GetDeccon() interfaces.Instruction { return s.deccon }

func (s *DeclaconstanteContext) SetDeccon(v interfaces.Instruction) { s.deccon = v }

func (s *DeclaconstanteContext) LET() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLET, 0)
}

func (s *DeclaconstanteContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *DeclaconstanteContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *DeclaconstanteContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *DeclaconstanteContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *DeclaconstanteContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *DeclaconstanteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaconstanteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaconstanteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterDeclaconstante(s)
	}
}

func (s *DeclaconstanteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitDeclaconstante(s)
	}
}

func (p *SwiftGrammarParser) Declaconstante() (localctx IDeclaconstanteContext) {
	localctx = NewDeclaconstanteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, SwiftGrammarParserRULE_declaconstante)
	p.SetState(305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(291)

			var _m = p.Match(SwiftGrammarParserLET)

			localctx.(*DeclaconstanteContext)._LET = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(292)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*DeclaconstanteContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(293)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(294)

			var _x = p.Tipodato()

			localctx.(*DeclaconstanteContext)._tipodato = _x
		}
		{
			p.SetState(295)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(296)

			var _x = p.expr(0)

			localctx.(*DeclaconstanteContext)._expr = _x
		}
		localctx.(*DeclaconstanteContext).deccon = instructions.NewConstanteDeclaration((func() int {
			if localctx.(*DeclaconstanteContext).Get_LET() == nil {
				return 0
			} else {
				return localctx.(*DeclaconstanteContext).Get_LET().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaconstanteContext).Get_LET() == nil {
				return 0
			} else {
				return localctx.(*DeclaconstanteContext).Get_LET().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclaconstanteContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*DeclaconstanteContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*DeclaconstanteContext).Get_tipodato().GetTipo(), localctx.(*DeclaconstanteContext).Get_expr().GetE())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(299)

			var _m = p.Match(SwiftGrammarParserLET)

			localctx.(*DeclaconstanteContext)._LET = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(300)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*DeclaconstanteContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(301)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(302)

			var _x = p.expr(0)

			localctx.(*DeclaconstanteContext)._expr = _x
		}
		localctx.(*DeclaconstanteContext).deccon = instructions.NewConstanteDeclaracionSinTipo((func() int {
			if localctx.(*DeclaconstanteContext).Get_LET() == nil {
				return 0
			} else {
				return localctx.(*DeclaconstanteContext).Get_LET().GetLine()
			}
		}()), (func() int {
			if localctx.(*DeclaconstanteContext).Get_LET() == nil {
				return 0
			} else {
				return localctx.(*DeclaconstanteContext).Get_LET().GetColumn()
			}
		}()), (func() string {
			if localctx.(*DeclaconstanteContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*DeclaconstanteContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*DeclaconstanteContext).Get_expr().GetE())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsignacionvariableContext is an interface to support dynamic dispatch.
type IAsignacionvariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetAsgvbl returns the asgvbl attribute.
	GetAsgvbl() interfaces.Instruction

	// SetAsgvbl sets the asgvbl attribute.
	SetAsgvbl(interfaces.Instruction)

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	IG() antlr.TerminalNode
	Expr() IExprContext
	SUMA() antlr.TerminalNode
	RESTA() antlr.TerminalNode

	// IsAsignacionvariableContext differentiates from other interfaces.
	IsAsignacionvariableContext()
}

type AsignacionvariableContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	asgvbl     interfaces.Instruction
	_ID_VALIDO antlr.Token
	_expr      IExprContext
}

func NewEmptyAsignacionvariableContext() *AsignacionvariableContext {
	var p = new(AsignacionvariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_asignacionvariable
	return p
}

func InitEmptyAsignacionvariableContext(p *AsignacionvariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_asignacionvariable
}

func (*AsignacionvariableContext) IsAsignacionvariableContext() {}

func NewAsignacionvariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsignacionvariableContext {
	var p = new(AsignacionvariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_asignacionvariable

	return p
}

func (s *AsignacionvariableContext) GetParser() antlr.Parser { return s.parser }

func (s *AsignacionvariableContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *AsignacionvariableContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *AsignacionvariableContext) Get_expr() IExprContext { return s._expr }

func (s *AsignacionvariableContext) Set_expr(v IExprContext) { s._expr = v }

func (s *AsignacionvariableContext) GetAsgvbl() interfaces.Instruction { return s.asgvbl }

func (s *AsignacionvariableContext) SetAsgvbl(v interfaces.Instruction) { s.asgvbl = v }

func (s *AsignacionvariableContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *AsignacionvariableContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *AsignacionvariableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AsignacionvariableContext) SUMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSUMA, 0)
}

func (s *AsignacionvariableContext) RESTA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserRESTA, 0)
}

func (s *AsignacionvariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsignacionvariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsignacionvariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterAsignacionvariable(s)
	}
}

func (s *AsignacionvariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitAsignacionvariable(s)
	}
}

func (p *SwiftGrammarParser) Asignacionvariable() (localctx IAsignacionvariableContext) {
	localctx = NewAsignacionvariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, SwiftGrammarParserRULE_asignacionvariable)
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(307)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*AsignacionvariableContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(308)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(309)

			var _x = p.expr(0)

			localctx.(*AsignacionvariableContext)._expr = _x
		}
		localctx.(*AsignacionvariableContext).asgvbl = instructions.NewAsignacionVariable((func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*AsignacionvariableContext).Get_expr().GetE())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(312)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*AsignacionvariableContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(313)
			p.Match(SwiftGrammarParserSUMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(314)

			var _x = p.expr(0)

			localctx.(*AsignacionvariableContext)._expr = _x
		}
		localctx.(*AsignacionvariableContext).asgvbl = instructions.NewAsignacionSuma((func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*AsignacionvariableContext).Get_expr().GetE())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(317)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*AsignacionvariableContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(318)
			p.Match(SwiftGrammarParserRESTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(319)

			var _x = p.expr(0)

			localctx.(*AsignacionvariableContext)._expr = _x
		}
		localctx.(*AsignacionvariableContext).asgvbl = instructions.NewAsignacionResta((func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*AsignacionvariableContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*AsignacionvariableContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*AsignacionvariableContext).Get_expr().GetE())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITipodatoContext is an interface to support dynamic dispatch.
type ITipodatoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTipo returns the tipo attribute.
	GetTipo() environment.TipoExpresion

	// SetTipo sets the tipo attribute.
	SetTipo(environment.TipoExpresion)

	// Getter signatures
	INT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	STRING() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	CHARACT() antlr.TerminalNode

	// IsTipodatoContext differentiates from other interfaces.
	IsTipodatoContext()
}

type TipodatoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	tipo   environment.TipoExpresion
}

func NewEmptyTipodatoContext() *TipodatoContext {
	var p = new(TipodatoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_tipodato
	return p
}

func InitEmptyTipodatoContext(p *TipodatoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_tipodato
}

func (*TipodatoContext) IsTipodatoContext() {}

func NewTipodatoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TipodatoContext {
	var p = new(TipodatoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_tipodato

	return p
}

func (s *TipodatoContext) GetParser() antlr.Parser { return s.parser }

func (s *TipodatoContext) GetTipo() environment.TipoExpresion { return s.tipo }

func (s *TipodatoContext) SetTipo(v environment.TipoExpresion) { s.tipo = v }

func (s *TipodatoContext) INT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserINT, 0)
}

func (s *TipodatoContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserFLOAT, 0)
}

func (s *TipodatoContext) STRING() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSTRING, 0)
}

func (s *TipodatoContext) BOOL() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserBOOL, 0)
}

func (s *TipodatoContext) CHARACT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCHARACT, 0)
}

func (s *TipodatoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TipodatoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TipodatoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterTipodato(s)
	}
}

func (s *TipodatoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitTipodato(s)
	}
}

func (p *SwiftGrammarParser) Tipodato() (localctx ITipodatoContext) {
	localctx = NewTipodatoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, SwiftGrammarParserRULE_tipodato)
	p.SetState(334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SwiftGrammarParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(324)
			p.Match(SwiftGrammarParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TipodatoContext).tipo = environment.INTEGER

	case SwiftGrammarParserFLOAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(326)
			p.Match(SwiftGrammarParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TipodatoContext).tipo = environment.FLOAT

	case SwiftGrammarParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(328)
			p.Match(SwiftGrammarParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TipodatoContext).tipo = environment.STRING

	case SwiftGrammarParserBOOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(330)
			p.Match(SwiftGrammarParserBOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TipodatoContext).tipo = environment.BOOLEAN

	case SwiftGrammarParserCHARACT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(332)
			p.Match(SwiftGrammarParserCHARACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*TipodatoContext).tipo = environment.CHARACTER

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// Get_NUMBER returns the _NUMBER token.
	Get_NUMBER() antlr.Token

	// Get_CADENA returns the _CADENA token.
	Get_CADENA() antlr.Token

	// Get_TRU returns the _TRU token.
	Get_TRU() antlr.Token

	// Get_FAL returns the _FAL token.
	Get_FAL() antlr.Token

	// Get_CHARACTER returns the _CHARACTER token.
	Get_CHARACTER() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_NULO returns the _NULO token.
	Get_NULO() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Set_NUMBER sets the _NUMBER token.
	Set_NUMBER(antlr.Token)

	// Set_CADENA sets the _CADENA token.
	Set_CADENA(antlr.Token)

	// Set_TRU sets the _TRU token.
	Set_TRU(antlr.Token)

	// Set_FAL sets the _FAL token.
	Set_FAL(antlr.Token)

	// Set_CHARACTER sets the _CHARACTER token.
	Set_CHARACTER(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_NULO sets the _NULO token.
	Set_NULO(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IExprContext

	// GetRight returns the right rule contexts.
	GetRight() IExprContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_vectorvacio returns the _vectorvacio rule contexts.
	Get_vectorvacio() IVectorvacioContext

	// Get_vectorcount returns the _vectorcount rule contexts.
	Get_vectorcount() IVectorcountContext

	// Get_vectoraccess returns the _vectoraccess rule contexts.
	Get_vectoraccess() IVectoraccessContext

	// Get_intembebida returns the _intembebida rule contexts.
	Get_intembebida() IIntembebidaContext

	// Get_floatembebida returns the _floatembebida rule contexts.
	Get_floatembebida() IFloatembebidaContext

	// Get_stringembebida returns the _stringembebida rule contexts.
	Get_stringembebida() IStringembebidaContext

	// SetLeft sets the left rule contexts.
	SetLeft(IExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IExprContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_vectorvacio sets the _vectorvacio rule contexts.
	Set_vectorvacio(IVectorvacioContext)

	// Set_vectorcount sets the _vectorcount rule contexts.
	Set_vectorcount(IVectorcountContext)

	// Set_vectoraccess sets the _vectoraccess rule contexts.
	Set_vectoraccess(IVectoraccessContext)

	// Set_intembebida sets the _intembebida rule contexts.
	Set_intembebida(IIntembebidaContext)

	// Set_floatembebida sets the _floatembebida rule contexts.
	Set_floatembebida(IFloatembebidaContext)

	// Set_stringembebida sets the _stringembebida rule contexts.
	Set_stringembebida(IStringembebidaContext)

	// GetE returns the e attribute.
	GetE() interfaces.Expression

	// SetE sets the e attribute.
	SetE(interfaces.Expression)

	// Getter signatures
	NOT() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	SUB() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	CADENA() antlr.TerminalNode
	TRU() antlr.TerminalNode
	FAL() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	NULO() antlr.TerminalNode
	Vectorvacio() IVectorvacioContext
	Vectorcount() IVectorcountContext
	Vectoraccess() IVectoraccessContext
	Intembebida() IIntembebidaContext
	Floatembebida() IFloatembebidaContext
	Stringembebida() IStringembebidaContext
	MODULO() antlr.TerminalNode
	MUL() antlr.TerminalNode
	DIV() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MAY_IG() antlr.TerminalNode
	MAYOR() antlr.TerminalNode
	MEN_IG() antlr.TerminalNode
	MENOR() antlr.TerminalNode
	IG_IG() antlr.TerminalNode
	DIF() antlr.TerminalNode
	AND() antlr.TerminalNode
	OR() antlr.TerminalNode

	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	e               interfaces.Expression
	left            IExprContext
	op              antlr.Token
	right           IExprContext
	_expr           IExprContext
	_NUMBER         antlr.Token
	_CADENA         antlr.Token
	_TRU            antlr.Token
	_FAL            antlr.Token
	_CHARACTER      antlr.Token
	_ID_VALIDO      antlr.Token
	_NULO           antlr.Token
	_vectorvacio    IVectorvacioContext
	_vectorcount    IVectorcountContext
	_vectoraccess   IVectoraccessContext
	_intembebida    IIntembebidaContext
	_floatembebida  IFloatembebidaContext
	_stringembebida IStringembebidaContext
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) GetOp() antlr.Token { return s.op }

func (s *ExprContext) Get_NUMBER() antlr.Token { return s._NUMBER }

func (s *ExprContext) Get_CADENA() antlr.Token { return s._CADENA }

func (s *ExprContext) Get_TRU() antlr.Token { return s._TRU }

func (s *ExprContext) Get_FAL() antlr.Token { return s._FAL }

func (s *ExprContext) Get_CHARACTER() antlr.Token { return s._CHARACTER }

func (s *ExprContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *ExprContext) Get_NULO() antlr.Token { return s._NULO }

func (s *ExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprContext) Set_NUMBER(v antlr.Token) { s._NUMBER = v }

func (s *ExprContext) Set_CADENA(v antlr.Token) { s._CADENA = v }

func (s *ExprContext) Set_TRU(v antlr.Token) { s._TRU = v }

func (s *ExprContext) Set_FAL(v antlr.Token) { s._FAL = v }

func (s *ExprContext) Set_CHARACTER(v antlr.Token) { s._CHARACTER = v }

func (s *ExprContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *ExprContext) Set_NULO(v antlr.Token) { s._NULO = v }

func (s *ExprContext) GetLeft() IExprContext { return s.left }

func (s *ExprContext) GetRight() IExprContext { return s.right }

func (s *ExprContext) Get_expr() IExprContext { return s._expr }

func (s *ExprContext) Get_vectorvacio() IVectorvacioContext { return s._vectorvacio }

func (s *ExprContext) Get_vectorcount() IVectorcountContext { return s._vectorcount }

func (s *ExprContext) Get_vectoraccess() IVectoraccessContext { return s._vectoraccess }

func (s *ExprContext) Get_intembebida() IIntembebidaContext { return s._intembebida }

func (s *ExprContext) Get_floatembebida() IFloatembebidaContext { return s._floatembebida }

func (s *ExprContext) Get_stringembebida() IStringembebidaContext { return s._stringembebida }

func (s *ExprContext) SetLeft(v IExprContext) { s.left = v }

func (s *ExprContext) SetRight(v IExprContext) { s.right = v }

func (s *ExprContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ExprContext) Set_vectorvacio(v IVectorvacioContext) { s._vectorvacio = v }

func (s *ExprContext) Set_vectorcount(v IVectorcountContext) { s._vectorcount = v }

func (s *ExprContext) Set_vectoraccess(v IVectoraccessContext) { s._vectoraccess = v }

func (s *ExprContext) Set_intembebida(v IIntembebidaContext) { s._intembebida = v }

func (s *ExprContext) Set_floatembebida(v IFloatembebidaContext) { s._floatembebida = v }

func (s *ExprContext) Set_stringembebida(v IStringembebidaContext) { s._stringembebida = v }

func (s *ExprContext) GetE() interfaces.Expression { return s.e }

func (s *ExprContext) SetE(v interfaces.Expression) { s.e = v }

func (s *ExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserNOT, 0)
}

func (s *ExprContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *ExprContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *ExprContext) SUB() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSUB, 0)
}

func (s *ExprContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserNUMBER, 0)
}

func (s *ExprContext) CADENA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCADENA, 0)
}

func (s *ExprContext) TRU() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserTRU, 0)
}

func (s *ExprContext) FAL() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserFAL, 0)
}

func (s *ExprContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCHARACTER, 0)
}

func (s *ExprContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *ExprContext) NULO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserNULO, 0)
}

func (s *ExprContext) Vectorvacio() IVectorvacioContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorvacioContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorvacioContext)
}

func (s *ExprContext) Vectorcount() IVectorcountContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectorcountContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectorcountContext)
}

func (s *ExprContext) Vectoraccess() IVectoraccessContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVectoraccessContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVectoraccessContext)
}

func (s *ExprContext) Intembebida() IIntembebidaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntembebidaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntembebidaContext)
}

func (s *ExprContext) Floatembebida() IFloatembebidaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatembebidaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatembebidaContext)
}

func (s *ExprContext) Stringembebida() IStringembebidaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringembebidaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringembebidaContext)
}

func (s *ExprContext) MODULO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMODULO, 0)
}

func (s *ExprContext) MUL() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMUL, 0)
}

func (s *ExprContext) DIV() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDIV, 0)
}

func (s *ExprContext) ADD() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserADD, 0)
}

func (s *ExprContext) MAY_IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMAY_IG, 0)
}

func (s *ExprContext) MAYOR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMAYOR, 0)
}

func (s *ExprContext) MEN_IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMEN_IG, 0)
}

func (s *ExprContext) MENOR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMENOR, 0)
}

func (s *ExprContext) IG_IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG_IG, 0)
}

func (s *ExprContext) DIF() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDIF, 0)
}

func (s *ExprContext) AND() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserAND, 0)
}

func (s *ExprContext) OR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserOR, 0)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterExpr(s)
	}
}

func (s *ExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitExpr(s)
	}
}

func (p *SwiftGrammarParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *SwiftGrammarParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 18
	p.EnterRecursionRule(localctx, 18, SwiftGrammarParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(337)

			var _m = p.Match(SwiftGrammarParserNOT)

			localctx.(*ExprContext).op = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(338)

			var _x = p.expr(24)

			localctx.(*ExprContext).right = _x
			localctx.(*ExprContext)._expr = _x
		}
		localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
			if localctx.(*ExprContext).GetRight() == nil {
				return nil
			} else {
				return localctx.(*ExprContext).GetRight().GetStart()
			}
		}()).GetLine(), (func() antlr.Token {
			if localctx.(*ExprContext).GetRight() == nil {
				return nil
			} else {
				return localctx.(*ExprContext).GetRight().GetStart()
			}
		}()).GetColumn(), localctx.(*ExprContext).GetRight().GetE(), (func() string {
			if localctx.(*ExprContext).GetOp() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).GetOp().GetText()
			}
		}()), localctx.(*ExprContext).GetRight().GetE())

	case 2:
		{
			p.SetState(341)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)

			var _x = p.expr(0)

			localctx.(*ExprContext)._expr = _x
		}
		{
			p.SetState(343)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_expr().GetE()

	case 3:
		{
			p.SetState(346)
			p.Match(SwiftGrammarParserSUB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(347)

			var _m = p.Match(SwiftGrammarParserNUMBER)

			localctx.(*ExprContext)._NUMBER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		if strings.Contains((func() string {
			if localctx.(*ExprContext).Get_NUMBER() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_NUMBER().GetText()
			}
		}()), ".") {
			num, err := strconv.ParseFloat((func() string {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return ""
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetText()
				}
			}()), 64)
			if err != nil {
				fmt.Println(err)
			}
			num2 := fmt.Sprintf("%.6f", num)
			num3, err := strconv.ParseFloat(num2, 64)
			if err != nil {
				fmt.Println(err)
			}
			localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetLine()
				}
			}()), (func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetColumn()
				}
			}()), -num3, environment.FLOAT)
		} else {
			num, err := strconv.Atoi((func() string {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return ""
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetText()
				}
			}()))
			if err != nil {
				fmt.Println(err)
			}
			localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetLine()
				}
			}()), (func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetColumn()
				}
			}()), -num, environment.INTEGER)
		}

	case 4:
		{
			p.SetState(349)

			var _m = p.Match(SwiftGrammarParserNUMBER)

			localctx.(*ExprContext)._NUMBER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		if strings.Contains((func() string {
			if localctx.(*ExprContext).Get_NUMBER() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_NUMBER().GetText()
			}
		}()), ".") {
			num, err := strconv.ParseFloat((func() string {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return ""
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetText()
				}
			}()), 64)
			if err != nil {
				fmt.Println(err)
			}
			num2 := fmt.Sprintf("%.6f", num)
			num3, err := strconv.ParseFloat(num2, 64)
			if err != nil {
				fmt.Println(err)
			}
			localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetLine()
				}
			}()), (func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetColumn()
				}
			}()), num3, environment.FLOAT)
		} else {
			num, err := strconv.Atoi((func() string {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return ""
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetText()
				}
			}()))
			if err != nil {
				fmt.Println(err)
			}
			localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetLine()
				}
			}()), (func() int {
				if localctx.(*ExprContext).Get_NUMBER() == nil {
					return 0
				} else {
					return localctx.(*ExprContext).Get_NUMBER().GetColumn()
				}
			}()), num, environment.INTEGER)
		}

	case 5:
		{
			p.SetState(351)

			var _m = p.Match(SwiftGrammarParserCADENA)

			localctx.(*ExprContext)._CADENA = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		str := (func() string {
			if localctx.(*ExprContext).Get_CADENA() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_CADENA().GetText()
			}
		}())
		localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
			if localctx.(*ExprContext).Get_CADENA() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_CADENA().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_CADENA() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_CADENA().GetColumn()
			}
		}()), str[1:len(str)-1], environment.STRING)

	case 6:
		{
			p.SetState(353)

			var _m = p.Match(SwiftGrammarParserTRU)

			localctx.(*ExprContext)._TRU = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
			if localctx.(*ExprContext).Get_TRU() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_TRU().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_TRU() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_TRU().GetColumn()
			}
		}()), true, environment.BOOLEAN)

	case 7:
		{
			p.SetState(355)

			var _m = p.Match(SwiftGrammarParserFAL)

			localctx.(*ExprContext)._FAL = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
			if localctx.(*ExprContext).Get_FAL() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_FAL().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_FAL() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_FAL().GetColumn()
			}
		}()), false, environment.BOOLEAN)

	case 8:
		{
			p.SetState(357)

			var _m = p.Match(SwiftGrammarParserCHARACTER)

			localctx.(*ExprContext)._CHARACTER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		str := (func() string {
			if localctx.(*ExprContext).Get_CHARACTER() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_CHARACTER().GetText()
			}
		}())
		localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
			if localctx.(*ExprContext).Get_CHARACTER() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_CHARACTER().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_CHARACTER() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_CHARACTER().GetColumn()
			}
		}()), str[1:len(str)-1], environment.CHARACTER)

	case 9:
		{
			p.SetState(359)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ExprContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		id := (func() string {
			if localctx.(*ExprContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_ID_VALIDO().GetText()
			}
		}())
		localctx.(*ExprContext).e = instructions.NewCallid((func() int {
			if localctx.(*ExprContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_ID_VALIDO().GetColumn()
			}
		}()), id)

	case 10:
		{
			p.SetState(361)

			var _m = p.Match(SwiftGrammarParserNULO)

			localctx.(*ExprContext)._NULO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ExprContext).e = expressions.NewPrimitive((func() int {
			if localctx.(*ExprContext).Get_NULO() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_NULO().GetLine()
			}
		}()), (func() int {
			if localctx.(*ExprContext).Get_NULO() == nil {
				return 0
			} else {
				return localctx.(*ExprContext).Get_NULO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ExprContext).Get_NULO() == nil {
				return ""
			} else {
				return localctx.(*ExprContext).Get_NULO().GetText()
			}
		}()), environment.NULL)

	case 11:
		{
			p.SetState(363)

			var _x = p.Vectorvacio()

			localctx.(*ExprContext)._vectorvacio = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_vectorvacio().GetVeemct()

	case 12:
		{
			p.SetState(366)

			var _x = p.Vectorcount()

			localctx.(*ExprContext)._vectorcount = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_vectorcount().GetVecnct()

	case 13:
		{
			p.SetState(369)

			var _x = p.Vectoraccess()

			localctx.(*ExprContext)._vectoraccess = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_vectoraccess().GetVepposct()

	case 14:
		{
			p.SetState(372)

			var _x = p.Intembebida()

			localctx.(*ExprContext)._intembebida = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_intembebida().GetIntemb()

	case 15:
		{
			p.SetState(375)

			var _x = p.Floatembebida()

			localctx.(*ExprContext)._floatembebida = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_floatembebida().GetFloemb()

	case 16:
		{
			p.SetState(378)

			var _x = p.Stringembebida()

			localctx.(*ExprContext)._stringembebida = _x
		}
		localctx.(*ExprContext).e = localctx.(*ExprContext).Get_stringembebida().GetStremb()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(423)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(383)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(384)

					var _m = p.Match(SwiftGrammarParserMODULO)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(385)

					var _x = p.expr(24)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 2:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(388)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(389)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SwiftGrammarParserMUL || _la == SwiftGrammarParserDIV) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(390)

					var _x = p.expr(23)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 3:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(393)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(394)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SwiftGrammarParserADD || _la == SwiftGrammarParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(395)

					var _x = p.expr(22)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 4:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(398)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(399)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SwiftGrammarParserMAY_IG || _la == SwiftGrammarParserMAYOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(400)

					var _x = p.expr(21)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 5:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(403)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(404)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SwiftGrammarParserMEN_IG || _la == SwiftGrammarParserMENOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(405)

					var _x = p.expr(20)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 6:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(408)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
					goto errorExit
				}
				{
					p.SetState(409)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == SwiftGrammarParserDIF || _la == SwiftGrammarParserIG_IG) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(410)

					var _x = p.expr(19)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 7:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(413)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(414)

					var _m = p.Match(SwiftGrammarParserAND)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(415)

					var _x = p.expr(18)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case 8:
				localctx = NewExprContext(p, _parentctx, _parentState)
				localctx.(*ExprContext).left = _prevctx
				p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_expr)
				p.SetState(418)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(419)

					var _m = p.Match(SwiftGrammarParserOR)

					localctx.(*ExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(420)

					var _x = p.expr(17)

					localctx.(*ExprContext).right = _x
					localctx.(*ExprContext)._expr = _x
				}
				localctx.(*ExprContext).e = expressions.NewOperation((func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetLine(), (func() antlr.Token {
					if localctx.(*ExprContext).GetLeft() == nil {
						return nil
					} else {
						return localctx.(*ExprContext).GetLeft().GetStart()
					}
				}()).GetColumn(), localctx.(*ExprContext).GetLeft().GetE(), (func() string {
					if localctx.(*ExprContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ExprContext).GetOp().GetText()
					}
				}()), localctx.(*ExprContext).GetRight().GetE())

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISentenciaifelseContext is an interface to support dynamic dispatch.
type ISentenciaifelseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_IF returns the _IF token.
	Get_IF() antlr.Token

	// Set_IF sets the _IF token.
	Set_IF(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// GetIfop returns the ifop rule contexts.
	GetIfop() IBlockinternoContext

	// GetElseop returns the elseop rule contexts.
	GetElseop() IBlockinternoContext

	// Get_sentenciaifelse returns the _sentenciaifelse rule contexts.
	Get_sentenciaifelse() ISentenciaifelseContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// SetIfop sets the ifop rule contexts.
	SetIfop(IBlockinternoContext)

	// SetElseop sets the elseop rule contexts.
	SetElseop(IBlockinternoContext)

	// Set_sentenciaifelse sets the _sentenciaifelse rule contexts.
	Set_sentenciaifelse(ISentenciaifelseContext)

	// GetMyIfElse returns the myIfElse attribute.
	GetMyIfElse() interfaces.Instruction

	// SetMyIfElse sets the myIfElse attribute.
	SetMyIfElse(interfaces.Instruction)

	// Getter signatures
	IF() antlr.TerminalNode
	Expr() IExprContext
	AllLLAVEIZQ() []antlr.TerminalNode
	LLAVEIZQ(i int) antlr.TerminalNode
	AllBlockinterno() []IBlockinternoContext
	Blockinterno(i int) IBlockinternoContext
	AllLLAVEDER() []antlr.TerminalNode
	LLAVEDER(i int) antlr.TerminalNode
	ELSE() antlr.TerminalNode
	Sentenciaifelse() ISentenciaifelseContext

	// IsSentenciaifelseContext differentiates from other interfaces.
	IsSentenciaifelseContext()
}

type SentenciaifelseContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	myIfElse         interfaces.Instruction
	_IF              antlr.Token
	_expr            IExprContext
	_blockinterno    IBlockinternoContext
	ifop             IBlockinternoContext
	elseop           IBlockinternoContext
	_sentenciaifelse ISentenciaifelseContext
}

func NewEmptySentenciaifelseContext() *SentenciaifelseContext {
	var p = new(SentenciaifelseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_sentenciaifelse
	return p
}

func InitEmptySentenciaifelseContext(p *SentenciaifelseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_sentenciaifelse
}

func (*SentenciaifelseContext) IsSentenciaifelseContext() {}

func NewSentenciaifelseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenciaifelseContext {
	var p = new(SentenciaifelseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_sentenciaifelse

	return p
}

func (s *SentenciaifelseContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenciaifelseContext) Get_IF() antlr.Token { return s._IF }

func (s *SentenciaifelseContext) Set_IF(v antlr.Token) { s._IF = v }

func (s *SentenciaifelseContext) Get_expr() IExprContext { return s._expr }

func (s *SentenciaifelseContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *SentenciaifelseContext) GetIfop() IBlockinternoContext { return s.ifop }

func (s *SentenciaifelseContext) GetElseop() IBlockinternoContext { return s.elseop }

func (s *SentenciaifelseContext) Get_sentenciaifelse() ISentenciaifelseContext {
	return s._sentenciaifelse
}

func (s *SentenciaifelseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *SentenciaifelseContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *SentenciaifelseContext) SetIfop(v IBlockinternoContext) { s.ifop = v }

func (s *SentenciaifelseContext) SetElseop(v IBlockinternoContext) { s.elseop = v }

func (s *SentenciaifelseContext) Set_sentenciaifelse(v ISentenciaifelseContext) {
	s._sentenciaifelse = v
}

func (s *SentenciaifelseContext) GetMyIfElse() interfaces.Instruction { return s.myIfElse }

func (s *SentenciaifelseContext) SetMyIfElse(v interfaces.Instruction) { s.myIfElse = v }

func (s *SentenciaifelseContext) IF() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIF, 0)
}

func (s *SentenciaifelseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SentenciaifelseContext) AllLLAVEIZQ() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserLLAVEIZQ)
}

func (s *SentenciaifelseContext) LLAVEIZQ(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, i)
}

func (s *SentenciaifelseContext) AllBlockinterno() []IBlockinternoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockinternoContext); ok {
			len++
		}
	}

	tst := make([]IBlockinternoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockinternoContext); ok {
			tst[i] = t.(IBlockinternoContext)
			i++
		}
	}

	return tst
}

func (s *SentenciaifelseContext) Blockinterno(i int) IBlockinternoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *SentenciaifelseContext) AllLLAVEDER() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserLLAVEDER)
}

func (s *SentenciaifelseContext) LLAVEDER(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, i)
}

func (s *SentenciaifelseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserELSE, 0)
}

func (s *SentenciaifelseContext) Sentenciaifelse() ISentenciaifelseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenciaifelseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenciaifelseContext)
}

func (s *SentenciaifelseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenciaifelseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenciaifelseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterSentenciaifelse(s)
	}
}

func (s *SentenciaifelseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitSentenciaifelse(s)
	}
}

func (p *SwiftGrammarParser) Sentenciaifelse() (localctx ISentenciaifelseContext) {
	localctx = NewSentenciaifelseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, SwiftGrammarParserRULE_sentenciaifelse)
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(428)

			var _m = p.Match(SwiftGrammarParserIF)

			localctx.(*SentenciaifelseContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(429)

			var _x = p.expr(0)

			localctx.(*SentenciaifelseContext)._expr = _x
		}
		{
			p.SetState(430)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(431)

			var _x = p.Blockinterno()

			localctx.(*SentenciaifelseContext)._blockinterno = _x
		}
		{
			p.SetState(432)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SentenciaifelseContext).myIfElse = instructions.NewSentenciaIf((func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetLine()
			}
		}()), (func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetColumn()
			}
		}()), localctx.(*SentenciaifelseContext).Get_expr().GetE(), localctx.(*SentenciaifelseContext).Get_blockinterno().GetBlkint())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(435)

			var _m = p.Match(SwiftGrammarParserIF)

			localctx.(*SentenciaifelseContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(436)

			var _x = p.expr(0)

			localctx.(*SentenciaifelseContext)._expr = _x
		}
		{
			p.SetState(437)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(438)

			var _x = p.Blockinterno()

			localctx.(*SentenciaifelseContext).ifop = _x
		}
		{
			p.SetState(439)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(440)
			p.Match(SwiftGrammarParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(441)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(442)

			var _x = p.Blockinterno()

			localctx.(*SentenciaifelseContext).elseop = _x
		}
		{
			p.SetState(443)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SentenciaifelseContext).myIfElse = instructions.NewSentenciaIfElse((func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetLine()
			}
		}()), (func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetColumn()
			}
		}()), localctx.(*SentenciaifelseContext).Get_expr().GetE(), localctx.(*SentenciaifelseContext).GetIfop().GetBlkint(), localctx.(*SentenciaifelseContext).GetElseop().GetBlkint())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(446)

			var _m = p.Match(SwiftGrammarParserIF)

			localctx.(*SentenciaifelseContext)._IF = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(447)

			var _x = p.expr(0)

			localctx.(*SentenciaifelseContext)._expr = _x
		}
		{
			p.SetState(448)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(449)

			var _x = p.Blockinterno()

			localctx.(*SentenciaifelseContext)._blockinterno = _x
		}
		{
			p.SetState(450)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(451)
			p.Match(SwiftGrammarParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(452)

			var _x = p.Sentenciaifelse()

			localctx.(*SentenciaifelseContext)._sentenciaifelse = _x
		}
		localctx.(*SentenciaifelseContext).myIfElse = instructions.NewSentenciaIfElseIf((func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetLine()
			}
		}()), (func() int {
			if localctx.(*SentenciaifelseContext).Get_IF() == nil {
				return 0
			} else {
				return localctx.(*SentenciaifelseContext).Get_IF().GetColumn()
			}
		}()), localctx.(*SentenciaifelseContext).Get_expr().GetE(), localctx.(*SentenciaifelseContext).Get_blockinterno().GetBlkint(), localctx.(*SentenciaifelseContext).Get_sentenciaifelse().GetMyIfElse())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchcontrolContext is an interface to support dynamic dispatch.
type ISwitchcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_SWITCH returns the _SWITCH token.
	Get_SWITCH() antlr.Token

	// Get_DEFAULT returns the _DEFAULT token.
	Get_DEFAULT() antlr.Token

	// Set_SWITCH sets the _SWITCH token.
	Set_SWITCH(antlr.Token)

	// Set_DEFAULT sets the _DEFAULT token.
	Set_DEFAULT(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_blockcase returns the _blockcase rule contexts.
	Get_blockcase() IBlockcaseContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_blockcase sets the _blockcase rule contexts.
	Set_blockcase(IBlockcaseContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// GetMySwitch returns the mySwitch attribute.
	GetMySwitch() interfaces.Instruction

	// SetMySwitch sets the mySwitch attribute.
	SetMySwitch(interfaces.Instruction)

	// Getter signatures
	SWITCH() antlr.TerminalNode
	Expr() IExprContext
	LLAVEIZQ() antlr.TerminalNode
	Blockcase() IBlockcaseContext
	LLAVEDER() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	Blockinterno() IBlockinternoContext

	// IsSwitchcontrolContext differentiates from other interfaces.
	IsSwitchcontrolContext()
}

type SwitchcontrolContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	mySwitch      interfaces.Instruction
	_SWITCH       antlr.Token
	_expr         IExprContext
	_blockcase    IBlockcaseContext
	_DEFAULT      antlr.Token
	_blockinterno IBlockinternoContext
}

func NewEmptySwitchcontrolContext() *SwitchcontrolContext {
	var p = new(SwitchcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_switchcontrol
	return p
}

func InitEmptySwitchcontrolContext(p *SwitchcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_switchcontrol
}

func (*SwitchcontrolContext) IsSwitchcontrolContext() {}

func NewSwitchcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchcontrolContext {
	var p = new(SwitchcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_switchcontrol

	return p
}

func (s *SwitchcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchcontrolContext) Get_SWITCH() antlr.Token { return s._SWITCH }

func (s *SwitchcontrolContext) Get_DEFAULT() antlr.Token { return s._DEFAULT }

func (s *SwitchcontrolContext) Set_SWITCH(v antlr.Token) { s._SWITCH = v }

func (s *SwitchcontrolContext) Set_DEFAULT(v antlr.Token) { s._DEFAULT = v }

func (s *SwitchcontrolContext) Get_expr() IExprContext { return s._expr }

func (s *SwitchcontrolContext) Get_blockcase() IBlockcaseContext { return s._blockcase }

func (s *SwitchcontrolContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *SwitchcontrolContext) Set_expr(v IExprContext) { s._expr = v }

func (s *SwitchcontrolContext) Set_blockcase(v IBlockcaseContext) { s._blockcase = v }

func (s *SwitchcontrolContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *SwitchcontrolContext) GetMySwitch() interfaces.Instruction { return s.mySwitch }

func (s *SwitchcontrolContext) SetMySwitch(v interfaces.Instruction) { s.mySwitch = v }

func (s *SwitchcontrolContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSWITCH, 0)
}

func (s *SwitchcontrolContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SwitchcontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *SwitchcontrolContext) Blockcase() IBlockcaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockcaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockcaseContext)
}

func (s *SwitchcontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *SwitchcontrolContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDEFAULT, 0)
}

func (s *SwitchcontrolContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *SwitchcontrolContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *SwitchcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterSwitchcontrol(s)
	}
}

func (s *SwitchcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitSwitchcontrol(s)
	}
}

func (p *SwiftGrammarParser) Switchcontrol() (localctx ISwitchcontrolContext) {
	localctx = NewSwitchcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, SwiftGrammarParserRULE_switchcontrol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)

		var _m = p.Match(SwiftGrammarParserSWITCH)

		localctx.(*SwitchcontrolContext)._SWITCH = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(458)

		var _x = p.expr(0)

		localctx.(*SwitchcontrolContext)._expr = _x
	}
	{
		p.SetState(459)
		p.Match(SwiftGrammarParserLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(460)

		var _x = p.Blockcase()

		localctx.(*SwitchcontrolContext)._blockcase = _x
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SwiftGrammarParserDEFAULT {
		{
			p.SetState(461)

			var _m = p.Match(SwiftGrammarParserDEFAULT)

			localctx.(*SwitchcontrolContext)._DEFAULT = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(462)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(463)

			var _x = p.Blockinterno()

			localctx.(*SwitchcontrolContext)._blockinterno = _x
		}

	}
	{
		p.SetState(466)
		p.Match(SwiftGrammarParserLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	if localctx.(*SwitchcontrolContext).Get_DEFAULT() != nil {
		localctx.(*SwitchcontrolContext).mySwitch = instructions.NewSentenciaSwitchDefault((func() int {
			if localctx.(*SwitchcontrolContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*SwitchcontrolContext).Get_SWITCH().GetLine()
			}
		}()), (func() int {
			if localctx.(*SwitchcontrolContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*SwitchcontrolContext).Get_SWITCH().GetColumn()
			}
		}()), localctx.(*SwitchcontrolContext).Get_expr().GetE(), localctx.(*SwitchcontrolContext).Get_blockcase().GetBlkcase(), localctx.(*SwitchcontrolContext).Get_blockinterno().GetBlkint())
	} else {
		localctx.(*SwitchcontrolContext).mySwitch = instructions.NewSentenciaSwitch((func() int {
			if localctx.(*SwitchcontrolContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*SwitchcontrolContext).Get_SWITCH().GetLine()
			}
		}()), (func() int {
			if localctx.(*SwitchcontrolContext).Get_SWITCH() == nil {
				return 0
			} else {
				return localctx.(*SwitchcontrolContext).Get_SWITCH().GetColumn()
			}
		}()), localctx.(*SwitchcontrolContext).Get_expr().GetE(), localctx.(*SwitchcontrolContext).Get_blockcase().GetBlkcase())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockcaseContext is an interface to support dynamic dispatch.
type IBlockcaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_bloquecase returns the _bloquecase rule contexts.
	Get_bloquecase() IBloquecaseContext

	// Set_bloquecase sets the _bloquecase rule contexts.
	Set_bloquecase(IBloquecaseContext)

	// GetBlocas returns the blocas rule context list.
	GetBlocas() []IBloquecaseContext

	// SetBlocas sets the blocas rule context list.
	SetBlocas([]IBloquecaseContext)

	// GetBlkcase returns the blkcase attribute.
	GetBlkcase() []interface{}

	// SetBlkcase sets the blkcase attribute.
	SetBlkcase([]interface{})

	// Getter signatures
	AllBloquecase() []IBloquecaseContext
	Bloquecase(i int) IBloquecaseContext

	// IsBlockcaseContext differentiates from other interfaces.
	IsBlockcaseContext()
}

type BlockcaseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	blkcase     []interface{}
	_bloquecase IBloquecaseContext
	blocas      []IBloquecaseContext
}

func NewEmptyBlockcaseContext() *BlockcaseContext {
	var p = new(BlockcaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockcase
	return p
}

func InitEmptyBlockcaseContext(p *BlockcaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockcase
}

func (*BlockcaseContext) IsBlockcaseContext() {}

func NewBlockcaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockcaseContext {
	var p = new(BlockcaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_blockcase

	return p
}

func (s *BlockcaseContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockcaseContext) Get_bloquecase() IBloquecaseContext { return s._bloquecase }

func (s *BlockcaseContext) Set_bloquecase(v IBloquecaseContext) { s._bloquecase = v }

func (s *BlockcaseContext) GetBlocas() []IBloquecaseContext { return s.blocas }

func (s *BlockcaseContext) SetBlocas(v []IBloquecaseContext) { s.blocas = v }

func (s *BlockcaseContext) GetBlkcase() []interface{} { return s.blkcase }

func (s *BlockcaseContext) SetBlkcase(v []interface{}) { s.blkcase = v }

func (s *BlockcaseContext) AllBloquecase() []IBloquecaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBloquecaseContext); ok {
			len++
		}
	}

	tst := make([]IBloquecaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBloquecaseContext); ok {
			tst[i] = t.(IBloquecaseContext)
			i++
		}
	}

	return tst
}

func (s *BlockcaseContext) Bloquecase(i int) IBloquecaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloquecaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloquecaseContext)
}

func (s *BlockcaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockcaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockcaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBlockcase(s)
	}
}

func (s *BlockcaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBlockcase(s)
	}
}

func (p *SwiftGrammarParser) Blockcase() (localctx IBlockcaseContext) {
	localctx = NewBlockcaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, SwiftGrammarParserRULE_blockcase)

	localctx.(*BlockcaseContext).blkcase = []interface{}{}
	var listInt []IBloquecaseContext

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(470)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SwiftGrammarParserCASE {
		{
			p.SetState(469)

			var _x = p.Bloquecase()

			localctx.(*BlockcaseContext)._bloquecase = _x
		}
		localctx.(*BlockcaseContext).blocas = append(localctx.(*BlockcaseContext).blocas, localctx.(*BlockcaseContext)._bloquecase)

		p.SetState(472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt = localctx.(*BlockcaseContext).GetBlocas()
	for _, e := range listInt {
		localctx.(*BlockcaseContext).blkcase = append(localctx.(*BlockcaseContext).blkcase, e.GetBlocas())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBloquecaseContext is an interface to support dynamic dispatch.
type IBloquecaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CASE returns the _CASE token.
	Get_CASE() antlr.Token

	// Set_CASE sets the _CASE token.
	Set_CASE(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// GetBlocas returns the blocas attribute.
	GetBlocas() interfaces.Instruction

	// SetBlocas sets the blocas attribute.
	SetBlocas(interfaces.Instruction)

	// Getter signatures
	CASE() antlr.TerminalNode
	Expr() IExprContext
	DOS_PUNTOS() antlr.TerminalNode
	Blockinterno() IBlockinternoContext

	// IsBloquecaseContext differentiates from other interfaces.
	IsBloquecaseContext()
}

type BloquecaseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	blocas        interfaces.Instruction
	_CASE         antlr.Token
	_expr         IExprContext
	_blockinterno IBlockinternoContext
}

func NewEmptyBloquecaseContext() *BloquecaseContext {
	var p = new(BloquecaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_bloquecase
	return p
}

func InitEmptyBloquecaseContext(p *BloquecaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_bloquecase
}

func (*BloquecaseContext) IsBloquecaseContext() {}

func NewBloquecaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BloquecaseContext {
	var p = new(BloquecaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_bloquecase

	return p
}

func (s *BloquecaseContext) GetParser() antlr.Parser { return s.parser }

func (s *BloquecaseContext) Get_CASE() antlr.Token { return s._CASE }

func (s *BloquecaseContext) Set_CASE(v antlr.Token) { s._CASE = v }

func (s *BloquecaseContext) Get_expr() IExprContext { return s._expr }

func (s *BloquecaseContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *BloquecaseContext) Set_expr(v IExprContext) { s._expr = v }

func (s *BloquecaseContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *BloquecaseContext) GetBlocas() interfaces.Instruction { return s.blocas }

func (s *BloquecaseContext) SetBlocas(v interfaces.Instruction) { s.blocas = v }

func (s *BloquecaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCASE, 0)
}

func (s *BloquecaseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *BloquecaseContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *BloquecaseContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *BloquecaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BloquecaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BloquecaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBloquecase(s)
	}
}

func (s *BloquecaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBloquecase(s)
	}
}

func (p *SwiftGrammarParser) Bloquecase() (localctx IBloquecaseContext) {
	localctx = NewBloquecaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, SwiftGrammarParserRULE_bloquecase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(476)

		var _m = p.Match(SwiftGrammarParserCASE)

		localctx.(*BloquecaseContext)._CASE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(477)

		var _x = p.expr(0)

		localctx.(*BloquecaseContext)._expr = _x
	}
	{
		p.SetState(478)
		p.Match(SwiftGrammarParserDOS_PUNTOS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(479)

		var _x = p.Blockinterno()

		localctx.(*BloquecaseContext)._blockinterno = _x
	}

	localctx.(*BloquecaseContext).blocas = instructions.NewSentenciaSwitchCase((func() int {
		if localctx.(*BloquecaseContext).Get_CASE() == nil {
			return 0
		} else {
			return localctx.(*BloquecaseContext).Get_CASE().GetLine()
		}
	}()), (func() int {
		if localctx.(*BloquecaseContext).Get_CASE() == nil {
			return 0
		} else {
			return localctx.(*BloquecaseContext).Get_CASE().GetColumn()
		}
	}()), localctx.(*BloquecaseContext).Get_expr().GetE(), localctx.(*BloquecaseContext).Get_blockinterno().GetBlkint())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhilecontrolContext is an interface to support dynamic dispatch.
type IWhilecontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_WHILE returns the _WHILE token.
	Get_WHILE() antlr.Token

	// Set_WHILE sets the _WHILE token.
	Set_WHILE(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// GetWhict returns the whict attribute.
	GetWhict() interfaces.Instruction

	// SetWhict sets the whict attribute.
	SetWhict(interfaces.Instruction)

	// Getter signatures
	WHILE() antlr.TerminalNode
	Expr() IExprContext
	LLAVEIZQ() antlr.TerminalNode
	Blockinterno() IBlockinternoContext
	LLAVEDER() antlr.TerminalNode

	// IsWhilecontrolContext differentiates from other interfaces.
	IsWhilecontrolContext()
}

type WhilecontrolContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	whict         interfaces.Instruction
	_WHILE        antlr.Token
	_expr         IExprContext
	_blockinterno IBlockinternoContext
}

func NewEmptyWhilecontrolContext() *WhilecontrolContext {
	var p = new(WhilecontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_whilecontrol
	return p
}

func InitEmptyWhilecontrolContext(p *WhilecontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_whilecontrol
}

func (*WhilecontrolContext) IsWhilecontrolContext() {}

func NewWhilecontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhilecontrolContext {
	var p = new(WhilecontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_whilecontrol

	return p
}

func (s *WhilecontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *WhilecontrolContext) Get_WHILE() antlr.Token { return s._WHILE }

func (s *WhilecontrolContext) Set_WHILE(v antlr.Token) { s._WHILE = v }

func (s *WhilecontrolContext) Get_expr() IExprContext { return s._expr }

func (s *WhilecontrolContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *WhilecontrolContext) Set_expr(v IExprContext) { s._expr = v }

func (s *WhilecontrolContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *WhilecontrolContext) GetWhict() interfaces.Instruction { return s.whict }

func (s *WhilecontrolContext) SetWhict(v interfaces.Instruction) { s.whict = v }

func (s *WhilecontrolContext) WHILE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserWHILE, 0)
}

func (s *WhilecontrolContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhilecontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *WhilecontrolContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *WhilecontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *WhilecontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhilecontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhilecontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterWhilecontrol(s)
	}
}

func (s *WhilecontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitWhilecontrol(s)
	}
}

func (p *SwiftGrammarParser) Whilecontrol() (localctx IWhilecontrolContext) {
	localctx = NewWhilecontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, SwiftGrammarParserRULE_whilecontrol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)

		var _m = p.Match(SwiftGrammarParserWHILE)

		localctx.(*WhilecontrolContext)._WHILE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(483)

		var _x = p.expr(0)

		localctx.(*WhilecontrolContext)._expr = _x
	}
	{
		p.SetState(484)
		p.Match(SwiftGrammarParserLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(485)

		var _x = p.Blockinterno()

		localctx.(*WhilecontrolContext)._blockinterno = _x
	}
	{
		p.SetState(486)
		p.Match(SwiftGrammarParserLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*WhilecontrolContext).whict = instructions.NewSentenciaWhile((func() int {
		if localctx.(*WhilecontrolContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*WhilecontrolContext).Get_WHILE().GetLine()
		}
	}()), (func() int {
		if localctx.(*WhilecontrolContext).Get_WHILE() == nil {
			return 0
		} else {
			return localctx.(*WhilecontrolContext).Get_WHILE().GetColumn()
		}
	}()), localctx.(*WhilecontrolContext).Get_expr().GetE(), localctx.(*WhilecontrolContext).Get_blockinterno().GetBlkint())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForcontrolContext is an interface to support dynamic dispatch.
type IForcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_FOR returns the _FOR token.
	Get_FOR() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_FOR sets the _FOR token.
	Set_FOR(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// GetLeft returns the left rule contexts.
	GetLeft() IExprContext

	// GetRight returns the right rule contexts.
	GetRight() IExprContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// SetLeft sets the left rule contexts.
	SetLeft(IExprContext)

	// SetRight sets the right rule contexts.
	SetRight(IExprContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetForct returns the forct attribute.
	GetForct() interfaces.Instruction

	// SetForct sets the forct attribute.
	SetForct(interfaces.Instruction)

	// Getter signatures
	FOR() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	IN() antlr.TerminalNode
	RANGO() antlr.TerminalNode
	LLAVEIZQ() antlr.TerminalNode
	Blockinterno() IBlockinternoContext
	LLAVEDER() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsForcontrolContext differentiates from other interfaces.
	IsForcontrolContext()
}

type ForcontrolContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	forct         interfaces.Instruction
	_FOR          antlr.Token
	_ID_VALIDO    antlr.Token
	left          IExprContext
	right         IExprContext
	_blockinterno IBlockinternoContext
	_expr         IExprContext
}

func NewEmptyForcontrolContext() *ForcontrolContext {
	var p = new(ForcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_forcontrol
	return p
}

func InitEmptyForcontrolContext(p *ForcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_forcontrol
}

func (*ForcontrolContext) IsForcontrolContext() {}

func NewForcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForcontrolContext {
	var p = new(ForcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_forcontrol

	return p
}

func (s *ForcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *ForcontrolContext) Get_FOR() antlr.Token { return s._FOR }

func (s *ForcontrolContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *ForcontrolContext) Set_FOR(v antlr.Token) { s._FOR = v }

func (s *ForcontrolContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *ForcontrolContext) GetLeft() IExprContext { return s.left }

func (s *ForcontrolContext) GetRight() IExprContext { return s.right }

func (s *ForcontrolContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *ForcontrolContext) Get_expr() IExprContext { return s._expr }

func (s *ForcontrolContext) SetLeft(v IExprContext) { s.left = v }

func (s *ForcontrolContext) SetRight(v IExprContext) { s.right = v }

func (s *ForcontrolContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *ForcontrolContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ForcontrolContext) GetForct() interfaces.Instruction { return s.forct }

func (s *ForcontrolContext) SetForct(v interfaces.Instruction) { s.forct = v }

func (s *ForcontrolContext) FOR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserFOR, 0)
}

func (s *ForcontrolContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *ForcontrolContext) IN() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIN, 0)
}

func (s *ForcontrolContext) RANGO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserRANGO, 0)
}

func (s *ForcontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *ForcontrolContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *ForcontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *ForcontrolContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ForcontrolContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ForcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterForcontrol(s)
	}
}

func (s *ForcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitForcontrol(s)
	}
}

func (p *SwiftGrammarParser) Forcontrol() (localctx IForcontrolContext) {
	localctx = NewForcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, SwiftGrammarParserRULE_forcontrol)
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(489)

			var _m = p.Match(SwiftGrammarParserFOR)

			localctx.(*ForcontrolContext)._FOR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(490)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ForcontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.Match(SwiftGrammarParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(492)

			var _x = p.expr(0)

			localctx.(*ForcontrolContext).left = _x
		}
		{
			p.SetState(493)
			p.Match(SwiftGrammarParserRANGO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(494)

			var _x = p.expr(0)

			localctx.(*ForcontrolContext).right = _x
		}
		{
			p.SetState(495)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(496)

			var _x = p.Blockinterno()

			localctx.(*ForcontrolContext)._blockinterno = _x
		}
		{
			p.SetState(497)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ForcontrolContext).forct = instructions.NewSentenciaForRango((func() int {
			if localctx.(*ForcontrolContext).Get_FOR() == nil {
				return 0
			} else {
				return localctx.(*ForcontrolContext).Get_FOR().GetLine()
			}
		}()), (func() int {
			if localctx.(*ForcontrolContext).Get_FOR() == nil {
				return 0
			} else {
				return localctx.(*ForcontrolContext).Get_FOR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ForcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*ForcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*ForcontrolContext).GetLeft().GetE(), localctx.(*ForcontrolContext).GetRight().GetE(), localctx.(*ForcontrolContext).Get_blockinterno().GetBlkint())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)

			var _m = p.Match(SwiftGrammarParserFOR)

			localctx.(*ForcontrolContext)._FOR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(501)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ForcontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.Match(SwiftGrammarParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(503)

			var _x = p.expr(0)

			localctx.(*ForcontrolContext)._expr = _x
		}
		{
			p.SetState(504)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(505)

			var _x = p.Blockinterno()

			localctx.(*ForcontrolContext)._blockinterno = _x
		}
		{
			p.SetState(506)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ForcontrolContext).forct = instructions.NewSentenciaForCadena((func() int {
			if localctx.(*ForcontrolContext).Get_FOR() == nil {
				return 0
			} else {
				return localctx.(*ForcontrolContext).Get_FOR().GetLine()
			}
		}()), (func() int {
			if localctx.(*ForcontrolContext).Get_FOR() == nil {
				return 0
			} else {
				return localctx.(*ForcontrolContext).Get_FOR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*ForcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*ForcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*ForcontrolContext).Get_expr().GetE(), localctx.(*ForcontrolContext).Get_blockinterno().GetBlkint())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGuardcontrolContext is an interface to support dynamic dispatch.
type IGuardcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_GUARD returns the _GUARD token.
	Get_GUARD() antlr.Token

	// Set_GUARD sets the _GUARD token.
	Set_GUARD(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// GetGuct returns the guct attribute.
	GetGuct() interfaces.Instruction

	// SetGuct sets the guct attribute.
	SetGuct(interfaces.Instruction)

	// Getter signatures
	GUARD() antlr.TerminalNode
	Expr() IExprContext
	ELSE() antlr.TerminalNode
	LLAVEIZQ() antlr.TerminalNode
	Blockinterno() IBlockinternoContext
	LLAVEDER() antlr.TerminalNode

	// IsGuardcontrolContext differentiates from other interfaces.
	IsGuardcontrolContext()
}

type GuardcontrolContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	guct          interfaces.Instruction
	_GUARD        antlr.Token
	_expr         IExprContext
	_blockinterno IBlockinternoContext
}

func NewEmptyGuardcontrolContext() *GuardcontrolContext {
	var p = new(GuardcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_guardcontrol
	return p
}

func InitEmptyGuardcontrolContext(p *GuardcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_guardcontrol
}

func (*GuardcontrolContext) IsGuardcontrolContext() {}

func NewGuardcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GuardcontrolContext {
	var p = new(GuardcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_guardcontrol

	return p
}

func (s *GuardcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *GuardcontrolContext) Get_GUARD() antlr.Token { return s._GUARD }

func (s *GuardcontrolContext) Set_GUARD(v antlr.Token) { s._GUARD = v }

func (s *GuardcontrolContext) Get_expr() IExprContext { return s._expr }

func (s *GuardcontrolContext) Get_blockinterno() IBlockinternoContext { return s._blockinterno }

func (s *GuardcontrolContext) Set_expr(v IExprContext) { s._expr = v }

func (s *GuardcontrolContext) Set_blockinterno(v IBlockinternoContext) { s._blockinterno = v }

func (s *GuardcontrolContext) GetGuct() interfaces.Instruction { return s.guct }

func (s *GuardcontrolContext) SetGuct(v interfaces.Instruction) { s.guct = v }

func (s *GuardcontrolContext) GUARD() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserGUARD, 0)
}

func (s *GuardcontrolContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GuardcontrolContext) ELSE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserELSE, 0)
}

func (s *GuardcontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *GuardcontrolContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *GuardcontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *GuardcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GuardcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GuardcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterGuardcontrol(s)
	}
}

func (s *GuardcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitGuardcontrol(s)
	}
}

func (p *SwiftGrammarParser) Guardcontrol() (localctx IGuardcontrolContext) {
	localctx = NewGuardcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, SwiftGrammarParserRULE_guardcontrol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)

		var _m = p.Match(SwiftGrammarParserGUARD)

		localctx.(*GuardcontrolContext)._GUARD = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(512)

		var _x = p.expr(0)

		localctx.(*GuardcontrolContext)._expr = _x
	}
	{
		p.SetState(513)
		p.Match(SwiftGrammarParserELSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(514)
		p.Match(SwiftGrammarParserLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(515)

		var _x = p.Blockinterno()

		localctx.(*GuardcontrolContext)._blockinterno = _x
	}
	{
		p.SetState(516)
		p.Match(SwiftGrammarParserLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*GuardcontrolContext).guct = instructions.NewSentenciaGuard((func() int {
		if localctx.(*GuardcontrolContext).Get_GUARD() == nil {
			return 0
		} else {
			return localctx.(*GuardcontrolContext).Get_GUARD().GetLine()
		}
	}()), (func() int {
		if localctx.(*GuardcontrolContext).Get_GUARD() == nil {
			return 0
		} else {
			return localctx.(*GuardcontrolContext).Get_GUARD().GetColumn()
		}
	}()), localctx.(*GuardcontrolContext).Get_expr().GetE(), localctx.(*GuardcontrolContext).Get_blockinterno().GetBlkint())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueeContext is an interface to support dynamic dispatch.
type IContinueeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CONTINUE returns the _CONTINUE token.
	Get_CONTINUE() antlr.Token

	// Set_CONTINUE sets the _CONTINUE token.
	Set_CONTINUE(antlr.Token)

	// GetCoct returns the coct attribute.
	GetCoct() interfaces.Instruction

	// SetCoct sets the coct attribute.
	SetCoct(interfaces.Instruction)

	// Getter signatures
	CONTINUE() antlr.TerminalNode

	// IsContinueeContext differentiates from other interfaces.
	IsContinueeContext()
}

type ContinueeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	coct      interfaces.Instruction
	_CONTINUE antlr.Token
}

func NewEmptyContinueeContext() *ContinueeContext {
	var p = new(ContinueeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_continuee
	return p
}

func InitEmptyContinueeContext(p *ContinueeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_continuee
}

func (*ContinueeContext) IsContinueeContext() {}

func NewContinueeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueeContext {
	var p = new(ContinueeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_continuee

	return p
}

func (s *ContinueeContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueeContext) Get_CONTINUE() antlr.Token { return s._CONTINUE }

func (s *ContinueeContext) Set_CONTINUE(v antlr.Token) { s._CONTINUE = v }

func (s *ContinueeContext) GetCoct() interfaces.Instruction { return s.coct }

func (s *ContinueeContext) SetCoct(v interfaces.Instruction) { s.coct = v }

func (s *ContinueeContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCONTINUE, 0)
}

func (s *ContinueeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterContinuee(s)
	}
}

func (s *ContinueeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitContinuee(s)
	}
}

func (p *SwiftGrammarParser) Continuee() (localctx IContinueeContext) {
	localctx = NewContinueeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, SwiftGrammarParserRULE_continuee)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(519)

		var _m = p.Match(SwiftGrammarParserCONTINUE)

		localctx.(*ContinueeContext)._CONTINUE = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*ContinueeContext).coct = instructions.NewTransferenciaContinue((func() int {
		if localctx.(*ContinueeContext).Get_CONTINUE() == nil {
			return 0
		} else {
			return localctx.(*ContinueeContext).Get_CONTINUE().GetLine()
		}
	}()), (func() int {
		if localctx.(*ContinueeContext).Get_CONTINUE() == nil {
			return 0
		} else {
			return localctx.(*ContinueeContext).Get_CONTINUE().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakkContext is an interface to support dynamic dispatch.
type IBreakkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_BREAK returns the _BREAK token.
	Get_BREAK() antlr.Token

	// Set_BREAK sets the _BREAK token.
	Set_BREAK(antlr.Token)

	// GetBrkct returns the brkct attribute.
	GetBrkct() interfaces.Instruction

	// SetBrkct sets the brkct attribute.
	SetBrkct(interfaces.Instruction)

	// Getter signatures
	BREAK() antlr.TerminalNode

	// IsBreakkContext differentiates from other interfaces.
	IsBreakkContext()
}

type BreakkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	brkct  interfaces.Instruction
	_BREAK antlr.Token
}

func NewEmptyBreakkContext() *BreakkContext {
	var p = new(BreakkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_breakk
	return p
}

func InitEmptyBreakkContext(p *BreakkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_breakk
}

func (*BreakkContext) IsBreakkContext() {}

func NewBreakkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakkContext {
	var p = new(BreakkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_breakk

	return p
}

func (s *BreakkContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakkContext) Get_BREAK() antlr.Token { return s._BREAK }

func (s *BreakkContext) Set_BREAK(v antlr.Token) { s._BREAK = v }

func (s *BreakkContext) GetBrkct() interfaces.Instruction { return s.brkct }

func (s *BreakkContext) SetBrkct(v interfaces.Instruction) { s.brkct = v }

func (s *BreakkContext) BREAK() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserBREAK, 0)
}

func (s *BreakkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBreakk(s)
	}
}

func (s *BreakkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBreakk(s)
	}
}

func (p *SwiftGrammarParser) Breakk() (localctx IBreakkContext) {
	localctx = NewBreakkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, SwiftGrammarParserRULE_breakk)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)

		var _m = p.Match(SwiftGrammarParserBREAK)

		localctx.(*BreakkContext)._BREAK = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*BreakkContext).brkct = instructions.NewTransferenciaBreak((func() int {
		if localctx.(*BreakkContext).Get_BREAK() == nil {
			return 0
		} else {
			return localctx.(*BreakkContext).Get_BREAK().GetLine()
		}
	}()), (func() int {
		if localctx.(*BreakkContext).Get_BREAK() == nil {
			return 0
		} else {
			return localctx.(*BreakkContext).Get_BREAK().GetColumn()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetornosContext is an interface to support dynamic dispatch.
type IRetornosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_RETURN returns the _RETURN token.
	Get_RETURN() antlr.Token

	// Set_RETURN sets the _RETURN token.
	Set_RETURN(antlr.Token)

	// GetOp returns the op rule contexts.
	GetOp() IExprContext

	// SetOp sets the op rule contexts.
	SetOp(IExprContext)

	// GetRect returns the rect attribute.
	GetRect() interfaces.Instruction

	// SetRect sets the rect attribute.
	SetRect(interfaces.Instruction)

	// Getter signatures
	RETURN() antlr.TerminalNode
	Expr() IExprContext

	// IsRetornosContext differentiates from other interfaces.
	IsRetornosContext()
}

type RetornosContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	rect    interfaces.Instruction
	_RETURN antlr.Token
	op      IExprContext
}

func NewEmptyRetornosContext() *RetornosContext {
	var p = new(RetornosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_retornos
	return p
}

func InitEmptyRetornosContext(p *RetornosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_retornos
}

func (*RetornosContext) IsRetornosContext() {}

func NewRetornosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetornosContext {
	var p = new(RetornosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_retornos

	return p
}

func (s *RetornosContext) GetParser() antlr.Parser { return s.parser }

func (s *RetornosContext) Get_RETURN() antlr.Token { return s._RETURN }

func (s *RetornosContext) Set_RETURN(v antlr.Token) { s._RETURN = v }

func (s *RetornosContext) GetOp() IExprContext { return s.op }

func (s *RetornosContext) SetOp(v IExprContext) { s.op = v }

func (s *RetornosContext) GetRect() interfaces.Instruction { return s.rect }

func (s *RetornosContext) SetRect(v interfaces.Instruction) { s.rect = v }

func (s *RetornosContext) RETURN() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserRETURN, 0)
}

func (s *RetornosContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RetornosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetornosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetornosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterRetornos(s)
	}
}

func (s *RetornosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitRetornos(s)
	}
}

func (p *SwiftGrammarParser) Retornos() (localctx IRetornosContext) {
	localctx = NewRetornosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, SwiftGrammarParserRULE_retornos)
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(525)

			var _m = p.Match(SwiftGrammarParserRETURN)

			localctx.(*RetornosContext)._RETURN = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*RetornosContext).SetRect(instructions.NewTransferenciaReturn((func() int {
			if localctx.(*RetornosContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*RetornosContext).Get_RETURN().GetLine()
			}
		}()), (func() int {
			if localctx.(*RetornosContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*RetornosContext).Get_RETURN().GetColumn()
			}
		}())))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(527)

			var _m = p.Match(SwiftGrammarParserRETURN)

			localctx.(*RetornosContext)._RETURN = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(528)

			var _x = p.expr(0)

			localctx.(*RetornosContext).op = _x
		}

		localctx.(*RetornosContext).SetRect(instructions.NewTransferenciaReturnExp((func() int {
			if localctx.(*RetornosContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*RetornosContext).Get_RETURN().GetLine()
			}
		}()), (func() int {
			if localctx.(*RetornosContext).Get_RETURN() == nil {
				return 0
			} else {
				return localctx.(*RetornosContext).Get_RETURN().GetColumn()
			}
		}()), localctx.(*RetornosContext).GetOp().GetE()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorcontrolContext is an interface to support dynamic dispatch.
type IVectorcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_VAR returns the _VAR token.
	Get_VAR() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// GetPrin returns the prin token.
	GetPrin() antlr.Token

	// GetSecu returns the secu token.
	GetSecu() antlr.Token

	// Set_VAR sets the _VAR token.
	Set_VAR(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// SetPrin sets the prin token.
	SetPrin(antlr.Token)

	// SetSecu sets the secu token.
	SetSecu(antlr.Token)

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// Get_blockparams returns the _blockparams rule contexts.
	Get_blockparams() IBlockparamsContext

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// Set_blockparams sets the _blockparams rule contexts.
	Set_blockparams(IBlockparamsContext)

	// GetVect returns the vect attribute.
	GetVect() interfaces.Instruction

	// SetVect sets the vect attribute.
	SetVect(interfaces.Instruction)

	// Getter signatures
	VAR() antlr.TerminalNode
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	AllCORCHIZQ() []antlr.TerminalNode
	CORCHIZQ(i int) antlr.TerminalNode
	Tipodato() ITipodatoContext
	AllCORCHDER() []antlr.TerminalNode
	CORCHDER(i int) antlr.TerminalNode
	IG() antlr.TerminalNode
	Blockparams() IBlockparamsContext

	// IsVectorcontrolContext differentiates from other interfaces.
	IsVectorcontrolContext()
}

type VectorcontrolContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	vect         interfaces.Instruction
	_VAR         antlr.Token
	_ID_VALIDO   antlr.Token
	_tipodato    ITipodatoContext
	_blockparams IBlockparamsContext
	prin         antlr.Token
	secu         antlr.Token
}

func NewEmptyVectorcontrolContext() *VectorcontrolContext {
	var p = new(VectorcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorcontrol
	return p
}

func InitEmptyVectorcontrolContext(p *VectorcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorcontrol
}

func (*VectorcontrolContext) IsVectorcontrolContext() {}

func NewVectorcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorcontrolContext {
	var p = new(VectorcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectorcontrol

	return p
}

func (s *VectorcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorcontrolContext) Get_VAR() antlr.Token { return s._VAR }

func (s *VectorcontrolContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectorcontrolContext) GetPrin() antlr.Token { return s.prin }

func (s *VectorcontrolContext) GetSecu() antlr.Token { return s.secu }

func (s *VectorcontrolContext) Set_VAR(v antlr.Token) { s._VAR = v }

func (s *VectorcontrolContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectorcontrolContext) SetPrin(v antlr.Token) { s.prin = v }

func (s *VectorcontrolContext) SetSecu(v antlr.Token) { s.secu = v }

func (s *VectorcontrolContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *VectorcontrolContext) Get_blockparams() IBlockparamsContext { return s._blockparams }

func (s *VectorcontrolContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *VectorcontrolContext) Set_blockparams(v IBlockparamsContext) { s._blockparams = v }

func (s *VectorcontrolContext) GetVect() interfaces.Instruction { return s.vect }

func (s *VectorcontrolContext) SetVect(v interfaces.Instruction) { s.vect = v }

func (s *VectorcontrolContext) VAR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserVAR, 0)
}

func (s *VectorcontrolContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *VectorcontrolContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *VectorcontrolContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *VectorcontrolContext) AllCORCHIZQ() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHIZQ)
}

func (s *VectorcontrolContext) CORCHIZQ(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, i)
}

func (s *VectorcontrolContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *VectorcontrolContext) AllCORCHDER() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHDER)
}

func (s *VectorcontrolContext) CORCHDER(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, i)
}

func (s *VectorcontrolContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *VectorcontrolContext) Blockparams() IBlockparamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockparamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockparamsContext)
}

func (s *VectorcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectorcontrol(s)
	}
}

func (s *VectorcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectorcontrol(s)
	}
}

func (p *SwiftGrammarParser) Vectorcontrol() (localctx IVectorcontrolContext) {
	localctx = NewVectorcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, SwiftGrammarParserRULE_vectorcontrol)
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(533)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*VectorcontrolContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(534)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorcontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(535)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(536)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(537)

			var _x = p.Tipodato()

			localctx.(*VectorcontrolContext)._tipodato = _x
		}
		{
			p.SetState(538)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(539)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(540)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)

			var _x = p.Blockparams()

			localctx.(*VectorcontrolContext)._blockparams = _x
		}
		{
			p.SetState(542)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorcontrolContext).vect = instructions.NewArregloDeclaracionLista((func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectorcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectorcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectorcontrolContext).Get_tipodato().GetTipo(), localctx.(*VectorcontrolContext).Get_blockparams().GetBlkpar())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(545)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*VectorcontrolContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(546)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorcontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(547)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(548)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(549)

			var _x = p.Tipodato()

			localctx.(*VectorcontrolContext)._tipodato = _x
		}
		{
			p.SetState(550)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(551)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(552)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(553)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorcontrolContext).vect = instructions.NewArregloDeclaracionSinLista((func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectorcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectorcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectorcontrolContext).Get_tipodato().GetTipo())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(556)

			var _m = p.Match(SwiftGrammarParserVAR)

			localctx.(*VectorcontrolContext)._VAR = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(557)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorcontrolContext).prin = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(558)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(560)

			var _x = p.Tipodato()

			localctx.(*VectorcontrolContext)._tipodato = _x
		}
		{
			p.SetState(561)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(562)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(563)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorcontrolContext).secu = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorcontrolContext).vect = instructions.NewArregloDeclaracionId((func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectorcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*VectorcontrolContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectorcontrolContext).GetPrin() == nil {
				return ""
			} else {
				return localctx.(*VectorcontrolContext).GetPrin().GetText()
			}
		}()), localctx.(*VectorcontrolContext).Get_tipodato().GetTipo(), (func() string {
			if localctx.(*VectorcontrolContext).GetSecu() == nil {
				return ""
			} else {
				return localctx.(*VectorcontrolContext).GetSecu().GetText()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockparamsContext is an interface to support dynamic dispatch.
type IBlockparamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_bloqueparams returns the _bloqueparams rule contexts.
	Get_bloqueparams() IBloqueparamsContext

	// Set_bloqueparams sets the _bloqueparams rule contexts.
	Set_bloqueparams(IBloqueparamsContext)

	// GetBlopas returns the blopas rule context list.
	GetBlopas() []IBloqueparamsContext

	// SetBlopas sets the blopas rule context list.
	SetBlopas([]IBloqueparamsContext)

	// GetBlkpar returns the blkpar attribute.
	GetBlkpar() []interface{}

	// SetBlkpar sets the blkpar attribute.
	SetBlkpar([]interface{})

	// Getter signatures
	AllBloqueparams() []IBloqueparamsContext
	Bloqueparams(i int) IBloqueparamsContext

	// IsBlockparamsContext differentiates from other interfaces.
	IsBlockparamsContext()
}

type BlockparamsContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	blkpar        []interface{}
	_bloqueparams IBloqueparamsContext
	blopas        []IBloqueparamsContext
}

func NewEmptyBlockparamsContext() *BlockparamsContext {
	var p = new(BlockparamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockparams
	return p
}

func InitEmptyBlockparamsContext(p *BlockparamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_blockparams
}

func (*BlockparamsContext) IsBlockparamsContext() {}

func NewBlockparamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockparamsContext {
	var p = new(BlockparamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_blockparams

	return p
}

func (s *BlockparamsContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockparamsContext) Get_bloqueparams() IBloqueparamsContext { return s._bloqueparams }

func (s *BlockparamsContext) Set_bloqueparams(v IBloqueparamsContext) { s._bloqueparams = v }

func (s *BlockparamsContext) GetBlopas() []IBloqueparamsContext { return s.blopas }

func (s *BlockparamsContext) SetBlopas(v []IBloqueparamsContext) { s.blopas = v }

func (s *BlockparamsContext) GetBlkpar() []interface{} { return s.blkpar }

func (s *BlockparamsContext) SetBlkpar(v []interface{}) { s.blkpar = v }

func (s *BlockparamsContext) AllBloqueparams() []IBloqueparamsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBloqueparamsContext); ok {
			len++
		}
	}

	tst := make([]IBloqueparamsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBloqueparamsContext); ok {
			tst[i] = t.(IBloqueparamsContext)
			i++
		}
	}

	return tst
}

func (s *BlockparamsContext) Bloqueparams(i int) IBloqueparamsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBloqueparamsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBloqueparamsContext)
}

func (s *BlockparamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockparamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockparamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBlockparams(s)
	}
}

func (s *BlockparamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBlockparams(s)
	}
}

func (p *SwiftGrammarParser) Blockparams() (localctx IBlockparamsContext) {
	localctx = NewBlockparamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, SwiftGrammarParserRULE_blockparams)

	localctx.(*BlockparamsContext).blkpar = []interface{}{}
	var listInt []IBloqueparamsContext

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2307041339449017550) != 0) || _la == SwiftGrammarParserCOMA {
		{
			p.SetState(568)

			var _x = p.Bloqueparams()

			localctx.(*BlockparamsContext)._bloqueparams = _x
		}
		localctx.(*BlockparamsContext).blopas = append(localctx.(*BlockparamsContext).blopas, localctx.(*BlockparamsContext)._bloqueparams)

		p.SetState(571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt = localctx.(*BlockparamsContext).GetBlopas()
	for _, e := range listInt {
		localctx.(*BlockparamsContext).blkpar = append(localctx.(*BlockparamsContext).blkpar, e.GetBlopas())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBloqueparamsContext is an interface to support dynamic dispatch.
type IBloqueparamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_COMA returns the _COMA token.
	Get_COMA() antlr.Token

	// Set_COMA sets the _COMA token.
	Set_COMA(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetBlopas returns the blopas attribute.
	GetBlopas() interfaces.Expression

	// SetBlopas sets the blopas attribute.
	SetBlopas(interfaces.Expression)

	// Getter signatures
	COMA() antlr.TerminalNode
	Expr() IExprContext

	// IsBloqueparamsContext differentiates from other interfaces.
	IsBloqueparamsContext()
}

type BloqueparamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	blopas interfaces.Expression
	_COMA  antlr.Token
	_expr  IExprContext
}

func NewEmptyBloqueparamsContext() *BloqueparamsContext {
	var p = new(BloqueparamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_bloqueparams
	return p
}

func InitEmptyBloqueparamsContext(p *BloqueparamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_bloqueparams
}

func (*BloqueparamsContext) IsBloqueparamsContext() {}

func NewBloqueparamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BloqueparamsContext {
	var p = new(BloqueparamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_bloqueparams

	return p
}

func (s *BloqueparamsContext) GetParser() antlr.Parser { return s.parser }

func (s *BloqueparamsContext) Get_COMA() antlr.Token { return s._COMA }

func (s *BloqueparamsContext) Set_COMA(v antlr.Token) { s._COMA = v }

func (s *BloqueparamsContext) Get_expr() IExprContext { return s._expr }

func (s *BloqueparamsContext) Set_expr(v IExprContext) { s._expr = v }

func (s *BloqueparamsContext) GetBlopas() interfaces.Expression { return s.blopas }

func (s *BloqueparamsContext) SetBlopas(v interfaces.Expression) { s.blopas = v }

func (s *BloqueparamsContext) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *BloqueparamsContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *BloqueparamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BloqueparamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BloqueparamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterBloqueparams(s)
	}
}

func (s *BloqueparamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitBloqueparams(s)
	}
}

func (p *SwiftGrammarParser) Bloqueparams() (localctx IBloqueparamsContext) {
	localctx = NewBloqueparamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, SwiftGrammarParserRULE_bloqueparams)
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SwiftGrammarParserCOMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(575)

			var _m = p.Match(SwiftGrammarParserCOMA)

			localctx.(*BloqueparamsContext)._COMA = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(576)

			var _x = p.expr(0)

			localctx.(*BloqueparamsContext)._expr = _x
		}

		localctx.(*BloqueparamsContext).blopas = instructions.NewArregloParametros((func() int {
			if localctx.(*BloqueparamsContext).Get_COMA() == nil {
				return 0
			} else {
				return localctx.(*BloqueparamsContext).Get_COMA().GetLine()
			}
		}()), (func() int {
			if localctx.(*BloqueparamsContext).Get_COMA() == nil {
				return 0
			} else {
				return localctx.(*BloqueparamsContext).Get_COMA().GetColumn()
			}
		}()), localctx.(*BloqueparamsContext).Get_expr().GetE())

	case SwiftGrammarParserT__0, SwiftGrammarParserFLOAT, SwiftGrammarParserSTRING, SwiftGrammarParserTRU, SwiftGrammarParserFAL, SwiftGrammarParserNULO, SwiftGrammarParserNUMBER, SwiftGrammarParserCADENA, SwiftGrammarParserID_VALIDO, SwiftGrammarParserCHARACTER, SwiftGrammarParserPARIZQ, SwiftGrammarParserNOT, SwiftGrammarParserSUB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(579)

			var _x = p.expr(0)

			localctx.(*BloqueparamsContext)._expr = _x
		}

		localctx.(*BloqueparamsContext).blopas = instructions.NewArregloParametro(localctx.(*BloqueparamsContext).Get_expr().GetE())

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectoragregarContext is an interface to support dynamic dispatch.
type IVectoragregarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// GetPrin returns the prin token.
	GetPrin() antlr.Token

	// GetSecu returns the secu token.
	GetSecu() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// SetPrin sets the prin token.
	SetPrin(antlr.Token)

	// SetSecu sets the secu token.
	SetSecu(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// GetPop returns the pop rule contexts.
	GetPop() IExprContext

	// GetSop returns the sop rule contexts.
	GetSop() IExprContext

	// GetOp1 returns the op1 rule contexts.
	GetOp1() IExprContext

	// GetOp2 returns the op2 rule contexts.
	GetOp2() IExprContext

	// Get_listamatrizaddsubs returns the _listamatrizaddsubs rule contexts.
	Get_listamatrizaddsubs() IListamatrizaddsubsContext

	// GetOp3 returns the op3 rule contexts.
	GetOp3() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// SetPop sets the pop rule contexts.
	SetPop(IExprContext)

	// SetSop sets the sop rule contexts.
	SetSop(IExprContext)

	// SetOp1 sets the op1 rule contexts.
	SetOp1(IExprContext)

	// SetOp2 sets the op2 rule contexts.
	SetOp2(IExprContext)

	// Set_listamatrizaddsubs sets the _listamatrizaddsubs rule contexts.
	Set_listamatrizaddsubs(IListamatrizaddsubsContext)

	// SetOp3 sets the op3 rule contexts.
	SetOp3(IExprContext)

	// GetVeadct returns the veadct attribute.
	GetVeadct() interfaces.Instruction

	// SetVeadct sets the veadct attribute.
	SetVeadct(interfaces.Instruction)

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	APPEND() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	PARDER() antlr.TerminalNode
	AllCORCHIZQ() []antlr.TerminalNode
	CORCHIZQ(i int) antlr.TerminalNode
	AllCORCHDER() []antlr.TerminalNode
	CORCHDER(i int) antlr.TerminalNode
	IG() antlr.TerminalNode
	Listamatrizaddsubs() IListamatrizaddsubsContext

	// IsVectoragregarContext differentiates from other interfaces.
	IsVectoragregarContext()
}

type VectoragregarContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	veadct              interfaces.Instruction
	_ID_VALIDO          antlr.Token
	_expr               IExprContext
	prin                antlr.Token
	pop                 IExprContext
	secu                antlr.Token
	sop                 IExprContext
	op1                 IExprContext
	op2                 IExprContext
	_listamatrizaddsubs IListamatrizaddsubsContext
	op3                 IExprContext
}

func NewEmptyVectoragregarContext() *VectoragregarContext {
	var p = new(VectoragregarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectoragregar
	return p
}

func InitEmptyVectoragregarContext(p *VectoragregarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectoragregar
}

func (*VectoragregarContext) IsVectoragregarContext() {}

func NewVectoragregarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectoragregarContext {
	var p = new(VectoragregarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectoragregar

	return p
}

func (s *VectoragregarContext) GetParser() antlr.Parser { return s.parser }

func (s *VectoragregarContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectoragregarContext) GetPrin() antlr.Token { return s.prin }

func (s *VectoragregarContext) GetSecu() antlr.Token { return s.secu }

func (s *VectoragregarContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectoragregarContext) SetPrin(v antlr.Token) { s.prin = v }

func (s *VectoragregarContext) SetSecu(v antlr.Token) { s.secu = v }

func (s *VectoragregarContext) Get_expr() IExprContext { return s._expr }

func (s *VectoragregarContext) GetPop() IExprContext { return s.pop }

func (s *VectoragregarContext) GetSop() IExprContext { return s.sop }

func (s *VectoragregarContext) GetOp1() IExprContext { return s.op1 }

func (s *VectoragregarContext) GetOp2() IExprContext { return s.op2 }

func (s *VectoragregarContext) Get_listamatrizaddsubs() IListamatrizaddsubsContext {
	return s._listamatrizaddsubs
}

func (s *VectoragregarContext) GetOp3() IExprContext { return s.op3 }

func (s *VectoragregarContext) Set_expr(v IExprContext) { s._expr = v }

func (s *VectoragregarContext) SetPop(v IExprContext) { s.pop = v }

func (s *VectoragregarContext) SetSop(v IExprContext) { s.sop = v }

func (s *VectoragregarContext) SetOp1(v IExprContext) { s.op1 = v }

func (s *VectoragregarContext) SetOp2(v IExprContext) { s.op2 = v }

func (s *VectoragregarContext) Set_listamatrizaddsubs(v IListamatrizaddsubsContext) {
	s._listamatrizaddsubs = v
}

func (s *VectoragregarContext) SetOp3(v IExprContext) { s.op3 = v }

func (s *VectoragregarContext) GetVeadct() interfaces.Instruction { return s.veadct }

func (s *VectoragregarContext) SetVeadct(v interfaces.Instruction) { s.veadct = v }

func (s *VectoragregarContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *VectoragregarContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *VectoragregarContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *VectoragregarContext) APPEND() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserAPPEND, 0)
}

func (s *VectoragregarContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *VectoragregarContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *VectoragregarContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VectoragregarContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *VectoragregarContext) AllCORCHIZQ() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHIZQ)
}

func (s *VectoragregarContext) CORCHIZQ(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, i)
}

func (s *VectoragregarContext) AllCORCHDER() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHDER)
}

func (s *VectoragregarContext) CORCHDER(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, i)
}

func (s *VectoragregarContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *VectoragregarContext) Listamatrizaddsubs() IListamatrizaddsubsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListamatrizaddsubsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListamatrizaddsubsContext)
}

func (s *VectoragregarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectoragregarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectoragregarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectoragregar(s)
	}
}

func (s *VectoragregarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectoragregar(s)
	}
}

func (p *SwiftGrammarParser) Vectoragregar() (localctx IVectoragregarContext) {
	localctx = NewVectoragregarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, SwiftGrammarParserRULE_vectoragregar)
	p.SetState(634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(585)
			p.Match(SwiftGrammarParserPUNTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(586)
			p.Match(SwiftGrammarParserAPPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(588)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext)._expr = _x
		}
		{
			p.SetState(589)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectoragregarContext).veadct = instructions.NewArregloAppend((func() string {
			if localctx.(*VectoragregarContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoragregarContext).Get_expr().GetE())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(592)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext).prin = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(594)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).pop = _x
		}
		{
			p.SetState(595)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(597)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext).secu = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(598)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(599)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).sop = _x
		}
		{
			p.SetState(600)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectoragregarContext).veadct = instructions.NewArregloAppendArreglo((func() string {
			if localctx.(*VectoragregarContext).GetPrin() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).GetPrin().GetText()
			}
		}()), localctx.(*VectoragregarContext).GetPop().GetE(), (func() string {
			if localctx.(*VectoragregarContext).GetSecu() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).GetSecu().GetText()
			}
		}()), localctx.(*VectoragregarContext).GetSop().GetE())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(603)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(604)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(605)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op1 = _x
		}
		{
			p.SetState(606)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(607)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(608)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op2 = _x
		}
		{
			p.SetState(609)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(610)

			var _x = p.Listamatrizaddsubs()

			localctx.(*VectoragregarContext)._listamatrizaddsubs = _x
		}
		{
			p.SetState(611)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(612)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op3 = _x
		}
		localctx.(*VectoragregarContext).veadct = instructions.NewMatrizAsignacionList((func() string {
			if localctx.(*VectoragregarContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoragregarContext).GetOp1().GetE(), localctx.(*VectoragregarContext).GetOp2().GetE(), localctx.(*VectoragregarContext).Get_listamatrizaddsubs().GetBlklimatas(), localctx.(*VectoragregarContext).GetOp3().GetE())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(615)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(616)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(617)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op1 = _x
		}
		{
			p.SetState(618)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(620)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op2 = _x
		}
		{
			p.SetState(621)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(622)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(623)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).op3 = _x
		}
		localctx.(*VectoragregarContext).veadct = instructions.NewMatrizAsignacion((func() string {
			if localctx.(*VectoragregarContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoragregarContext).GetOp1().GetE(), localctx.(*VectoragregarContext).GetOp2().GetE(), localctx.(*VectoragregarContext).GetOp3().GetE())

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(626)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoragregarContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(627)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(628)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).pop = _x
		}
		{
			p.SetState(629)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(630)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(631)

			var _x = p.expr(0)

			localctx.(*VectoragregarContext).sop = _x
		}
		localctx.(*VectoragregarContext).veadct = instructions.NewArregloAppendExp((func() string {
			if localctx.(*VectoragregarContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoragregarContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoragregarContext).GetPop().GetE(), localctx.(*VectoragregarContext).GetSop().GetE())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorremoverContext is an interface to support dynamic dispatch.
type IVectorremoverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_PUNTO returns the _PUNTO token.
	Get_PUNTO() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_PUNTO sets the _PUNTO token.
	Set_PUNTO(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetVermct returns the vermct attribute.
	GetVermct() interfaces.Instruction

	// SetVermct sets the vermct attribute.
	SetVermct(interfaces.Instruction)

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	REMOVELAST() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	AT() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	Expr() IExprContext

	// IsVectorremoverContext differentiates from other interfaces.
	IsVectorremoverContext()
}

type VectorremoverContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	vermct     interfaces.Instruction
	_ID_VALIDO antlr.Token
	_PUNTO     antlr.Token
	_expr      IExprContext
}

func NewEmptyVectorremoverContext() *VectorremoverContext {
	var p = new(VectorremoverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorremover
	return p
}

func InitEmptyVectorremoverContext(p *VectorremoverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorremover
}

func (*VectorremoverContext) IsVectorremoverContext() {}

func NewVectorremoverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorremoverContext {
	var p = new(VectorremoverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectorremover

	return p
}

func (s *VectorremoverContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorremoverContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectorremoverContext) Get_PUNTO() antlr.Token { return s._PUNTO }

func (s *VectorremoverContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectorremoverContext) Set_PUNTO(v antlr.Token) { s._PUNTO = v }

func (s *VectorremoverContext) Get_expr() IExprContext { return s._expr }

func (s *VectorremoverContext) Set_expr(v IExprContext) { s._expr = v }

func (s *VectorremoverContext) GetVermct() interfaces.Instruction { return s.vermct }

func (s *VectorremoverContext) SetVermct(v interfaces.Instruction) { s.vermct = v }

func (s *VectorremoverContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *VectorremoverContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *VectorremoverContext) REMOVELAST() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserREMOVELAST, 0)
}

func (s *VectorremoverContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *VectorremoverContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *VectorremoverContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserREMOVE, 0)
}

func (s *VectorremoverContext) AT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserAT, 0)
}

func (s *VectorremoverContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *VectorremoverContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VectorremoverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorremoverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorremoverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectorremover(s)
	}
}

func (s *VectorremoverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectorremover(s)
	}
}

func (p *SwiftGrammarParser) Vectorremover() (localctx IVectorremoverContext) {
	localctx = NewVectorremoverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, SwiftGrammarParserRULE_vectorremover)
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(636)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorremoverContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)

			var _m = p.Match(SwiftGrammarParserPUNTO)

			localctx.(*VectorremoverContext)._PUNTO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(638)
			p.Match(SwiftGrammarParserREMOVELAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorremoverContext).vermct = instructions.NewArregloRemoveLast((func() int {
			if localctx.(*VectorremoverContext).Get_PUNTO() == nil {
				return 0
			} else {
				return localctx.(*VectorremoverContext).Get_PUNTO().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectorremoverContext).Get_PUNTO() == nil {
				return 0
			} else {
				return localctx.(*VectorremoverContext).Get_PUNTO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectorremoverContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectorremoverContext).Get_ID_VALIDO().GetText()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(642)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectorremoverContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(643)

			var _m = p.Match(SwiftGrammarParserPUNTO)

			localctx.(*VectorremoverContext)._PUNTO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(644)
			p.Match(SwiftGrammarParserREMOVE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(645)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.Match(SwiftGrammarParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(647)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(648)

			var _x = p.expr(0)

			localctx.(*VectorremoverContext)._expr = _x
		}
		{
			p.SetState(649)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectorremoverContext).vermct = instructions.NewArregloRemovePos((func() int {
			if localctx.(*VectorremoverContext).Get_PUNTO() == nil {
				return 0
			} else {
				return localctx.(*VectorremoverContext).Get_PUNTO().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectorremoverContext).Get_PUNTO() == nil {
				return 0
			} else {
				return localctx.(*VectorremoverContext).Get_PUNTO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectorremoverContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectorremoverContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectorremoverContext).Get_expr().GetE())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorvacioContext is an interface to support dynamic dispatch.
type IVectorvacioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_PUNTO returns the _PUNTO token.
	Get_PUNTO() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_PUNTO sets the _PUNTO token.
	Set_PUNTO(antlr.Token)

	// GetVeemct returns the veemct attribute.
	GetVeemct() interfaces.Expression

	// SetVeemct sets the veemct attribute.
	SetVeemct(interfaces.Expression)

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	ISEMPTY() antlr.TerminalNode

	// IsVectorvacioContext differentiates from other interfaces.
	IsVectorvacioContext()
}

type VectorvacioContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	veemct     interfaces.Expression
	_ID_VALIDO antlr.Token
	_PUNTO     antlr.Token
}

func NewEmptyVectorvacioContext() *VectorvacioContext {
	var p = new(VectorvacioContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorvacio
	return p
}

func InitEmptyVectorvacioContext(p *VectorvacioContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorvacio
}

func (*VectorvacioContext) IsVectorvacioContext() {}

func NewVectorvacioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorvacioContext {
	var p = new(VectorvacioContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectorvacio

	return p
}

func (s *VectorvacioContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorvacioContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectorvacioContext) Get_PUNTO() antlr.Token { return s._PUNTO }

func (s *VectorvacioContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectorvacioContext) Set_PUNTO(v antlr.Token) { s._PUNTO = v }

func (s *VectorvacioContext) GetVeemct() interfaces.Expression { return s.veemct }

func (s *VectorvacioContext) SetVeemct(v interfaces.Expression) { s.veemct = v }

func (s *VectorvacioContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *VectorvacioContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *VectorvacioContext) ISEMPTY() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserISEMPTY, 0)
}

func (s *VectorvacioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorvacioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorvacioContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectorvacio(s)
	}
}

func (s *VectorvacioContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectorvacio(s)
	}
}

func (p *SwiftGrammarParser) Vectorvacio() (localctx IVectorvacioContext) {
	localctx = NewVectorvacioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, SwiftGrammarParserRULE_vectorvacio)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(654)

		var _m = p.Match(SwiftGrammarParserID_VALIDO)

		localctx.(*VectorvacioContext)._ID_VALIDO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)

		var _m = p.Match(SwiftGrammarParserPUNTO)

		localctx.(*VectorvacioContext)._PUNTO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(656)
		p.Match(SwiftGrammarParserISEMPTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*VectorvacioContext).veemct = instructions.NewArregloIsEmpty((func() int {
		if localctx.(*VectorvacioContext).Get_PUNTO() == nil {
			return 0
		} else {
			return localctx.(*VectorvacioContext).Get_PUNTO().GetLine()
		}
	}()), (func() int {
		if localctx.(*VectorvacioContext).Get_PUNTO() == nil {
			return 0
		} else {
			return localctx.(*VectorvacioContext).Get_PUNTO().GetColumn()
		}
	}()), (func() string {
		if localctx.(*VectorvacioContext).Get_ID_VALIDO() == nil {
			return ""
		} else {
			return localctx.(*VectorvacioContext).Get_ID_VALIDO().GetText()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectorcountContext is an interface to support dynamic dispatch.
type IVectorcountContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_PUNTO returns the _PUNTO token.
	Get_PUNTO() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_PUNTO sets the _PUNTO token.
	Set_PUNTO(antlr.Token)

	// GetVecnct returns the vecnct attribute.
	GetVecnct() interfaces.Expression

	// SetVecnct sets the vecnct attribute.
	SetVecnct(interfaces.Expression)

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	COUNT() antlr.TerminalNode

	// IsVectorcountContext differentiates from other interfaces.
	IsVectorcountContext()
}

type VectorcountContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	vecnct     interfaces.Expression
	_ID_VALIDO antlr.Token
	_PUNTO     antlr.Token
}

func NewEmptyVectorcountContext() *VectorcountContext {
	var p = new(VectorcountContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorcount
	return p
}

func InitEmptyVectorcountContext(p *VectorcountContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectorcount
}

func (*VectorcountContext) IsVectorcountContext() {}

func NewVectorcountContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectorcountContext {
	var p = new(VectorcountContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectorcount

	return p
}

func (s *VectorcountContext) GetParser() antlr.Parser { return s.parser }

func (s *VectorcountContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectorcountContext) Get_PUNTO() antlr.Token { return s._PUNTO }

func (s *VectorcountContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectorcountContext) Set_PUNTO(v antlr.Token) { s._PUNTO = v }

func (s *VectorcountContext) GetVecnct() interfaces.Expression { return s.vecnct }

func (s *VectorcountContext) SetVecnct(v interfaces.Expression) { s.vecnct = v }

func (s *VectorcountContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *VectorcountContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *VectorcountContext) COUNT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOUNT, 0)
}

func (s *VectorcountContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectorcountContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectorcountContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectorcount(s)
	}
}

func (s *VectorcountContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectorcount(s)
	}
}

func (p *SwiftGrammarParser) Vectorcount() (localctx IVectorcountContext) {
	localctx = NewVectorcountContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, SwiftGrammarParserRULE_vectorcount)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)

		var _m = p.Match(SwiftGrammarParserID_VALIDO)

		localctx.(*VectorcountContext)._ID_VALIDO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(660)

		var _m = p.Match(SwiftGrammarParserPUNTO)

		localctx.(*VectorcountContext)._PUNTO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(661)
		p.Match(SwiftGrammarParserCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*VectorcountContext).vecnct = instructions.NewArregloCount((func() int {
		if localctx.(*VectorcountContext).Get_PUNTO() == nil {
			return 0
		} else {
			return localctx.(*VectorcountContext).Get_PUNTO().GetLine()
		}
	}()), (func() int {
		if localctx.(*VectorcountContext).Get_PUNTO() == nil {
			return 0
		} else {
			return localctx.(*VectorcountContext).Get_PUNTO().GetColumn()
		}
	}()), (func() string {
		if localctx.(*VectorcountContext).Get_ID_VALIDO() == nil {
			return ""
		} else {
			return localctx.(*VectorcountContext).Get_ID_VALIDO().GetText()
		}
	}()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVectoraccessContext is an interface to support dynamic dispatch.
type IVectoraccessContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_CORCHDER returns the _CORCHDER token.
	Get_CORCHDER() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_CORCHDER sets the _CORCHDER token.
	Set_CORCHDER(antlr.Token)

	// GetOp1 returns the op1 rule contexts.
	GetOp1() IExprContext

	// GetOp2 returns the op2 rule contexts.
	GetOp2() IExprContext

	// Get_listamatrizaddsubs returns the _listamatrizaddsubs rule contexts.
	Get_listamatrizaddsubs() IListamatrizaddsubsContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// SetOp1 sets the op1 rule contexts.
	SetOp1(IExprContext)

	// SetOp2 sets the op2 rule contexts.
	SetOp2(IExprContext)

	// Set_listamatrizaddsubs sets the _listamatrizaddsubs rule contexts.
	Set_listamatrizaddsubs(IListamatrizaddsubsContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetVepposct returns the vepposct attribute.
	GetVepposct() interfaces.Expression

	// SetVepposct sets the vepposct attribute.
	SetVepposct(interfaces.Expression)

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	AllCORCHIZQ() []antlr.TerminalNode
	CORCHIZQ(i int) antlr.TerminalNode
	AllCORCHDER() []antlr.TerminalNode
	CORCHDER(i int) antlr.TerminalNode
	Listamatrizaddsubs() IListamatrizaddsubsContext
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsVectoraccessContext differentiates from other interfaces.
	IsVectoraccessContext()
}

type VectoraccessContext struct {
	antlr.BaseParserRuleContext
	parser              antlr.Parser
	vepposct            interfaces.Expression
	_ID_VALIDO          antlr.Token
	op1                 IExprContext
	op2                 IExprContext
	_listamatrizaddsubs IListamatrizaddsubsContext
	_expr               IExprContext
	_CORCHDER           antlr.Token
}

func NewEmptyVectoraccessContext() *VectoraccessContext {
	var p = new(VectoraccessContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectoraccess
	return p
}

func InitEmptyVectoraccessContext(p *VectoraccessContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_vectoraccess
}

func (*VectoraccessContext) IsVectoraccessContext() {}

func NewVectoraccessContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VectoraccessContext {
	var p = new(VectoraccessContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_vectoraccess

	return p
}

func (s *VectoraccessContext) GetParser() antlr.Parser { return s.parser }

func (s *VectoraccessContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *VectoraccessContext) Get_CORCHDER() antlr.Token { return s._CORCHDER }

func (s *VectoraccessContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *VectoraccessContext) Set_CORCHDER(v antlr.Token) { s._CORCHDER = v }

func (s *VectoraccessContext) GetOp1() IExprContext { return s.op1 }

func (s *VectoraccessContext) GetOp2() IExprContext { return s.op2 }

func (s *VectoraccessContext) Get_listamatrizaddsubs() IListamatrizaddsubsContext {
	return s._listamatrizaddsubs
}

func (s *VectoraccessContext) Get_expr() IExprContext { return s._expr }

func (s *VectoraccessContext) SetOp1(v IExprContext) { s.op1 = v }

func (s *VectoraccessContext) SetOp2(v IExprContext) { s.op2 = v }

func (s *VectoraccessContext) Set_listamatrizaddsubs(v IListamatrizaddsubsContext) {
	s._listamatrizaddsubs = v
}

func (s *VectoraccessContext) Set_expr(v IExprContext) { s._expr = v }

func (s *VectoraccessContext) GetVepposct() interfaces.Expression { return s.vepposct }

func (s *VectoraccessContext) SetVepposct(v interfaces.Expression) { s.vepposct = v }

func (s *VectoraccessContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *VectoraccessContext) AllCORCHIZQ() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHIZQ)
}

func (s *VectoraccessContext) CORCHIZQ(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, i)
}

func (s *VectoraccessContext) AllCORCHDER() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserCORCHDER)
}

func (s *VectoraccessContext) CORCHDER(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, i)
}

func (s *VectoraccessContext) Listamatrizaddsubs() IListamatrizaddsubsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListamatrizaddsubsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListamatrizaddsubsContext)
}

func (s *VectoraccessContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *VectoraccessContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VectoraccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VectoraccessContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VectoraccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterVectoraccess(s)
	}
}

func (s *VectoraccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitVectoraccess(s)
	}
}

func (p *SwiftGrammarParser) Vectoraccess() (localctx IVectoraccessContext) {
	localctx = NewVectoraccessContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, SwiftGrammarParserRULE_vectoraccess)
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(664)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoraccessContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(665)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(666)

			var _x = p.expr(0)

			localctx.(*VectoraccessContext).op1 = _x
		}
		{
			p.SetState(667)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(668)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(669)

			var _x = p.expr(0)

			localctx.(*VectoraccessContext).op2 = _x
		}
		{
			p.SetState(670)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(671)

			var _x = p.Listamatrizaddsubs()

			localctx.(*VectoraccessContext)._listamatrizaddsubs = _x
		}
		localctx.(*VectoraccessContext).vepposct = instructions.NewMatrizObtencionList((func() string {
			if localctx.(*VectoraccessContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoraccessContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoraccessContext).GetOp1().GetE(), localctx.(*VectoraccessContext).GetOp2().GetE(), localctx.(*VectoraccessContext).Get_listamatrizaddsubs().GetBlklimatas())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoraccessContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(675)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(676)

			var _x = p.expr(0)

			localctx.(*VectoraccessContext).op1 = _x
		}
		{
			p.SetState(677)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(678)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(679)

			var _x = p.expr(0)

			localctx.(*VectoraccessContext).op2 = _x
		}
		{
			p.SetState(680)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectoraccessContext).vepposct = instructions.NewMatrizObtencion((func() string {
			if localctx.(*VectoraccessContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoraccessContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoraccessContext).GetOp1().GetE(), localctx.(*VectoraccessContext).GetOp2().GetE())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(683)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*VectoraccessContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(685)

			var _x = p.expr(0)

			localctx.(*VectoraccessContext)._expr = _x
		}
		{
			p.SetState(686)

			var _m = p.Match(SwiftGrammarParserCORCHDER)

			localctx.(*VectoraccessContext)._CORCHDER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*VectoraccessContext).vepposct = instructions.NewArregloAccess((func() int {
			if localctx.(*VectoraccessContext).Get_CORCHDER() == nil {
				return 0
			} else {
				return localctx.(*VectoraccessContext).Get_CORCHDER().GetLine()
			}
		}()), (func() int {
			if localctx.(*VectoraccessContext).Get_CORCHDER() == nil {
				return 0
			} else {
				return localctx.(*VectoraccessContext).Get_CORCHDER().GetColumn()
			}
		}()), (func() string {
			if localctx.(*VectoraccessContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*VectoraccessContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*VectoraccessContext).Get_expr().GetE())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMatrizcontrolContext is an interface to support dynamic dispatch.
type IMatrizcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_VAR returns the _VAR token.
	Get_VAR() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_DOS_PUNTOS returns the _DOS_PUNTOS token.
	Get_DOS_PUNTOS() antlr.Token

	// Set_VAR sets the _VAR token.
	Set_VAR(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_DOS_PUNTOS sets the _DOS_PUNTOS token.
	Set_DOS_PUNTOS(antlr.Token)

	// Get_tipomatriz returns the _tipomatriz rule contexts.
	Get_tipomatriz() ITipomatrizContext

	// Get_defmatriz returns the _defmatriz rule contexts.
	Get_defmatriz() IDefmatrizContext

	// Set_tipomatriz sets the _tipomatriz rule contexts.
	Set_tipomatriz(ITipomatrizContext)

	// Set_defmatriz sets the _defmatriz rule contexts.
	Set_defmatriz(IDefmatrizContext)

	// GetMatct returns the matct attribute.
	GetMatct() interfaces.Instruction

	// SetMatct sets the matct attribute.
	SetMatct(interfaces.Instruction)

	// Getter signatures
	VAR() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	IG() antlr.TerminalNode
	Defmatriz() IDefmatrizContext
	DOS_PUNTOS() antlr.TerminalNode
	Tipomatriz() ITipomatrizContext

	// IsMatrizcontrolContext differentiates from other interfaces.
	IsMatrizcontrolContext()
}

type MatrizcontrolContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	matct       interfaces.Instruction
	_VAR        antlr.Token
	_ID_VALIDO  antlr.Token
	_DOS_PUNTOS antlr.Token
	_tipomatriz ITipomatrizContext
	_defmatriz  IDefmatrizContext
}

func NewEmptyMatrizcontrolContext() *MatrizcontrolContext {
	var p = new(MatrizcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_matrizcontrol
	return p
}

func InitEmptyMatrizcontrolContext(p *MatrizcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_matrizcontrol
}

func (*MatrizcontrolContext) IsMatrizcontrolContext() {}

func NewMatrizcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MatrizcontrolContext {
	var p = new(MatrizcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_matrizcontrol

	return p
}

func (s *MatrizcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *MatrizcontrolContext) Get_VAR() antlr.Token { return s._VAR }

func (s *MatrizcontrolContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *MatrizcontrolContext) Get_DOS_PUNTOS() antlr.Token { return s._DOS_PUNTOS }

func (s *MatrizcontrolContext) Set_VAR(v antlr.Token) { s._VAR = v }

func (s *MatrizcontrolContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *MatrizcontrolContext) Set_DOS_PUNTOS(v antlr.Token) { s._DOS_PUNTOS = v }

func (s *MatrizcontrolContext) Get_tipomatriz() ITipomatrizContext { return s._tipomatriz }

func (s *MatrizcontrolContext) Get_defmatriz() IDefmatrizContext { return s._defmatriz }

func (s *MatrizcontrolContext) Set_tipomatriz(v ITipomatrizContext) { s._tipomatriz = v }

func (s *MatrizcontrolContext) Set_defmatriz(v IDefmatrizContext) { s._defmatriz = v }

func (s *MatrizcontrolContext) GetMatct() interfaces.Instruction { return s.matct }

func (s *MatrizcontrolContext) SetMatct(v interfaces.Instruction) { s.matct = v }

func (s *MatrizcontrolContext) VAR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserVAR, 0)
}

func (s *MatrizcontrolContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *MatrizcontrolContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *MatrizcontrolContext) Defmatriz() IDefmatrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefmatrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefmatrizContext)
}

func (s *MatrizcontrolContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *MatrizcontrolContext) Tipomatriz() ITipomatrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipomatrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipomatrizContext)
}

func (s *MatrizcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatrizcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MatrizcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterMatrizcontrol(s)
	}
}

func (s *MatrizcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitMatrizcontrol(s)
	}
}

func (p *SwiftGrammarParser) Matrizcontrol() (localctx IMatrizcontrolContext) {
	localctx = NewMatrizcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, SwiftGrammarParserRULE_matrizcontrol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)

		var _m = p.Match(SwiftGrammarParserVAR)

		localctx.(*MatrizcontrolContext)._VAR = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(692)

		var _m = p.Match(SwiftGrammarParserID_VALIDO)

		localctx.(*MatrizcontrolContext)._ID_VALIDO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == SwiftGrammarParserDOS_PUNTOS {
		{
			p.SetState(693)

			var _m = p.Match(SwiftGrammarParserDOS_PUNTOS)

			localctx.(*MatrizcontrolContext)._DOS_PUNTOS = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)

			var _x = p.Tipomatriz()

			localctx.(*MatrizcontrolContext)._tipomatriz = _x
		}

	}
	{
		p.SetState(697)
		p.Match(SwiftGrammarParserIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)

		var _x = p.Defmatriz()

		localctx.(*MatrizcontrolContext)._defmatriz = _x
	}

	if localctx.(*MatrizcontrolContext).Get_DOS_PUNTOS() != nil {
		localctx.(*MatrizcontrolContext).matct = instructions.NewMatrizDeclaracion((func() int {
			if localctx.(*MatrizcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*MatrizcontrolContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*MatrizcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*MatrizcontrolContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*MatrizcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*MatrizcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*MatrizcontrolContext).Get_tipomatriz().GetTipomat(), localctx.(*MatrizcontrolContext).Get_defmatriz().GetDefmat())
	} else {
		localctx.(*MatrizcontrolContext).matct = instructions.NewMatrizDeclaracionSinTipo((func() int {
			if localctx.(*MatrizcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*MatrizcontrolContext).Get_VAR().GetLine()
			}
		}()), (func() int {
			if localctx.(*MatrizcontrolContext).Get_VAR() == nil {
				return 0
			} else {
				return localctx.(*MatrizcontrolContext).Get_VAR().GetColumn()
			}
		}()), (func() string {
			if localctx.(*MatrizcontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*MatrizcontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*MatrizcontrolContext).Get_defmatriz().GetDefmat())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITipomatrizContext is an interface to support dynamic dispatch.
type ITipomatrizContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CORCHIZQ returns the _CORCHIZQ token.
	Get_CORCHIZQ() antlr.Token

	// Set_CORCHIZQ sets the _CORCHIZQ token.
	Set_CORCHIZQ(antlr.Token)

	// Get_tipomatriz returns the _tipomatriz rule contexts.
	Get_tipomatriz() ITipomatrizContext

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// Set_tipomatriz sets the _tipomatriz rule contexts.
	Set_tipomatriz(ITipomatrizContext)

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// GetTipomat returns the tipomat attribute.
	GetTipomat() interfaces.Expression

	// SetTipomat sets the tipomat attribute.
	SetTipomat(interfaces.Expression)

	// Getter signatures
	CORCHIZQ() antlr.TerminalNode
	Tipomatriz() ITipomatrizContext
	CORCHDER() antlr.TerminalNode
	Tipodato() ITipodatoContext

	// IsTipomatrizContext differentiates from other interfaces.
	IsTipomatrizContext()
}

type TipomatrizContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	tipomat     interfaces.Expression
	_CORCHIZQ   antlr.Token
	_tipomatriz ITipomatrizContext
	_tipodato   ITipodatoContext
}

func NewEmptyTipomatrizContext() *TipomatrizContext {
	var p = new(TipomatrizContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_tipomatriz
	return p
}

func InitEmptyTipomatrizContext(p *TipomatrizContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_tipomatriz
}

func (*TipomatrizContext) IsTipomatrizContext() {}

func NewTipomatrizContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TipomatrizContext {
	var p = new(TipomatrizContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_tipomatriz

	return p
}

func (s *TipomatrizContext) GetParser() antlr.Parser { return s.parser }

func (s *TipomatrizContext) Get_CORCHIZQ() antlr.Token { return s._CORCHIZQ }

func (s *TipomatrizContext) Set_CORCHIZQ(v antlr.Token) { s._CORCHIZQ = v }

func (s *TipomatrizContext) Get_tipomatriz() ITipomatrizContext { return s._tipomatriz }

func (s *TipomatrizContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *TipomatrizContext) Set_tipomatriz(v ITipomatrizContext) { s._tipomatriz = v }

func (s *TipomatrizContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *TipomatrizContext) GetTipomat() interfaces.Expression { return s.tipomat }

func (s *TipomatrizContext) SetTipomat(v interfaces.Expression) { s.tipomat = v }

func (s *TipomatrizContext) CORCHIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, 0)
}

func (s *TipomatrizContext) Tipomatriz() ITipomatrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipomatrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipomatrizContext)
}

func (s *TipomatrizContext) CORCHDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, 0)
}

func (s *TipomatrizContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *TipomatrizContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TipomatrizContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TipomatrizContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterTipomatriz(s)
	}
}

func (s *TipomatrizContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitTipomatriz(s)
	}
}

func (p *SwiftGrammarParser) Tipomatriz() (localctx ITipomatrizContext) {
	localctx = NewTipomatrizContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, SwiftGrammarParserRULE_tipomatriz)
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(701)

			var _m = p.Match(SwiftGrammarParserCORCHIZQ)

			localctx.(*TipomatrizContext)._CORCHIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(702)

			var _x = p.Tipomatriz()

			localctx.(*TipomatrizContext)._tipomatriz = _x
		}
		{
			p.SetState(703)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*TipomatrizContext).tipomat = instructions.NewMatrizDimension((func() int {
			if localctx.(*TipomatrizContext).Get_CORCHIZQ() == nil {
				return 0
			} else {
				return localctx.(*TipomatrizContext).Get_CORCHIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*TipomatrizContext).Get_CORCHIZQ() == nil {
				return 0
			} else {
				return localctx.(*TipomatrizContext).Get_CORCHIZQ().GetColumn()
			}
		}()), localctx.(*TipomatrizContext).Get_tipomatriz().GetTipomat())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(706)

			var _m = p.Match(SwiftGrammarParserCORCHIZQ)

			localctx.(*TipomatrizContext)._CORCHIZQ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(707)

			var _x = p.Tipodato()

			localctx.(*TipomatrizContext)._tipodato = _x
		}
		{
			p.SetState(708)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*TipomatrizContext).tipomat = instructions.NewMatrizTipo((func() int {
			if localctx.(*TipomatrizContext).Get_CORCHIZQ() == nil {
				return 0
			} else {
				return localctx.(*TipomatrizContext).Get_CORCHIZQ().GetLine()
			}
		}()), (func() int {
			if localctx.(*TipomatrizContext).Get_CORCHIZQ() == nil {
				return 0
			} else {
				return localctx.(*TipomatrizContext).Get_CORCHIZQ().GetColumn()
			}
		}()), localctx.(*TipomatrizContext).Get_tipodato().GetTipo())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefmatrizContext is an interface to support dynamic dispatch.
type IDefmatrizContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listavaloresmat returns the _listavaloresmat rule contexts.
	Get_listavaloresmat() IListavaloresmatContext

	// Set_listavaloresmat sets the _listavaloresmat rule contexts.
	Set_listavaloresmat(IListavaloresmatContext)

	// GetDefmat returns the defmat attribute.
	GetDefmat() interfaces.Instruction

	// SetDefmat sets the defmat attribute.
	SetDefmat(interfaces.Instruction)

	// Getter signatures
	Listavaloresmat() IListavaloresmatContext

	// IsDefmatrizContext differentiates from other interfaces.
	IsDefmatrizContext()
}

type DefmatrizContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	defmat           interfaces.Instruction
	_listavaloresmat IListavaloresmatContext
}

func NewEmptyDefmatrizContext() *DefmatrizContext {
	var p = new(DefmatrizContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_defmatriz
	return p
}

func InitEmptyDefmatrizContext(p *DefmatrizContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_defmatriz
}

func (*DefmatrizContext) IsDefmatrizContext() {}

func NewDefmatrizContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefmatrizContext {
	var p = new(DefmatrizContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_defmatriz

	return p
}

func (s *DefmatrizContext) GetParser() antlr.Parser { return s.parser }

func (s *DefmatrizContext) Get_listavaloresmat() IListavaloresmatContext { return s._listavaloresmat }

func (s *DefmatrizContext) Set_listavaloresmat(v IListavaloresmatContext) { s._listavaloresmat = v }

func (s *DefmatrizContext) GetDefmat() interfaces.Instruction { return s.defmat }

func (s *DefmatrizContext) SetDefmat(v interfaces.Instruction) { s.defmat = v }

func (s *DefmatrizContext) Listavaloresmat() IListavaloresmatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListavaloresmatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListavaloresmatContext)
}

func (s *DefmatrizContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefmatrizContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefmatrizContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterDefmatriz(s)
	}
}

func (s *DefmatrizContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitDefmatriz(s)
	}
}

func (p *SwiftGrammarParser) Defmatriz() (localctx IDefmatrizContext) {
	localctx = NewDefmatrizContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, SwiftGrammarParserRULE_defmatriz)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)

		var _x = p.Listavaloresmat()

		localctx.(*DefmatrizContext)._listavaloresmat = _x
	}
	localctx.(*DefmatrizContext).defmat = localctx.(*DefmatrizContext).Get_listavaloresmat().GetListvlamat()

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListavaloresmatContext is an interface to support dynamic dispatch.
type IListavaloresmatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listavaloresmat2 returns the _listavaloresmat2 rule contexts.
	Get_listavaloresmat2() IListavaloresmat2Context

	// Get_simplematriz returns the _simplematriz rule contexts.
	Get_simplematriz() ISimplematrizContext

	// Set_listavaloresmat2 sets the _listavaloresmat2 rule contexts.
	Set_listavaloresmat2(IListavaloresmat2Context)

	// Set_simplematriz sets the _simplematriz rule contexts.
	Set_simplematriz(ISimplematrizContext)

	// GetListvlamat returns the listvlamat attribute.
	GetListvlamat() interfaces.Instruction

	// SetListvlamat sets the listvlamat attribute.
	SetListvlamat(interfaces.Instruction)

	// Getter signatures
	CORCHIZQ() antlr.TerminalNode
	Listavaloresmat2() IListavaloresmat2Context
	CORCHDER() antlr.TerminalNode
	Simplematriz() ISimplematrizContext

	// IsListavaloresmatContext differentiates from other interfaces.
	IsListavaloresmatContext()
}

type ListavaloresmatContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	listvlamat        interfaces.Instruction
	_listavaloresmat2 IListavaloresmat2Context
	_simplematriz     ISimplematrizContext
}

func NewEmptyListavaloresmatContext() *ListavaloresmatContext {
	var p = new(ListavaloresmatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat
	return p
}

func InitEmptyListavaloresmatContext(p *ListavaloresmatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat
}

func (*ListavaloresmatContext) IsListavaloresmatContext() {}

func NewListavaloresmatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListavaloresmatContext {
	var p = new(ListavaloresmatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat

	return p
}

func (s *ListavaloresmatContext) GetParser() antlr.Parser { return s.parser }

func (s *ListavaloresmatContext) Get_listavaloresmat2() IListavaloresmat2Context {
	return s._listavaloresmat2
}

func (s *ListavaloresmatContext) Get_simplematriz() ISimplematrizContext { return s._simplematriz }

func (s *ListavaloresmatContext) Set_listavaloresmat2(v IListavaloresmat2Context) {
	s._listavaloresmat2 = v
}

func (s *ListavaloresmatContext) Set_simplematriz(v ISimplematrizContext) { s._simplematriz = v }

func (s *ListavaloresmatContext) GetListvlamat() interfaces.Instruction { return s.listvlamat }

func (s *ListavaloresmatContext) SetListvlamat(v interfaces.Instruction) { s.listvlamat = v }

func (s *ListavaloresmatContext) CORCHIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, 0)
}

func (s *ListavaloresmatContext) Listavaloresmat2() IListavaloresmat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListavaloresmat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListavaloresmat2Context)
}

func (s *ListavaloresmatContext) CORCHDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, 0)
}

func (s *ListavaloresmatContext) Simplematriz() ISimplematrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplematrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplematrizContext)
}

func (s *ListavaloresmatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListavaloresmatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListavaloresmatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListavaloresmat(s)
	}
}

func (s *ListavaloresmatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListavaloresmat(s)
	}
}

func (p *SwiftGrammarParser) Listavaloresmat() (localctx IListavaloresmatContext) {
	localctx = NewListavaloresmatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, SwiftGrammarParserRULE_listavaloresmat)
	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(716)
			p.Match(SwiftGrammarParserCORCHIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)

			var _x = p.listavaloresmat2(0)

			localctx.(*ListavaloresmatContext)._listavaloresmat2 = _x
		}
		{
			p.SetState(718)
			p.Match(SwiftGrammarParserCORCHDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*ListavaloresmatContext).listvlamat = localctx.(*ListavaloresmatContext).Get_listavaloresmat2().GetMylisttmatt()

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)

			var _x = p.Simplematriz()

			localctx.(*ListavaloresmatContext)._simplematriz = _x
		}
		localctx.(*ListavaloresmatContext).listvlamat = localctx.(*ListavaloresmatContext).Get_simplematriz().GetSimmat()

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListavaloresmat2Context is an interface to support dynamic dispatch.
type IListavaloresmat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op rule contexts.
	GetOp() IListavaloresmat2Context

	// Get_listavaloresmat returns the _listavaloresmat rule contexts.
	Get_listavaloresmat() IListavaloresmatContext

	// Get_listaexpresions returns the _listaexpresions rule contexts.
	Get_listaexpresions() IListaexpresionsContext

	// SetOp sets the op rule contexts.
	SetOp(IListavaloresmat2Context)

	// Set_listavaloresmat sets the _listavaloresmat rule contexts.
	Set_listavaloresmat(IListavaloresmatContext)

	// Set_listaexpresions sets the _listaexpresions rule contexts.
	Set_listaexpresions(IListaexpresionsContext)

	// GetMylisttmatt returns the mylisttmatt attribute.
	GetMylisttmatt() interfaces.Instruction

	// SetMylisttmatt sets the mylisttmatt attribute.
	SetMylisttmatt(interfaces.Instruction)

	// Getter signatures
	Listavaloresmat() IListavaloresmatContext
	Listaexpresions() IListaexpresionsContext
	COMA() antlr.TerminalNode
	Listavaloresmat2() IListavaloresmat2Context

	// IsListavaloresmat2Context differentiates from other interfaces.
	IsListavaloresmat2Context()
}

type Listavaloresmat2Context struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	mylisttmatt      interfaces.Instruction
	op               IListavaloresmat2Context
	_listavaloresmat IListavaloresmatContext
	_listaexpresions IListaexpresionsContext
}

func NewEmptyListavaloresmat2Context() *Listavaloresmat2Context {
	var p = new(Listavaloresmat2Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat2
	return p
}

func InitEmptyListavaloresmat2Context(p *Listavaloresmat2Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat2
}

func (*Listavaloresmat2Context) IsListavaloresmat2Context() {}

func NewListavaloresmat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Listavaloresmat2Context {
	var p = new(Listavaloresmat2Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listavaloresmat2

	return p
}

func (s *Listavaloresmat2Context) GetParser() antlr.Parser { return s.parser }

func (s *Listavaloresmat2Context) GetOp() IListavaloresmat2Context { return s.op }

func (s *Listavaloresmat2Context) Get_listavaloresmat() IListavaloresmatContext {
	return s._listavaloresmat
}

func (s *Listavaloresmat2Context) Get_listaexpresions() IListaexpresionsContext {
	return s._listaexpresions
}

func (s *Listavaloresmat2Context) SetOp(v IListavaloresmat2Context) { s.op = v }

func (s *Listavaloresmat2Context) Set_listavaloresmat(v IListavaloresmatContext) {
	s._listavaloresmat = v
}

func (s *Listavaloresmat2Context) Set_listaexpresions(v IListaexpresionsContext) {
	s._listaexpresions = v
}

func (s *Listavaloresmat2Context) GetMylisttmatt() interfaces.Instruction { return s.mylisttmatt }

func (s *Listavaloresmat2Context) SetMylisttmatt(v interfaces.Instruction) { s.mylisttmatt = v }

func (s *Listavaloresmat2Context) Listavaloresmat() IListavaloresmatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListavaloresmatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListavaloresmatContext)
}

func (s *Listavaloresmat2Context) Listaexpresions() IListaexpresionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaexpresionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaexpresionsContext)
}

func (s *Listavaloresmat2Context) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *Listavaloresmat2Context) Listavaloresmat2() IListavaloresmat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListavaloresmat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListavaloresmat2Context)
}

func (s *Listavaloresmat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Listavaloresmat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Listavaloresmat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListavaloresmat2(s)
	}
}

func (s *Listavaloresmat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListavaloresmat2(s)
	}
}

func (p *SwiftGrammarParser) Listavaloresmat2() (localctx IListavaloresmat2Context) {
	return p.listavaloresmat2(0)
}

func (p *SwiftGrammarParser) listavaloresmat2(_p int) (localctx IListavaloresmat2Context) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewListavaloresmat2Context(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IListavaloresmat2Context = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 64
	p.EnterRecursionRule(localctx, 64, SwiftGrammarParserRULE_listavaloresmat2, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SwiftGrammarParserCORCHIZQ:
		{
			p.SetState(727)

			var _x = p.Listavaloresmat()

			localctx.(*Listavaloresmat2Context)._listavaloresmat = _x
		}
		localctx.(*Listavaloresmat2Context).mylisttmatt = instructions.NewMatrizListaNivel(localctx.(*Listavaloresmat2Context).Get_listavaloresmat().GetListvlamat())

	case SwiftGrammarParserT__0, SwiftGrammarParserFLOAT, SwiftGrammarParserSTRING, SwiftGrammarParserTRU, SwiftGrammarParserFAL, SwiftGrammarParserNULO, SwiftGrammarParserNUMBER, SwiftGrammarParserCADENA, SwiftGrammarParserID_VALIDO, SwiftGrammarParserCHARACTER, SwiftGrammarParserPARIZQ, SwiftGrammarParserNOT, SwiftGrammarParserSUB, SwiftGrammarParserCOMA:
		{
			p.SetState(730)

			var _x = p.Listaexpresions()

			localctx.(*Listavaloresmat2Context)._listaexpresions = _x
		}
		localctx.(*Listavaloresmat2Context).mylisttmatt = instructions.NewMatrizListaExpresion(localctx.(*Listavaloresmat2Context).Get_listaexpresions().GetBlkparf())

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewListavaloresmat2Context(p, _parentctx, _parentState)
			localctx.(*Listavaloresmat2Context).op = _prevctx
			p.PushNewRecursionContext(localctx, _startState, SwiftGrammarParserRULE_listavaloresmat2)
			p.SetState(735)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				goto errorExit
			}
			{
				p.SetState(736)
				p.Match(SwiftGrammarParserCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(737)

				var _x = p.Listavaloresmat()

				localctx.(*Listavaloresmat2Context)._listavaloresmat = _x
			}
			localctx.(*Listavaloresmat2Context).mylisttmatt = instructions.NewMatrizListaExpresionList(localctx.(*Listavaloresmat2Context).GetOp().GetMylisttmatt(), localctx.(*Listavaloresmat2Context).Get_listavaloresmat().GetListvlamat())

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaexpresionsContext is an interface to support dynamic dispatch.
type IListaexpresionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listaexpresion returns the _listaexpresion rule contexts.
	Get_listaexpresion() IListaexpresionContext

	// Set_listaexpresion sets the _listaexpresion rule contexts.
	Set_listaexpresion(IListaexpresionContext)

	// GetFunpar returns the funpar rule context list.
	GetFunpar() []IListaexpresionContext

	// SetFunpar sets the funpar rule context list.
	SetFunpar([]IListaexpresionContext)

	// GetBlkparf returns the blkparf attribute.
	GetBlkparf() []interface{}

	// SetBlkparf sets the blkparf attribute.
	SetBlkparf([]interface{})

	// Getter signatures
	AllListaexpresion() []IListaexpresionContext
	Listaexpresion(i int) IListaexpresionContext

	// IsListaexpresionsContext differentiates from other interfaces.
	IsListaexpresionsContext()
}

type ListaexpresionsContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	blkparf         []interface{}
	_listaexpresion IListaexpresionContext
	funpar          []IListaexpresionContext
}

func NewEmptyListaexpresionsContext() *ListaexpresionsContext {
	var p = new(ListaexpresionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresions
	return p
}

func InitEmptyListaexpresionsContext(p *ListaexpresionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresions
}

func (*ListaexpresionsContext) IsListaexpresionsContext() {}

func NewListaexpresionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaexpresionsContext {
	var p = new(ListaexpresionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresions

	return p
}

func (s *ListaexpresionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaexpresionsContext) Get_listaexpresion() IListaexpresionContext {
	return s._listaexpresion
}

func (s *ListaexpresionsContext) Set_listaexpresion(v IListaexpresionContext) { s._listaexpresion = v }

func (s *ListaexpresionsContext) GetFunpar() []IListaexpresionContext { return s.funpar }

func (s *ListaexpresionsContext) SetFunpar(v []IListaexpresionContext) { s.funpar = v }

func (s *ListaexpresionsContext) GetBlkparf() []interface{} { return s.blkparf }

func (s *ListaexpresionsContext) SetBlkparf(v []interface{}) { s.blkparf = v }

func (s *ListaexpresionsContext) AllListaexpresion() []IListaexpresionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListaexpresionContext); ok {
			len++
		}
	}

	tst := make([]IListaexpresionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListaexpresionContext); ok {
			tst[i] = t.(IListaexpresionContext)
			i++
		}
	}

	return tst
}

func (s *ListaexpresionsContext) Listaexpresion(i int) IListaexpresionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaexpresionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaexpresionContext)
}

func (s *ListaexpresionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaexpresionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaexpresionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaexpresions(s)
	}
}

func (s *ListaexpresionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaexpresions(s)
	}
}

func (p *SwiftGrammarParser) Listaexpresions() (localctx IListaexpresionsContext) {
	localctx = NewListaexpresionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, SwiftGrammarParserRULE_listaexpresions)

	localctx.(*ListaexpresionsContext).blkparf = []interface{}{}
	var listInt []IListaexpresionContext

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(745)

				var _x = p.Listaexpresion()

				localctx.(*ListaexpresionsContext)._listaexpresion = _x
			}
			localctx.(*ListaexpresionsContext).funpar = append(localctx.(*ListaexpresionsContext).funpar, localctx.(*ListaexpresionsContext)._listaexpresion)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

	listInt = localctx.(*ListaexpresionsContext).GetFunpar()
	for _, e := range listInt {
		localctx.(*ListaexpresionsContext).blkparf = append(localctx.(*ListaexpresionsContext).blkparf, e.GetFunpar())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaexpresionContext is an interface to support dynamic dispatch.
type IListaexpresionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_COMA returns the _COMA token.
	Get_COMA() antlr.Token

	// Set_COMA sets the _COMA token.
	Set_COMA(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetFunpar returns the funpar attribute.
	GetFunpar() interfaces.Expression

	// SetFunpar sets the funpar attribute.
	SetFunpar(interfaces.Expression)

	// Getter signatures
	COMA() antlr.TerminalNode
	Expr() IExprContext

	// IsListaexpresionContext differentiates from other interfaces.
	IsListaexpresionContext()
}

type ListaexpresionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	funpar interfaces.Expression
	_COMA  antlr.Token
	_expr  IExprContext
}

func NewEmptyListaexpresionContext() *ListaexpresionContext {
	var p = new(ListaexpresionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresion
	return p
}

func InitEmptyListaexpresionContext(p *ListaexpresionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresion
}

func (*ListaexpresionContext) IsListaexpresionContext() {}

func NewListaexpresionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaexpresionContext {
	var p = new(ListaexpresionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaexpresion

	return p
}

func (s *ListaexpresionContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaexpresionContext) Get_COMA() antlr.Token { return s._COMA }

func (s *ListaexpresionContext) Set_COMA(v antlr.Token) { s._COMA = v }

func (s *ListaexpresionContext) Get_expr() IExprContext { return s._expr }

func (s *ListaexpresionContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ListaexpresionContext) GetFunpar() interfaces.Expression { return s.funpar }

func (s *ListaexpresionContext) SetFunpar(v interfaces.Expression) { s.funpar = v }

func (s *ListaexpresionContext) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *ListaexpresionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListaexpresionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaexpresionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaexpresionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaexpresion(s)
	}
}

func (s *ListaexpresionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaexpresion(s)
	}
}

func (p *SwiftGrammarParser) Listaexpresion() (localctx IListaexpresionContext) {
	localctx = NewListaexpresionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, SwiftGrammarParserRULE_listaexpresion)
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SwiftGrammarParserCOMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(752)

			var _m = p.Match(SwiftGrammarParserCOMA)

			localctx.(*ListaexpresionContext)._COMA = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(753)

			var _x = p.expr(0)

			localctx.(*ListaexpresionContext)._expr = _x
		}

		localctx.(*ListaexpresionContext).funpar = instructions.NewArregloParametros((func() int {
			if localctx.(*ListaexpresionContext).Get_COMA() == nil {
				return 0
			} else {
				return localctx.(*ListaexpresionContext).Get_COMA().GetLine()
			}
		}()), (func() int {
			if localctx.(*ListaexpresionContext).Get_COMA() == nil {
				return 0
			} else {
				return localctx.(*ListaexpresionContext).Get_COMA().GetColumn()
			}
		}()), localctx.(*ListaexpresionContext).Get_expr().GetE())

	case SwiftGrammarParserT__0, SwiftGrammarParserFLOAT, SwiftGrammarParserSTRING, SwiftGrammarParserTRU, SwiftGrammarParserFAL, SwiftGrammarParserNULO, SwiftGrammarParserNUMBER, SwiftGrammarParserCADENA, SwiftGrammarParserID_VALIDO, SwiftGrammarParserCHARACTER, SwiftGrammarParserPARIZQ, SwiftGrammarParserNOT, SwiftGrammarParserSUB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)

			var _x = p.expr(0)

			localctx.(*ListaexpresionContext)._expr = _x
		}

		localctx.(*ListaexpresionContext).funpar = instructions.NewArregloParametro(localctx.(*ListaexpresionContext).Get_expr().GetE())

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimplematrizContext is an interface to support dynamic dispatch.
type ISimplematrizContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_NUMBER returns the _NUMBER token.
	Get_NUMBER() antlr.Token

	// Set_NUMBER sets the _NUMBER token.
	Set_NUMBER(antlr.Token)

	// Get_tipomatriz returns the _tipomatriz rule contexts.
	Get_tipomatriz() ITipomatrizContext

	// GetOp returns the op rule contexts.
	GetOp() ISimplematrizContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_tipomatriz sets the _tipomatriz rule contexts.
	Set_tipomatriz(ITipomatrizContext)

	// SetOp sets the op rule contexts.
	SetOp(ISimplematrizContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetSimmat returns the simmat attribute.
	GetSimmat() interfaces.Instruction

	// SetSimmat sets the simmat attribute.
	SetSimmat(interfaces.Instruction)

	// Getter signatures
	Tipomatriz() ITipomatrizContext
	PARIZQ() antlr.TerminalNode
	REPEATING() antlr.TerminalNode
	AllDOS_PUNTOS() []antlr.TerminalNode
	DOS_PUNTOS(i int) antlr.TerminalNode
	COMA() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	PARDER() antlr.TerminalNode
	Simplematriz() ISimplematrizContext
	Expr() IExprContext

	// IsSimplematrizContext differentiates from other interfaces.
	IsSimplematrizContext()
}

type SimplematrizContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	simmat      interfaces.Instruction
	_tipomatriz ITipomatrizContext
	op          ISimplematrizContext
	_NUMBER     antlr.Token
	_expr       IExprContext
}

func NewEmptySimplematrizContext() *SimplematrizContext {
	var p = new(SimplematrizContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_simplematriz
	return p
}

func InitEmptySimplematrizContext(p *SimplematrizContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_simplematriz
}

func (*SimplematrizContext) IsSimplematrizContext() {}

func NewSimplematrizContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplematrizContext {
	var p = new(SimplematrizContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_simplematriz

	return p
}

func (s *SimplematrizContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplematrizContext) Get_NUMBER() antlr.Token { return s._NUMBER }

func (s *SimplematrizContext) Set_NUMBER(v antlr.Token) { s._NUMBER = v }

func (s *SimplematrizContext) Get_tipomatriz() ITipomatrizContext { return s._tipomatriz }

func (s *SimplematrizContext) GetOp() ISimplematrizContext { return s.op }

func (s *SimplematrizContext) Get_expr() IExprContext { return s._expr }

func (s *SimplematrizContext) Set_tipomatriz(v ITipomatrizContext) { s._tipomatriz = v }

func (s *SimplematrizContext) SetOp(v ISimplematrizContext) { s.op = v }

func (s *SimplematrizContext) Set_expr(v IExprContext) { s._expr = v }

func (s *SimplematrizContext) GetSimmat() interfaces.Instruction { return s.simmat }

func (s *SimplematrizContext) SetSimmat(v interfaces.Instruction) { s.simmat = v }

func (s *SimplematrizContext) Tipomatriz() ITipomatrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipomatrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipomatrizContext)
}

func (s *SimplematrizContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *SimplematrizContext) REPEATING() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserREPEATING, 0)
}

func (s *SimplematrizContext) AllDOS_PUNTOS() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserDOS_PUNTOS)
}

func (s *SimplematrizContext) DOS_PUNTOS(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, i)
}

func (s *SimplematrizContext) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *SimplematrizContext) COUNT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOUNT, 0)
}

func (s *SimplematrizContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserNUMBER, 0)
}

func (s *SimplematrizContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *SimplematrizContext) Simplematriz() ISimplematrizContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplematrizContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplematrizContext)
}

func (s *SimplematrizContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimplematrizContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplematrizContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimplematrizContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterSimplematriz(s)
	}
}

func (s *SimplematrizContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitSimplematriz(s)
	}
}

func (p *SwiftGrammarParser) Simplematriz() (localctx ISimplematrizContext) {
	localctx = NewSimplematrizContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, SwiftGrammarParserRULE_simplematriz)
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(761)

			var _x = p.Tipomatriz()

			localctx.(*SimplematrizContext)._tipomatriz = _x
		}
		{
			p.SetState(762)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(763)
			p.Match(SwiftGrammarParserREPEATING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(764)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(765)

			var _x = p.Simplematriz()

			localctx.(*SimplematrizContext).op = _x
		}
		{
			p.SetState(766)
			p.Match(SwiftGrammarParserCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(767)
			p.Match(SwiftGrammarParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(768)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)

			var _m = p.Match(SwiftGrammarParserNUMBER)

			localctx.(*SimplematrizContext)._NUMBER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(770)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SimplematrizContext).simmat = instructions.NewMatrizSimpleUno(localctx.(*SimplematrizContext).Get_tipomatriz().GetTipomat(), localctx.(*SimplematrizContext).GetOp().GetSimmat(), (func() string {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return ""
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetText()
			}
		}()), (func() int {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return 0
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetLine()
			}
		}()), (func() int {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return 0
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetColumn()
			}
		}()))

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(773)

			var _x = p.Tipomatriz()

			localctx.(*SimplematrizContext)._tipomatriz = _x
		}
		{
			p.SetState(774)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(775)
			p.Match(SwiftGrammarParserREPEATING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(776)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(777)

			var _x = p.expr(0)

			localctx.(*SimplematrizContext)._expr = _x
		}
		{
			p.SetState(778)
			p.Match(SwiftGrammarParserCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(779)
			p.Match(SwiftGrammarParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(780)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(781)

			var _m = p.Match(SwiftGrammarParserNUMBER)

			localctx.(*SimplematrizContext)._NUMBER = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(782)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		localctx.(*SimplematrizContext).simmat = instructions.NewMatrizSimpleDos(localctx.(*SimplematrizContext).Get_tipomatriz().GetTipomat(), localctx.(*SimplematrizContext).Get_expr().GetE(), (func() string {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return ""
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetText()
			}
		}()), (func() int {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return 0
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetLine()
			}
		}()), (func() int {
			if localctx.(*SimplematrizContext).Get_NUMBER() == nil {
				return 0
			} else {
				return localctx.(*SimplematrizContext).Get_NUMBER().GetColumn()
			}
		}()))

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListamatrizaddsubsContext is an interface to support dynamic dispatch.
type IListamatrizaddsubsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listamatrizaddsub returns the _listamatrizaddsub rule contexts.
	Get_listamatrizaddsub() IListamatrizaddsubContext

	// Set_listamatrizaddsub sets the _listamatrizaddsub rule contexts.
	Set_listamatrizaddsub(IListamatrizaddsubContext)

	// GetLmas returns the lmas rule context list.
	GetLmas() []IListamatrizaddsubContext

	// SetLmas sets the lmas rule context list.
	SetLmas([]IListamatrizaddsubContext)

	// GetBlklimatas returns the blklimatas attribute.
	GetBlklimatas() []interface{}

	// SetBlklimatas sets the blklimatas attribute.
	SetBlklimatas([]interface{})

	// Getter signatures
	AllListamatrizaddsub() []IListamatrizaddsubContext
	Listamatrizaddsub(i int) IListamatrizaddsubContext

	// IsListamatrizaddsubsContext differentiates from other interfaces.
	IsListamatrizaddsubsContext()
}

type ListamatrizaddsubsContext struct {
	antlr.BaseParserRuleContext
	parser             antlr.Parser
	blklimatas         []interface{}
	_listamatrizaddsub IListamatrizaddsubContext
	lmas               []IListamatrizaddsubContext
}

func NewEmptyListamatrizaddsubsContext() *ListamatrizaddsubsContext {
	var p = new(ListamatrizaddsubsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsubs
	return p
}

func InitEmptyListamatrizaddsubsContext(p *ListamatrizaddsubsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsubs
}

func (*ListamatrizaddsubsContext) IsListamatrizaddsubsContext() {}

func NewListamatrizaddsubsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListamatrizaddsubsContext {
	var p = new(ListamatrizaddsubsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsubs

	return p
}

func (s *ListamatrizaddsubsContext) GetParser() antlr.Parser { return s.parser }

func (s *ListamatrizaddsubsContext) Get_listamatrizaddsub() IListamatrizaddsubContext {
	return s._listamatrizaddsub
}

func (s *ListamatrizaddsubsContext) Set_listamatrizaddsub(v IListamatrizaddsubContext) {
	s._listamatrizaddsub = v
}

func (s *ListamatrizaddsubsContext) GetLmas() []IListamatrizaddsubContext { return s.lmas }

func (s *ListamatrizaddsubsContext) SetLmas(v []IListamatrizaddsubContext) { s.lmas = v }

func (s *ListamatrizaddsubsContext) GetBlklimatas() []interface{} { return s.blklimatas }

func (s *ListamatrizaddsubsContext) SetBlklimatas(v []interface{}) { s.blklimatas = v }

func (s *ListamatrizaddsubsContext) AllListamatrizaddsub() []IListamatrizaddsubContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListamatrizaddsubContext); ok {
			len++
		}
	}

	tst := make([]IListamatrizaddsubContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListamatrizaddsubContext); ok {
			tst[i] = t.(IListamatrizaddsubContext)
			i++
		}
	}

	return tst
}

func (s *ListamatrizaddsubsContext) Listamatrizaddsub(i int) IListamatrizaddsubContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListamatrizaddsubContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListamatrizaddsubContext)
}

func (s *ListamatrizaddsubsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListamatrizaddsubsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListamatrizaddsubsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListamatrizaddsubs(s)
	}
}

func (s *ListamatrizaddsubsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListamatrizaddsubs(s)
	}
}

func (p *SwiftGrammarParser) Listamatrizaddsubs() (localctx IListamatrizaddsubsContext) {
	localctx = NewListamatrizaddsubsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, SwiftGrammarParserRULE_listamatrizaddsubs)

	localctx.(*ListamatrizaddsubsContext).blklimatas = []interface{}{}
	var listInt []IListamatrizaddsubContext

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(787)

				var _x = p.Listamatrizaddsub()

				localctx.(*ListamatrizaddsubsContext)._listamatrizaddsub = _x
			}
			localctx.(*ListamatrizaddsubsContext).lmas = append(localctx.(*ListamatrizaddsubsContext).lmas, localctx.(*ListamatrizaddsubsContext)._listamatrizaddsub)

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

	listInt = localctx.(*ListamatrizaddsubsContext).GetLmas()
	for _, e := range listInt {
		localctx.(*ListamatrizaddsubsContext).blklimatas = append(localctx.(*ListamatrizaddsubsContext).blklimatas, e.GetLmas())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListamatrizaddsubContext is an interface to support dynamic dispatch.
type IListamatrizaddsubContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_CORCHIZQ returns the _CORCHIZQ token.
	Get_CORCHIZQ() antlr.Token

	// Set_CORCHIZQ sets the _CORCHIZQ token.
	Set_CORCHIZQ(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetLmas returns the lmas attribute.
	GetLmas() interfaces.Expression

	// SetLmas sets the lmas attribute.
	SetLmas(interfaces.Expression)

	// Getter signatures
	CORCHIZQ() antlr.TerminalNode
	Expr() IExprContext
	CORCHDER() antlr.TerminalNode

	// IsListamatrizaddsubContext differentiates from other interfaces.
	IsListamatrizaddsubContext()
}

type ListamatrizaddsubContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	lmas      interfaces.Expression
	_CORCHIZQ antlr.Token
	_expr     IExprContext
}

func NewEmptyListamatrizaddsubContext() *ListamatrizaddsubContext {
	var p = new(ListamatrizaddsubContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsub
	return p
}

func InitEmptyListamatrizaddsubContext(p *ListamatrizaddsubContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsub
}

func (*ListamatrizaddsubContext) IsListamatrizaddsubContext() {}

func NewListamatrizaddsubContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListamatrizaddsubContext {
	var p = new(ListamatrizaddsubContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listamatrizaddsub

	return p
}

func (s *ListamatrizaddsubContext) GetParser() antlr.Parser { return s.parser }

func (s *ListamatrizaddsubContext) Get_CORCHIZQ() antlr.Token { return s._CORCHIZQ }

func (s *ListamatrizaddsubContext) Set_CORCHIZQ(v antlr.Token) { s._CORCHIZQ = v }

func (s *ListamatrizaddsubContext) Get_expr() IExprContext { return s._expr }

func (s *ListamatrizaddsubContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ListamatrizaddsubContext) GetLmas() interfaces.Expression { return s.lmas }

func (s *ListamatrizaddsubContext) SetLmas(v interfaces.Expression) { s.lmas = v }

func (s *ListamatrizaddsubContext) CORCHIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHIZQ, 0)
}

func (s *ListamatrizaddsubContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListamatrizaddsubContext) CORCHDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCORCHDER, 0)
}

func (s *ListamatrizaddsubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListamatrizaddsubContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListamatrizaddsubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListamatrizaddsub(s)
	}
}

func (s *ListamatrizaddsubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListamatrizaddsub(s)
	}
}

func (p *SwiftGrammarParser) Listamatrizaddsub() (localctx IListamatrizaddsubContext) {
	localctx = NewListamatrizaddsubContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, SwiftGrammarParserRULE_listamatrizaddsub)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)

		var _m = p.Match(SwiftGrammarParserCORCHIZQ)

		localctx.(*ListamatrizaddsubContext)._CORCHIZQ = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(795)

		var _x = p.expr(0)

		localctx.(*ListamatrizaddsubContext)._expr = _x
	}
	{
		p.SetState(796)
		p.Match(SwiftGrammarParserCORCHDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*ListamatrizaddsubContext).lmas = instructions.NewArregloParametros((func() int {
		if localctx.(*ListamatrizaddsubContext).Get_CORCHIZQ() == nil {
			return 0
		} else {
			return localctx.(*ListamatrizaddsubContext).Get_CORCHIZQ().GetLine()
		}
	}()), (func() int {
		if localctx.(*ListamatrizaddsubContext).Get_CORCHIZQ() == nil {
			return 0
		} else {
			return localctx.(*ListamatrizaddsubContext).Get_CORCHIZQ().GetColumn()
		}
	}()), localctx.(*ListamatrizaddsubContext).Get_expr().GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructcontrolContext is an interface to support dynamic dispatch.
type IStructcontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_STRUCT returns the _STRUCT token.
	Get_STRUCT() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_STRUCT sets the _STRUCT token.
	Set_STRUCT(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Get_listaatributos returns the _listaatributos rule contexts.
	Get_listaatributos() IListaatributosContext

	// Set_listaatributos sets the _listaatributos rule contexts.
	Set_listaatributos(IListaatributosContext)

	// GetStruck returns the struck attribute.
	GetStruck() interfaces.Instruction

	// SetStruck sets the struck attribute.
	SetStruck(interfaces.Instruction)

	// Getter signatures
	STRUCT() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	LLAVEIZQ() antlr.TerminalNode
	Listaatributos() IListaatributosContext
	LLAVEDER() antlr.TerminalNode

	// IsStructcontrolContext differentiates from other interfaces.
	IsStructcontrolContext()
}

type StructcontrolContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	struck          interfaces.Instruction
	_STRUCT         antlr.Token
	_ID_VALIDO      antlr.Token
	_listaatributos IListaatributosContext
}

func NewEmptyStructcontrolContext() *StructcontrolContext {
	var p = new(StructcontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_structcontrol
	return p
}

func InitEmptyStructcontrolContext(p *StructcontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_structcontrol
}

func (*StructcontrolContext) IsStructcontrolContext() {}

func NewStructcontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructcontrolContext {
	var p = new(StructcontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_structcontrol

	return p
}

func (s *StructcontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *StructcontrolContext) Get_STRUCT() antlr.Token { return s._STRUCT }

func (s *StructcontrolContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *StructcontrolContext) Set_STRUCT(v antlr.Token) { s._STRUCT = v }

func (s *StructcontrolContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *StructcontrolContext) Get_listaatributos() IListaatributosContext { return s._listaatributos }

func (s *StructcontrolContext) Set_listaatributos(v IListaatributosContext) { s._listaatributos = v }

func (s *StructcontrolContext) GetStruck() interfaces.Instruction { return s.struck }

func (s *StructcontrolContext) SetStruck(v interfaces.Instruction) { s.struck = v }

func (s *StructcontrolContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSTRUCT, 0)
}

func (s *StructcontrolContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *StructcontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *StructcontrolContext) Listaatributos() IListaatributosContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaatributosContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaatributosContext)
}

func (s *StructcontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *StructcontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructcontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructcontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterStructcontrol(s)
	}
}

func (s *StructcontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitStructcontrol(s)
	}
}

func (p *SwiftGrammarParser) Structcontrol() (localctx IStructcontrolContext) {
	localctx = NewStructcontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, SwiftGrammarParserRULE_structcontrol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)

		var _m = p.Match(SwiftGrammarParserSTRUCT)

		localctx.(*StructcontrolContext)._STRUCT = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(800)

		var _m = p.Match(SwiftGrammarParserID_VALIDO)

		localctx.(*StructcontrolContext)._ID_VALIDO = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(801)
		p.Match(SwiftGrammarParserLLAVEIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(802)

		var _x = p.Listaatributos()

		localctx.(*StructcontrolContext)._listaatributos = _x
	}
	{
		p.SetState(803)
		p.Match(SwiftGrammarParserLLAVEDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	localctx.(*StructcontrolContext).SetStruck(instructions.NewStruck((func() int {
		if localctx.(*StructcontrolContext).Get_STRUCT() == nil {
			return 0
		} else {
			return localctx.(*StructcontrolContext).Get_STRUCT().GetLine()
		}
	}()), (func() int {
		if localctx.(*StructcontrolContext).Get_STRUCT() == nil {
			return 0
		} else {
			return localctx.(*StructcontrolContext).Get_STRUCT().GetColumn()
		}
	}()), (func() string {
		if localctx.(*StructcontrolContext).Get_ID_VALIDO() == nil {
			return ""
		} else {
			return localctx.(*StructcontrolContext).Get_ID_VALIDO().GetText()
		}
	}()), localctx.(*StructcontrolContext).Get_listaatributos().GetBlkstlt()))

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaatributosContext is an interface to support dynamic dispatch.
type IListaatributosContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_listaatributo returns the _listaatributo rule contexts.
	Get_listaatributo() IListaatributoContext

	// Set_listaatributo sets the _listaatributo rule contexts.
	Set_listaatributo(IListaatributoContext)

	// GetListatstr returns the listatstr rule context list.
	GetListatstr() []IListaatributoContext

	// SetListatstr sets the listatstr rule context list.
	SetListatstr([]IListaatributoContext)

	// GetBlkstlt returns the blkstlt attribute.
	GetBlkstlt() []interface{}

	// SetBlkstlt sets the blkstlt attribute.
	SetBlkstlt([]interface{})

	// Getter signatures
	AllListaatributo() []IListaatributoContext
	Listaatributo(i int) IListaatributoContext

	// IsListaatributosContext differentiates from other interfaces.
	IsListaatributosContext()
}

type ListaatributosContext struct {
	antlr.BaseParserRuleContext
	parser         antlr.Parser
	blkstlt        []interface{}
	_listaatributo IListaatributoContext
	listatstr      []IListaatributoContext
}

func NewEmptyListaatributosContext() *ListaatributosContext {
	var p = new(ListaatributosContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaatributos
	return p
}

func InitEmptyListaatributosContext(p *ListaatributosContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaatributos
}

func (*ListaatributosContext) IsListaatributosContext() {}

func NewListaatributosContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaatributosContext {
	var p = new(ListaatributosContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaatributos

	return p
}

func (s *ListaatributosContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaatributosContext) Get_listaatributo() IListaatributoContext { return s._listaatributo }

func (s *ListaatributosContext) Set_listaatributo(v IListaatributoContext) { s._listaatributo = v }

func (s *ListaatributosContext) GetListatstr() []IListaatributoContext { return s.listatstr }

func (s *ListaatributosContext) SetListatstr(v []IListaatributoContext) { s.listatstr = v }

func (s *ListaatributosContext) GetBlkstlt() []interface{} { return s.blkstlt }

func (s *ListaatributosContext) SetBlkstlt(v []interface{}) { s.blkstlt = v }

func (s *ListaatributosContext) AllListaatributo() []IListaatributoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListaatributoContext); ok {
			len++
		}
	}

	tst := make([]IListaatributoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListaatributoContext); ok {
			tst[i] = t.(IListaatributoContext)
			i++
		}
	}

	return tst
}

func (s *ListaatributosContext) Listaatributo(i int) IListaatributoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaatributoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaatributoContext)
}

func (s *ListaatributosContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaatributosContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaatributosContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaatributos(s)
	}
}

func (s *ListaatributosContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaatributos(s)
	}
}

func (p *SwiftGrammarParser) Listaatributos() (localctx IListaatributosContext) {
	localctx = NewListaatributosContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, SwiftGrammarParserRULE_listaatributos)

	localctx.(*ListaatributosContext).blkstlt = []interface{}{}
	var listInt []IListaatributoContext

	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&34376516352) != 0) {
		{
			p.SetState(806)

			var _x = p.Listaatributo()

			localctx.(*ListaatributosContext)._listaatributo = _x
		}
		localctx.(*ListaatributosContext).listatstr = append(localctx.(*ListaatributosContext).listatstr, localctx.(*ListaatributosContext)._listaatributo)

		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	listInt = localctx.(*ListaatributosContext).GetListatstr()
	for _, e := range listInt {
		localctx.(*ListaatributosContext).blkstlt = append(localctx.(*ListaatributosContext).blkstlt, e.GetListatstr())
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaatributoContext is an interface to support dynamic dispatch.
type IListaatributoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTip1 returns the tip1 token.
	GetTip1() antlr.Token

	// GetTip4 returns the tip4 token.
	GetTip4() antlr.Token

	// GetTip3 returns the tip3 token.
	GetTip3() antlr.Token

	// Get_IG returns the _IG token.
	Get_IG() antlr.Token

	// GetTipo returns the tipo token.
	GetTipo() antlr.Token

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Get_MUTATING returns the _MUTATING token.
	Get_MUTATING() antlr.Token

	// SetTip1 sets the tip1 token.
	SetTip1(antlr.Token)

	// SetTip4 sets the tip4 token.
	SetTip4(antlr.Token)

	// SetTip3 sets the tip3 token.
	SetTip3(antlr.Token)

	// Set_IG sets the _IG token.
	Set_IG(antlr.Token)

	// SetTipo sets the tipo token.
	SetTipo(antlr.Token)

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Set_MUTATING sets the _MUTATING token.
	Set_MUTATING(antlr.Token)

	// GetTip2 returns the tip2 rule contexts.
	GetTip2() ITipodatoContext

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Get_funciondeclaracioncontrol returns the _funciondeclaracioncontrol rule contexts.
	Get_funciondeclaracioncontrol() IFunciondeclaracioncontrolContext

	// SetTip2 sets the tip2 rule contexts.
	SetTip2(ITipodatoContext)

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// Set_funciondeclaracioncontrol sets the _funciondeclaracioncontrol rule contexts.
	Set_funciondeclaracioncontrol(IFunciondeclaracioncontrolContext)

	// GetListatstr returns the listatstr attribute.
	GetListatstr() interfaces.Instruction

	// SetListatstr sets the listatstr attribute.
	SetListatstr(interfaces.Instruction)

	// Getter signatures
	DOS_PUNTOS() antlr.TerminalNode
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	LET() antlr.TerminalNode
	VAR() antlr.TerminalNode
	Tipodato() ITipodatoContext
	IG() antlr.TerminalNode
	Expr() IExprContext
	PUNTOCOMA() antlr.TerminalNode
	Funciondeclaracioncontrol() IFunciondeclaracioncontrolContext
	MUTATING() antlr.TerminalNode

	// IsListaatributoContext differentiates from other interfaces.
	IsListaatributoContext()
}

type ListaatributoContext struct {
	antlr.BaseParserRuleContext
	parser                     antlr.Parser
	listatstr                  interfaces.Instruction
	tip1                       antlr.Token
	tip4                       antlr.Token
	tip2                       ITipodatoContext
	tip3                       antlr.Token
	_IG                        antlr.Token
	_expr                      IExprContext
	tipo                       antlr.Token
	_ID_VALIDO                 antlr.Token
	_MUTATING                  antlr.Token
	_funciondeclaracioncontrol IFunciondeclaracioncontrolContext
}

func NewEmptyListaatributoContext() *ListaatributoContext {
	var p = new(ListaatributoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaatributo
	return p
}

func InitEmptyListaatributoContext(p *ListaatributoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaatributo
}

func (*ListaatributoContext) IsListaatributoContext() {}

func NewListaatributoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaatributoContext {
	var p = new(ListaatributoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaatributo

	return p
}

func (s *ListaatributoContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaatributoContext) GetTip1() antlr.Token { return s.tip1 }

func (s *ListaatributoContext) GetTip4() antlr.Token { return s.tip4 }

func (s *ListaatributoContext) GetTip3() antlr.Token { return s.tip3 }

func (s *ListaatributoContext) Get_IG() antlr.Token { return s._IG }

func (s *ListaatributoContext) GetTipo() antlr.Token { return s.tipo }

func (s *ListaatributoContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *ListaatributoContext) Get_MUTATING() antlr.Token { return s._MUTATING }

func (s *ListaatributoContext) SetTip1(v antlr.Token) { s.tip1 = v }

func (s *ListaatributoContext) SetTip4(v antlr.Token) { s.tip4 = v }

func (s *ListaatributoContext) SetTip3(v antlr.Token) { s.tip3 = v }

func (s *ListaatributoContext) Set_IG(v antlr.Token) { s._IG = v }

func (s *ListaatributoContext) SetTipo(v antlr.Token) { s.tipo = v }

func (s *ListaatributoContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *ListaatributoContext) Set_MUTATING(v antlr.Token) { s._MUTATING = v }

func (s *ListaatributoContext) GetTip2() ITipodatoContext { return s.tip2 }

func (s *ListaatributoContext) Get_expr() IExprContext { return s._expr }

func (s *ListaatributoContext) Get_funciondeclaracioncontrol() IFunciondeclaracioncontrolContext {
	return s._funciondeclaracioncontrol
}

func (s *ListaatributoContext) SetTip2(v ITipodatoContext) { s.tip2 = v }

func (s *ListaatributoContext) Set_expr(v IExprContext) { s._expr = v }

func (s *ListaatributoContext) Set_funciondeclaracioncontrol(v IFunciondeclaracioncontrolContext) {
	s._funciondeclaracioncontrol = v
}

func (s *ListaatributoContext) GetListatstr() interfaces.Instruction { return s.listatstr }

func (s *ListaatributoContext) SetListatstr(v interfaces.Instruction) { s.listatstr = v }

func (s *ListaatributoContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *ListaatributoContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *ListaatributoContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *ListaatributoContext) LET() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLET, 0)
}

func (s *ListaatributoContext) VAR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserVAR, 0)
}

func (s *ListaatributoContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *ListaatributoContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *ListaatributoContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListaatributoContext) PUNTOCOMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTOCOMA, 0)
}

func (s *ListaatributoContext) Funciondeclaracioncontrol() IFunciondeclaracioncontrolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunciondeclaracioncontrolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunciondeclaracioncontrolContext)
}

func (s *ListaatributoContext) MUTATING() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserMUTATING, 0)
}

func (s *ListaatributoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaatributoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaatributoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaatributo(s)
	}
}

func (s *ListaatributoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaatributo(s)
	}
}

func (p *SwiftGrammarParser) Listaatributo() (localctx IListaatributoContext) {
	localctx = NewListaatributoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, SwiftGrammarParserRULE_listaatributo)
	var _la int

	p.SetState(844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(813)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ListaatributoContext).tip1 = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SwiftGrammarParserVAR || _la == SwiftGrammarParserLET) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ListaatributoContext).tip1 = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(814)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ListaatributoContext).tip4 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case SwiftGrammarParserT__0, SwiftGrammarParserFLOAT, SwiftGrammarParserSTRING, SwiftGrammarParserBOOL, SwiftGrammarParserCHARACT:
			{
				p.SetState(816)

				var _x = p.Tipodato()

				localctx.(*ListaatributoContext).tip2 = _x
			}

		case SwiftGrammarParserID_VALIDO:
			{
				p.SetState(817)

				var _m = p.Match(SwiftGrammarParserID_VALIDO)

				localctx.(*ListaatributoContext).tip3 = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserIG {
			{
				p.SetState(820)

				var _m = p.Match(SwiftGrammarParserIG)

				localctx.(*ListaatributoContext)._IG = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(821)

				var _x = p.expr(0)

				localctx.(*ListaatributoContext)._expr = _x
			}

		}
		p.SetState(825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(824)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		if localctx.(*ListaatributoContext).Get_IG() != nil {
			if (func() string {
				if localctx.(*ListaatributoContext).GetTip3() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).GetTip3().GetText()
				}
			}()) != "" {
				localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributosConTE2((func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip4() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip4().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip3() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip3().GetText()
					}
				}()), localctx.(*ListaatributoContext).Get_expr().GetE())
			} else {
				localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributosConTE((func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip4() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip4().GetText()
					}
				}()), localctx.(*ListaatributoContext).GetTip2().GetTipo(), localctx.(*ListaatributoContext).Get_expr().GetE())
			}
		} else {
			if (func() string {
				if localctx.(*ListaatributoContext).GetTip3() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).GetTip3().GetText()
				}
			}()) != "" {
				localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributosConT2((func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip4() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip4().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip3() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip3().GetText()
					}
				}()))
			} else {
				localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributosConT((func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return 0
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip1() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip1().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaatributoContext).GetTip4() == nil {
						return ""
					} else {
						return localctx.(*ListaatributoContext).GetTip4().GetText()
					}
				}()), localctx.(*ListaatributoContext).GetTip2().GetTipo())
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(828)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ListaatributoContext).tipo = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == SwiftGrammarParserVAR || _la == SwiftGrammarParserLET) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ListaatributoContext).tipo = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(829)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ListaatributoContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserIG {
			{
				p.SetState(830)

				var _m = p.Match(SwiftGrammarParserIG)

				localctx.(*ListaatributoContext)._IG = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(831)

				var _x = p.expr(0)

				localctx.(*ListaatributoContext)._expr = _x
			}

		}
		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserPUNTOCOMA {
			{
				p.SetState(834)
				p.Match(SwiftGrammarParserPUNTOCOMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		if localctx.(*ListaatributoContext).Get_IG() != nil {
			localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributosConE((func() int {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return 0
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetLine()
				}
			}()), (func() int {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return 0
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetColumn()
				}
			}()), (func() string {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetText()
				}
			}()), (func() string {
				if localctx.(*ListaatributoContext).Get_ID_VALIDO() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).Get_ID_VALIDO().GetText()
				}
			}()), localctx.(*ListaatributoContext).Get_expr().GetE())
		} else {
			localctx.(*ListaatributoContext).listatstr = instructions.NewStructAtributos((func() int {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return 0
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetLine()
				}
			}()), (func() int {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return 0
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetColumn()
				}
			}()), (func() string {
				if localctx.(*ListaatributoContext).GetTipo() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).GetTipo().GetText()
				}
			}()), (func() string {
				if localctx.(*ListaatributoContext).Get_ID_VALIDO() == nil {
					return ""
				} else {
					return localctx.(*ListaatributoContext).Get_ID_VALIDO().GetText()
				}
			}()))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserMUTATING {
			{
				p.SetState(838)

				var _m = p.Match(SwiftGrammarParserMUTATING)

				localctx.(*ListaatributoContext)._MUTATING = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(841)

			var _x = p.Funciondeclaracioncontrol()

			localctx.(*ListaatributoContext)._funciondeclaracioncontrol = _x
		}

		if localctx.(*ListaatributoContext).Get_MUTATING() != nil {
			//localctx.(*ListaatributoContext).listatstr = instructions.NewStruckMutatingFunction(localctx.(*ListaatributoContext).Get_funciondeclaracioncontrol().GetFdc())
		} else {
			//localctx.(*ListaatributoContext).listatstr = instructions.NewStruckFunction(localctx.(*ListaatributoContext).Get_funciondeclaracioncontrol().GetFdc())
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructexprContext is an interface to support dynamic dispatch.
type IStructexprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	IG() antlr.TerminalNode
	VAR() antlr.TerminalNode
	LET() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode
	L_dupla() IL_duplaContext
	Expr() IExprContext

	// IsStructexprContext differentiates from other interfaces.
	IsStructexprContext()
}

type StructexprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructexprContext() *StructexprContext {
	var p = new(StructexprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_structexpr
	return p
}

func InitEmptyStructexprContext(p *StructexprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_structexpr
}

func (*StructexprContext) IsStructexprContext() {}

func NewStructexprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructexprContext {
	var p = new(StructexprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_structexpr

	return p
}

func (s *StructexprContext) GetParser() antlr.Parser { return s.parser }

func (s *StructexprContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *StructexprContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *StructexprContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *StructexprContext) VAR() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserVAR, 0)
}

func (s *StructexprContext) LET() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLET, 0)
}

func (s *StructexprContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *StructexprContext) L_dupla() IL_duplaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IL_duplaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IL_duplaContext)
}

func (s *StructexprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StructexprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructexprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructexprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterStructexpr(s)
	}
}

func (s *StructexprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitStructexpr(s)
	}
}

func (p *SwiftGrammarParser) Structexpr() (localctx IStructexprContext) {
	localctx = NewStructexprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, SwiftGrammarParserRULE_structexpr)
	var _la int

	p.SetState(879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(846)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SwiftGrammarParserVAR || _la == SwiftGrammarParserLET) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(847)
			p.Match(SwiftGrammarParserID_VALIDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserDOS_PUNTOS {
			{
				p.SetState(848)
				p.Match(SwiftGrammarParserDOS_PUNTOS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(849)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(852)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(853)
			p.Match(SwiftGrammarParserID_VALIDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(855)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserID_VALIDO {
			{
				p.SetState(854)
				p.L_dupla()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SwiftGrammarParserVAR || _la == SwiftGrammarParserLET) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(859)
			p.Match(SwiftGrammarParserID_VALIDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserDOS_PUNTOS {
			{
				p.SetState(860)
				p.Match(SwiftGrammarParserDOS_PUNTOS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(861)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(864)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserID_VALIDO {
			{
				p.SetState(865)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(869)
			_la = p.GetTokenStream().LA(1)

			if !(_la == SwiftGrammarParserVAR || _la == SwiftGrammarParserLET) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(870)
			p.Match(SwiftGrammarParserID_VALIDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserDOS_PUNTOS {
			{
				p.SetState(871)
				p.Match(SwiftGrammarParserDOS_PUNTOS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(872)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(875)
			p.Match(SwiftGrammarParserIG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IL_duplaContext is an interface to support dynamic dispatch.
type IL_duplaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	AllDOS_PUNTOS() []antlr.TerminalNode
	DOS_PUNTOS(i int) antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext

	// IsL_duplaContext differentiates from other interfaces.
	IsL_duplaContext()
}

type L_duplaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyL_duplaContext() *L_duplaContext {
	var p = new(L_duplaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_l_dupla
	return p
}

func InitEmptyL_duplaContext(p *L_duplaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_l_dupla
}

func (*L_duplaContext) IsL_duplaContext() {}

func NewL_duplaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *L_duplaContext {
	var p = new(L_duplaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_l_dupla

	return p
}

func (s *L_duplaContext) GetParser() antlr.Parser { return s.parser }

func (s *L_duplaContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *L_duplaContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *L_duplaContext) AllDOS_PUNTOS() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserDOS_PUNTOS)
}

func (s *L_duplaContext) DOS_PUNTOS(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, i)
}

func (s *L_duplaContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *L_duplaContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *L_duplaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *L_duplaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *L_duplaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterL_dupla(s)
	}
}

func (s *L_duplaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitL_dupla(s)
	}
}

func (p *SwiftGrammarParser) L_dupla() (localctx IL_duplaContext) {
	localctx = NewL_duplaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, SwiftGrammarParserRULE_l_dupla)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(884)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == SwiftGrammarParserID_VALIDO {
		{
			p.SetState(881)
			p.Match(SwiftGrammarParserID_VALIDO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(882)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)
			p.expr(0)
		}

		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILlamadastructContext is an interface to support dynamic dispatch.
type ILlamadastructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	PUNTO() antlr.TerminalNode

	// IsLlamadastructContext differentiates from other interfaces.
	IsLlamadastructContext()
}

type LlamadastructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLlamadastructContext() *LlamadastructContext {
	var p = new(LlamadastructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_llamadastruct
	return p
}

func InitEmptyLlamadastructContext(p *LlamadastructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_llamadastruct
}

func (*LlamadastructContext) IsLlamadastructContext() {}

func NewLlamadastructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LlamadastructContext {
	var p = new(LlamadastructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_llamadastruct

	return p
}

func (s *LlamadastructContext) GetParser() antlr.Parser { return s.parser }

func (s *LlamadastructContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *LlamadastructContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *LlamadastructContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *LlamadastructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LlamadastructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LlamadastructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterLlamadastruct(s)
	}
}

func (s *LlamadastructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitLlamadastruct(s)
	}
}

func (p *SwiftGrammarParser) Llamadastruct() (localctx ILlamadastructContext) {
	localctx = NewLlamadastructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, SwiftGrammarParserRULE_llamadastruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(890)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(891)
		p.Match(SwiftGrammarParserPUNTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(892)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsignacionparametrostructContext is an interface to support dynamic dispatch.
type IAsignacionparametrostructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	IG() antlr.TerminalNode
	Expr() IExprContext

	// IsAsignacionparametrostructContext differentiates from other interfaces.
	IsAsignacionparametrostructContext()
}

type AsignacionparametrostructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsignacionparametrostructContext() *AsignacionparametrostructContext {
	var p = new(AsignacionparametrostructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_asignacionparametrostruct
	return p
}

func InitEmptyAsignacionparametrostructContext(p *AsignacionparametrostructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_asignacionparametrostruct
}

func (*AsignacionparametrostructContext) IsAsignacionparametrostructContext() {}

func NewAsignacionparametrostructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsignacionparametrostructContext {
	var p = new(AsignacionparametrostructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_asignacionparametrostruct

	return p
}

func (s *AsignacionparametrostructContext) GetParser() antlr.Parser { return s.parser }

func (s *AsignacionparametrostructContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *AsignacionparametrostructContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *AsignacionparametrostructContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *AsignacionparametrostructContext) IG() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserIG, 0)
}

func (s *AsignacionparametrostructContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *AsignacionparametrostructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsignacionparametrostructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsignacionparametrostructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterAsignacionparametrostruct(s)
	}
}

func (s *AsignacionparametrostructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitAsignacionparametrostruct(s)
	}
}

func (p *SwiftGrammarParser) Asignacionparametrostruct() (localctx IAsignacionparametrostructContext) {
	localctx = NewAsignacionparametrostructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, SwiftGrammarParserRULE_asignacionparametrostruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(895)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(896)
		p.Match(SwiftGrammarParserPUNTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(897)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(898)
		p.Match(SwiftGrammarParserIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(899)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILlamadafuncionstructContext is an interface to support dynamic dispatch.
type ILlamadafuncionstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	PUNTO() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	PARDER() antlr.TerminalNode

	// IsLlamadafuncionstructContext differentiates from other interfaces.
	IsLlamadafuncionstructContext()
}

type LlamadafuncionstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLlamadafuncionstructContext() *LlamadafuncionstructContext {
	var p = new(LlamadafuncionstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_llamadafuncionstruct
	return p
}

func InitEmptyLlamadafuncionstructContext(p *LlamadafuncionstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_llamadafuncionstruct
}

func (*LlamadafuncionstructContext) IsLlamadafuncionstructContext() {}

func NewLlamadafuncionstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LlamadafuncionstructContext {
	var p = new(LlamadafuncionstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_llamadafuncionstruct

	return p
}

func (s *LlamadafuncionstructContext) GetParser() antlr.Parser { return s.parser }

func (s *LlamadafuncionstructContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *LlamadafuncionstructContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *LlamadafuncionstructContext) PUNTO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPUNTO, 0)
}

func (s *LlamadafuncionstructContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *LlamadafuncionstructContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *LlamadafuncionstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LlamadafuncionstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LlamadafuncionstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterLlamadafuncionstruct(s)
	}
}

func (s *LlamadafuncionstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitLlamadafuncionstruct(s)
	}
}

func (p *SwiftGrammarParser) Llamadafuncionstruct() (localctx ILlamadafuncionstructContext) {
	localctx = NewLlamadafuncionstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, SwiftGrammarParserRULE_llamadafuncionstruct)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(902)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(903)
		p.Match(SwiftGrammarParserPUNTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(904)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(905)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(906)
		p.Match(SwiftGrammarParserPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunciondeclaracioncontrolContext is an interface to support dynamic dispatch.
type IFunciondeclaracioncontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_ID_VALIDO returns the _ID_VALIDO token.
	Get_ID_VALIDO() antlr.Token

	// Set_ID_VALIDO sets the _ID_VALIDO token.
	Set_ID_VALIDO(antlr.Token)

	// Get_listaparametro returns the _listaparametro rule contexts.
	Get_listaparametro() IListaparametroContext

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// Get_blockinterno returns the _blockinterno rule contexts.
	Get_blockinterno() IBlockinternoContext

	// Set_listaparametro sets the _listaparametro rule contexts.
	Set_listaparametro(IListaparametroContext)

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// Set_blockinterno sets the _blockinterno rule contexts.
	Set_blockinterno(IBlockinternoContext)

	// GetFdc returns the fdc attribute.
	GetFdc() interfaces.Instruction

	// SetFdc sets the fdc attribute.
	SetFdc(interfaces.Instruction)

	// Getter signatures
	FUNCION() antlr.TerminalNode
	ID_VALIDO() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Listaparametro() IListaparametroContext
	PARDER() antlr.TerminalNode
	RETORNO() antlr.TerminalNode
	Tipodato() ITipodatoContext
	LLAVEIZQ() antlr.TerminalNode
	Blockinterno() IBlockinternoContext
	LLAVEDER() antlr.TerminalNode

	// IsFunciondeclaracioncontrolContext differentiates from other interfaces.
	IsFunciondeclaracioncontrolContext()
}

type FunciondeclaracioncontrolContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	fdc             interfaces.Instruction
	_ID_VALIDO      antlr.Token
	_listaparametro IListaparametroContext
	_tipodato       ITipodatoContext
	_blockinterno   IBlockinternoContext
}

func NewEmptyFunciondeclaracioncontrolContext() *FunciondeclaracioncontrolContext {
	var p = new(FunciondeclaracioncontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_funciondeclaracioncontrol
	return p
}

func InitEmptyFunciondeclaracioncontrolContext(p *FunciondeclaracioncontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_funciondeclaracioncontrol
}

func (*FunciondeclaracioncontrolContext) IsFunciondeclaracioncontrolContext() {}

func NewFunciondeclaracioncontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunciondeclaracioncontrolContext {
	var p = new(FunciondeclaracioncontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_funciondeclaracioncontrol

	return p
}

func (s *FunciondeclaracioncontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *FunciondeclaracioncontrolContext) Get_ID_VALIDO() antlr.Token { return s._ID_VALIDO }

func (s *FunciondeclaracioncontrolContext) Set_ID_VALIDO(v antlr.Token) { s._ID_VALIDO = v }

func (s *FunciondeclaracioncontrolContext) Get_listaparametro() IListaparametroContext {
	return s._listaparametro
}

func (s *FunciondeclaracioncontrolContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *FunciondeclaracioncontrolContext) Get_blockinterno() IBlockinternoContext {
	return s._blockinterno
}

func (s *FunciondeclaracioncontrolContext) Set_listaparametro(v IListaparametroContext) {
	s._listaparametro = v
}

func (s *FunciondeclaracioncontrolContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *FunciondeclaracioncontrolContext) Set_blockinterno(v IBlockinternoContext) {
	s._blockinterno = v
}

func (s *FunciondeclaracioncontrolContext) GetFdc() interfaces.Instruction { return s.fdc }

func (s *FunciondeclaracioncontrolContext) SetFdc(v interfaces.Instruction) { s.fdc = v }

func (s *FunciondeclaracioncontrolContext) FUNCION() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserFUNCION, 0)
}

func (s *FunciondeclaracioncontrolContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *FunciondeclaracioncontrolContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *FunciondeclaracioncontrolContext) Listaparametro() IListaparametroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaparametroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaparametroContext)
}

func (s *FunciondeclaracioncontrolContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *FunciondeclaracioncontrolContext) RETORNO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserRETORNO, 0)
}

func (s *FunciondeclaracioncontrolContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *FunciondeclaracioncontrolContext) LLAVEIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEIZQ, 0)
}

func (s *FunciondeclaracioncontrolContext) Blockinterno() IBlockinternoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockinternoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockinternoContext)
}

func (s *FunciondeclaracioncontrolContext) LLAVEDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserLLAVEDER, 0)
}

func (s *FunciondeclaracioncontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunciondeclaracioncontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunciondeclaracioncontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterFunciondeclaracioncontrol(s)
	}
}

func (s *FunciondeclaracioncontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitFunciondeclaracioncontrol(s)
	}
}

func (p *SwiftGrammarParser) Funciondeclaracioncontrol() (localctx IFunciondeclaracioncontrolContext) {
	localctx = NewFunciondeclaracioncontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, SwiftGrammarParserRULE_funciondeclaracioncontrol)
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(909)
			p.Match(SwiftGrammarParserFUNCION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(910)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*FunciondeclaracioncontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(911)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)

			var _x = p.Listaparametro()

			localctx.(*FunciondeclaracioncontrolContext)._listaparametro = _x
		}
		{
			p.SetState(913)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(914)
			p.Match(SwiftGrammarParserRETORNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)

			var _x = p.Tipodato()

			localctx.(*FunciondeclaracioncontrolContext)._tipodato = _x
		}
		{
			p.SetState(916)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)

			var _x = p.Blockinterno()

			localctx.(*FunciondeclaracioncontrolContext)._blockinterno = _x
		}
		{
			p.SetState(918)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*FunciondeclaracioncontrolContext).fdc = instructions.NewFuncionesDeclaracionRP((func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*FunciondeclaracioncontrolContext).Get_listaparametro().GetListparfun(), localctx.(*FunciondeclaracioncontrolContext).Get_tipodato().GetTipo(), localctx.(*FunciondeclaracioncontrolContext).Get_blockinterno().GetBlkint())

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(921)
			p.Match(SwiftGrammarParserFUNCION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(922)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*FunciondeclaracioncontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(924)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(925)
			p.Match(SwiftGrammarParserRETORNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(926)

			var _x = p.Tipodato()

			localctx.(*FunciondeclaracioncontrolContext)._tipodato = _x
		}
		{
			p.SetState(927)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(928)

			var _x = p.Blockinterno()

			localctx.(*FunciondeclaracioncontrolContext)._blockinterno = _x
		}
		{
			p.SetState(929)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*FunciondeclaracioncontrolContext).fdc = instructions.NewFuncionesDeclaracionR((func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*FunciondeclaracioncontrolContext).Get_tipodato().GetTipo(), localctx.(*FunciondeclaracioncontrolContext).Get_blockinterno().GetBlkint())

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(932)
			p.Match(SwiftGrammarParserFUNCION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(933)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*FunciondeclaracioncontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(935)

			var _x = p.Listaparametro()

			localctx.(*FunciondeclaracioncontrolContext)._listaparametro = _x
		}
		{
			p.SetState(936)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(937)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(938)

			var _x = p.Blockinterno()

			localctx.(*FunciondeclaracioncontrolContext)._blockinterno = _x
		}
		{
			p.SetState(939)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*FunciondeclaracioncontrolContext).fdc = instructions.NewFuncionesDeclaracionP((func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*FunciondeclaracioncontrolContext).Get_listaparametro().GetListparfun(), localctx.(*FunciondeclaracioncontrolContext).Get_blockinterno().GetBlkint())

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(942)
			p.Match(SwiftGrammarParserFUNCION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(943)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*FunciondeclaracioncontrolContext)._ID_VALIDO = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(944)
			p.Match(SwiftGrammarParserPARIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(945)
			p.Match(SwiftGrammarParserPARDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(946)
			p.Match(SwiftGrammarParserLLAVEIZQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(947)

			var _x = p.Blockinterno()

			localctx.(*FunciondeclaracioncontrolContext)._blockinterno = _x
		}
		{
			p.SetState(948)
			p.Match(SwiftGrammarParserLLAVEDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		localctx.(*FunciondeclaracioncontrolContext).fdc = instructions.NewFuncionesDeclaracion((func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetLine()
			}
		}()), (func() int {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return 0
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetColumn()
			}
		}()), (func() string {
			if localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO() == nil {
				return ""
			} else {
				return localctx.(*FunciondeclaracioncontrolContext).Get_ID_VALIDO().GetText()
			}
		}()), localctx.(*FunciondeclaracioncontrolContext).Get_blockinterno().GetBlkint())

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaparametroContext is an interface to support dynamic dispatch.
type IListaparametroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// GetOp2 returns the op2 token.
	GetOp2() antlr.Token

	// Get_INOUT returns the _INOUT token.
	Get_INOUT() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// SetOp2 sets the op2 token.
	SetOp2(antlr.Token)

	// Set_INOUT sets the _INOUT token.
	Set_INOUT(antlr.Token)

	// Get_tipodato returns the _tipodato rule contexts.
	Get_tipodato() ITipodatoContext

	// GetOp3 returns the op3 rule contexts.
	GetOp3() IListaparametroContext

	// Set_tipodato sets the _tipodato rule contexts.
	Set_tipodato(ITipodatoContext)

	// SetOp3 sets the op3 rule contexts.
	SetOp3(IListaparametroContext)

	// GetListparfun returns the listparfun attribute.
	GetListparfun() interfaces.Instruction

	// SetListparfun sets the listparfun attribute.
	SetListparfun(interfaces.Instruction)

	// Getter signatures
	DOS_PUNTOS() antlr.TerminalNode
	Tipodato() ITipodatoContext
	COMA() antlr.TerminalNode
	AllID_VALIDO() []antlr.TerminalNode
	ID_VALIDO(i int) antlr.TerminalNode
	Listaparametro() IListaparametroContext
	INOUT() antlr.TerminalNode
	GUIONBAJO() antlr.TerminalNode

	// IsListaparametroContext differentiates from other interfaces.
	IsListaparametroContext()
}

type ListaparametroContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	listparfun interfaces.Instruction
	op         antlr.Token
	op2        antlr.Token
	_INOUT     antlr.Token
	_tipodato  ITipodatoContext
	op3        IListaparametroContext
}

func NewEmptyListaparametroContext() *ListaparametroContext {
	var p = new(ListaparametroContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaparametro
	return p
}

func InitEmptyListaparametroContext(p *ListaparametroContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaparametro
}

func (*ListaparametroContext) IsListaparametroContext() {}

func NewListaparametroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaparametroContext {
	var p = new(ListaparametroContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaparametro

	return p
}

func (s *ListaparametroContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaparametroContext) GetOp() antlr.Token { return s.op }

func (s *ListaparametroContext) GetOp2() antlr.Token { return s.op2 }

func (s *ListaparametroContext) Get_INOUT() antlr.Token { return s._INOUT }

func (s *ListaparametroContext) SetOp(v antlr.Token) { s.op = v }

func (s *ListaparametroContext) SetOp2(v antlr.Token) { s.op2 = v }

func (s *ListaparametroContext) Set_INOUT(v antlr.Token) { s._INOUT = v }

func (s *ListaparametroContext) Get_tipodato() ITipodatoContext { return s._tipodato }

func (s *ListaparametroContext) GetOp3() IListaparametroContext { return s.op3 }

func (s *ListaparametroContext) Set_tipodato(v ITipodatoContext) { s._tipodato = v }

func (s *ListaparametroContext) SetOp3(v IListaparametroContext) { s.op3 = v }

func (s *ListaparametroContext) GetListparfun() interfaces.Instruction { return s.listparfun }

func (s *ListaparametroContext) SetListparfun(v interfaces.Instruction) { s.listparfun = v }

func (s *ListaparametroContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *ListaparametroContext) Tipodato() ITipodatoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITipodatoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITipodatoContext)
}

func (s *ListaparametroContext) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *ListaparametroContext) AllID_VALIDO() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserID_VALIDO)
}

func (s *ListaparametroContext) ID_VALIDO(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, i)
}

func (s *ListaparametroContext) Listaparametro() IListaparametroContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaparametroContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaparametroContext)
}

func (s *ListaparametroContext) INOUT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserINOUT, 0)
}

func (s *ListaparametroContext) GUIONBAJO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserGUIONBAJO, 0)
}

func (s *ListaparametroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaparametroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaparametroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaparametro(s)
	}
}

func (s *ListaparametroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaparametro(s)
	}
}

func (p *SwiftGrammarParser) Listaparametro() (localctx IListaparametroContext) {
	localctx = NewListaparametroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, SwiftGrammarParserRULE_listaparametro)
	var _la int

	p.SetState(977)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(954)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(953)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ListaparametroContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SwiftGrammarParserID_VALIDO || _la == SwiftGrammarParserGUIONBAJO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ListaparametroContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(956)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ListaparametroContext).op2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(957)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserINOUT {
			{
				p.SetState(958)

				var _m = p.Match(SwiftGrammarParserINOUT)

				localctx.(*ListaparametroContext)._INOUT = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(961)

			var _x = p.Tipodato()

			localctx.(*ListaparametroContext)._tipodato = _x
		}
		{
			p.SetState(962)
			p.Match(SwiftGrammarParserCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(963)

			var _x = p.Listaparametro()

			localctx.(*ListaparametroContext).op3 = _x
		}

		if localctx.(*ListaparametroContext).GetOp() != nil {
			if localctx.(*ListaparametroContext).Get_INOUT() != nil {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesListaParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), true, true, localctx.(*ListaparametroContext).GetOp3().GetListparfun())
			} else {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesListaParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), false, true, localctx.(*ListaparametroContext).GetOp3().GetListparfun())
			}
		} else {
			if localctx.(*ListaparametroContext).Get_INOUT() != nil {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesListaParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), "", (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), true, false, localctx.(*ListaparametroContext).GetOp3().GetListparfun())
			} else {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesListaParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), "", (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), false, false, localctx.(*ListaparametroContext).GetOp3().GetListparfun())
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(967)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(966)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ListaparametroContext).op = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == SwiftGrammarParserID_VALIDO || _la == SwiftGrammarParserGUIONBAJO) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ListaparametroContext).op = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(969)

			var _m = p.Match(SwiftGrammarParserID_VALIDO)

			localctx.(*ListaparametroContext).op2 = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(970)
			p.Match(SwiftGrammarParserDOS_PUNTOS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == SwiftGrammarParserINOUT {
			{
				p.SetState(971)

				var _m = p.Match(SwiftGrammarParserINOUT)

				localctx.(*ListaparametroContext)._INOUT = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(974)

			var _x = p.Tipodato()

			localctx.(*ListaparametroContext)._tipodato = _x
		}

		if localctx.(*ListaparametroContext).GetOp() != nil {
			if localctx.(*ListaparametroContext).Get_INOUT() != nil {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), true, true)
			} else {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp().GetText()
					}
				}()), (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), false, true)
			}
		} else {
			if localctx.(*ListaparametroContext).Get_INOUT() != nil {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), "", (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), true, false)
			} else {
				localctx.(*ListaparametroContext).listparfun = instructions.NewFuncionesParametro((func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetLine()
					}
				}()), (func() int {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return 0
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetColumn()
					}
				}()), "", (func() string {
					if localctx.(*ListaparametroContext).GetOp2() == nil {
						return ""
					} else {
						return localctx.(*ListaparametroContext).GetOp2().GetText()
					}
				}()), localctx.(*ListaparametroContext).Get_tipodato().GetTipo(), false, false)
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncionllamadacontrolContext is an interface to support dynamic dispatch.
type IFuncionllamadacontrolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ID_VALIDO() antlr.TerminalNode
	AllPARIZQ() []antlr.TerminalNode
	PARIZQ(i int) antlr.TerminalNode
	Listaparametrosllamada() IListaparametrosllamadaContext

	// IsFuncionllamadacontrolContext differentiates from other interfaces.
	IsFuncionllamadacontrolContext()
}

type FuncionllamadacontrolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncionllamadacontrolContext() *FuncionllamadacontrolContext {
	var p = new(FuncionllamadacontrolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_funcionllamadacontrol
	return p
}

func InitEmptyFuncionllamadacontrolContext(p *FuncionllamadacontrolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_funcionllamadacontrol
}

func (*FuncionllamadacontrolContext) IsFuncionllamadacontrolContext() {}

func NewFuncionllamadacontrolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncionllamadacontrolContext {
	var p = new(FuncionllamadacontrolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_funcionllamadacontrol

	return p
}

func (s *FuncionllamadacontrolContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncionllamadacontrolContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *FuncionllamadacontrolContext) AllPARIZQ() []antlr.TerminalNode {
	return s.GetTokens(SwiftGrammarParserPARIZQ)
}

func (s *FuncionllamadacontrolContext) PARIZQ(i int) antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, i)
}

func (s *FuncionllamadacontrolContext) Listaparametrosllamada() IListaparametrosllamadaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaparametrosllamadaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaparametrosllamadaContext)
}

func (s *FuncionllamadacontrolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncionllamadacontrolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncionllamadacontrolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterFuncionllamadacontrol(s)
	}
}

func (s *FuncionllamadacontrolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitFuncionllamadacontrol(s)
	}
}

func (p *SwiftGrammarParser) Funcionllamadacontrol() (localctx IFuncionllamadacontrolContext) {
	localctx = NewFuncionllamadacontrolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, SwiftGrammarParserRULE_funcionllamadacontrol)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.Match(SwiftGrammarParserID_VALIDO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(980)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(981)
			p.Listaparametrosllamada()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(984)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListaparametrosllamadaContext is an interface to support dynamic dispatch.
type IListaparametrosllamadaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMA() antlr.TerminalNode
	Expr() IExprContext
	Listaparametrosllamada() IListaparametrosllamadaContext
	ID_VALIDO() antlr.TerminalNode
	DOS_PUNTOS() antlr.TerminalNode

	// IsListaparametrosllamadaContext differentiates from other interfaces.
	IsListaparametrosllamadaContext()
}

type ListaparametrosllamadaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListaparametrosllamadaContext() *ListaparametrosllamadaContext {
	var p = new(ListaparametrosllamadaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaparametrosllamada
	return p
}

func InitEmptyListaparametrosllamadaContext(p *ListaparametrosllamadaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_listaparametrosllamada
}

func (*ListaparametrosllamadaContext) IsListaparametrosllamadaContext() {}

func NewListaparametrosllamadaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListaparametrosllamadaContext {
	var p = new(ListaparametrosllamadaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_listaparametrosllamada

	return p
}

func (s *ListaparametrosllamadaContext) GetParser() antlr.Parser { return s.parser }

func (s *ListaparametrosllamadaContext) COMA() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserCOMA, 0)
}

func (s *ListaparametrosllamadaContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ListaparametrosllamadaContext) Listaparametrosllamada() IListaparametrosllamadaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListaparametrosllamadaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListaparametrosllamadaContext)
}

func (s *ListaparametrosllamadaContext) ID_VALIDO() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserID_VALIDO, 0)
}

func (s *ListaparametrosllamadaContext) DOS_PUNTOS() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserDOS_PUNTOS, 0)
}

func (s *ListaparametrosllamadaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListaparametrosllamadaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListaparametrosllamadaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterListaparametrosllamada(s)
	}
}

func (s *ListaparametrosllamadaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitListaparametrosllamada(s)
	}
}

func (p *SwiftGrammarParser) Listaparametrosllamada() (localctx IListaparametrosllamadaContext) {
	localctx = NewListaparametrosllamadaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, SwiftGrammarParserRULE_listaparametrosllamada)
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case SwiftGrammarParserCOMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(987)
			p.Match(SwiftGrammarParserCOMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(990)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(988)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(989)
				p.Match(SwiftGrammarParserDOS_PUNTOS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(993)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(992)
				p.Match(SwiftGrammarParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(995)
			p.expr(0)
		}
		{
			p.SetState(996)
			p.Listaparametrosllamada()
		}

	case SwiftGrammarParserT__0, SwiftGrammarParserFLOAT, SwiftGrammarParserSTRING, SwiftGrammarParserTRU, SwiftGrammarParserFAL, SwiftGrammarParserNULO, SwiftGrammarParserNUMBER, SwiftGrammarParserCADENA, SwiftGrammarParserID_VALIDO, SwiftGrammarParserCHARACTER, SwiftGrammarParserPARIZQ, SwiftGrammarParserNOT, SwiftGrammarParserSUB:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(999)
				p.Match(SwiftGrammarParserID_VALIDO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1000)
				p.Match(SwiftGrammarParserDOS_PUNTOS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1004)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1003)
				p.Match(SwiftGrammarParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1006)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintstmtContext is an interface to support dynamic dispatch.
type IPrintstmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_PRINT returns the _PRINT token.
	Get_PRINT() antlr.Token

	// Set_PRINT sets the _PRINT token.
	Set_PRINT(antlr.Token)

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetPrnt returns the prnt attribute.
	GetPrnt() interfaces.Instruction

	// SetPrnt sets the prnt attribute.
	SetPrnt(interfaces.Instruction)

	// Getter signatures
	PRINT() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Expr() IExprContext
	PARDER() antlr.TerminalNode

	// IsPrintstmtContext differentiates from other interfaces.
	IsPrintstmtContext()
}

type PrintstmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	prnt   interfaces.Instruction
	_PRINT antlr.Token
	_expr  IExprContext
}

func NewEmptyPrintstmtContext() *PrintstmtContext {
	var p = new(PrintstmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_printstmt
	return p
}

func InitEmptyPrintstmtContext(p *PrintstmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_printstmt
}

func (*PrintstmtContext) IsPrintstmtContext() {}

func NewPrintstmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintstmtContext {
	var p = new(PrintstmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_printstmt

	return p
}

func (s *PrintstmtContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintstmtContext) Get_PRINT() antlr.Token { return s._PRINT }

func (s *PrintstmtContext) Set_PRINT(v antlr.Token) { s._PRINT = v }

func (s *PrintstmtContext) Get_expr() IExprContext { return s._expr }

func (s *PrintstmtContext) Set_expr(v IExprContext) { s._expr = v }

func (s *PrintstmtContext) GetPrnt() interfaces.Instruction { return s.prnt }

func (s *PrintstmtContext) SetPrnt(v interfaces.Instruction) { s.prnt = v }

func (s *PrintstmtContext) PRINT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPRINT, 0)
}

func (s *PrintstmtContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *PrintstmtContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *PrintstmtContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *PrintstmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintstmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintstmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterPrintstmt(s)
	}
}

func (s *PrintstmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitPrintstmt(s)
	}
}

func (p *SwiftGrammarParser) Printstmt() (localctx IPrintstmtContext) {
	localctx = NewPrintstmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, SwiftGrammarParserRULE_printstmt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)

		var _m = p.Match(SwiftGrammarParserPRINT)

		localctx.(*PrintstmtContext)._PRINT = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1012)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1013)

		var _x = p.expr(0)

		localctx.(*PrintstmtContext)._expr = _x
	}
	{
		p.SetState(1014)
		p.Match(SwiftGrammarParserPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*PrintstmtContext).prnt = instructions.NewPrint((func() int {
		if localctx.(*PrintstmtContext).Get_PRINT() == nil {
			return 0
		} else {
			return localctx.(*PrintstmtContext).Get_PRINT().GetLine()
		}
	}()), (func() int {
		if localctx.(*PrintstmtContext).Get_PRINT() == nil {
			return 0
		} else {
			return localctx.(*PrintstmtContext).Get_PRINT().GetColumn()
		}
	}()), localctx.(*PrintstmtContext).Get_expr().GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntembebidaContext is an interface to support dynamic dispatch.
type IIntembebidaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetIntemb returns the intemb attribute.
	GetIntemb() interfaces.Expression

	// SetIntemb sets the intemb attribute.
	SetIntemb(interfaces.Expression)

	// Getter signatures
	INT() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Expr() IExprContext
	PARDER() antlr.TerminalNode

	// IsIntembebidaContext differentiates from other interfaces.
	IsIntembebidaContext()
}

type IntembebidaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	intemb interfaces.Expression
	_expr  IExprContext
}

func NewEmptyIntembebidaContext() *IntembebidaContext {
	var p = new(IntembebidaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_intembebida
	return p
}

func InitEmptyIntembebidaContext(p *IntembebidaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_intembebida
}

func (*IntembebidaContext) IsIntembebidaContext() {}

func NewIntembebidaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntembebidaContext {
	var p = new(IntembebidaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_intembebida

	return p
}

func (s *IntembebidaContext) GetParser() antlr.Parser { return s.parser }

func (s *IntembebidaContext) Get_expr() IExprContext { return s._expr }

func (s *IntembebidaContext) Set_expr(v IExprContext) { s._expr = v }

func (s *IntembebidaContext) GetIntemb() interfaces.Expression { return s.intemb }

func (s *IntembebidaContext) SetIntemb(v interfaces.Expression) { s.intemb = v }

func (s *IntembebidaContext) INT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserINT, 0)
}

func (s *IntembebidaContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *IntembebidaContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IntembebidaContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *IntembebidaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntembebidaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntembebidaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterIntembebida(s)
	}
}

func (s *IntembebidaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitIntembebida(s)
	}
}

func (p *SwiftGrammarParser) Intembebida() (localctx IIntembebidaContext) {
	localctx = NewIntembebidaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, SwiftGrammarParserRULE_intembebida)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(SwiftGrammarParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1018)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1019)

		var _x = p.expr(0)

		localctx.(*IntembebidaContext)._expr = _x
	}
	{
		p.SetState(1020)
		p.Match(SwiftGrammarParserPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*IntembebidaContext).intemb = instructions.NewFuncionIntEmbebida(localctx.(*IntembebidaContext).Get_expr().GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatembebidaContext is an interface to support dynamic dispatch.
type IFloatembebidaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetFloemb returns the floemb attribute.
	GetFloemb() interfaces.Expression

	// SetFloemb sets the floemb attribute.
	SetFloemb(interfaces.Expression)

	// Getter signatures
	FLOAT() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Expr() IExprContext
	PARDER() antlr.TerminalNode

	// IsFloatembebidaContext differentiates from other interfaces.
	IsFloatembebidaContext()
}

type FloatembebidaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	floemb interfaces.Expression
	_expr  IExprContext
}

func NewEmptyFloatembebidaContext() *FloatembebidaContext {
	var p = new(FloatembebidaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_floatembebida
	return p
}

func InitEmptyFloatembebidaContext(p *FloatembebidaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_floatembebida
}

func (*FloatembebidaContext) IsFloatembebidaContext() {}

func NewFloatembebidaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatembebidaContext {
	var p = new(FloatembebidaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_floatembebida

	return p
}

func (s *FloatembebidaContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatembebidaContext) Get_expr() IExprContext { return s._expr }

func (s *FloatembebidaContext) Set_expr(v IExprContext) { s._expr = v }

func (s *FloatembebidaContext) GetFloemb() interfaces.Expression { return s.floemb }

func (s *FloatembebidaContext) SetFloemb(v interfaces.Expression) { s.floemb = v }

func (s *FloatembebidaContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserFLOAT, 0)
}

func (s *FloatembebidaContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *FloatembebidaContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *FloatembebidaContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *FloatembebidaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatembebidaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatembebidaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterFloatembebida(s)
	}
}

func (s *FloatembebidaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitFloatembebida(s)
	}
}

func (p *SwiftGrammarParser) Floatembebida() (localctx IFloatembebidaContext) {
	localctx = NewFloatembebidaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, SwiftGrammarParserRULE_floatembebida)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.Match(SwiftGrammarParserFLOAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1024)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1025)

		var _x = p.expr(0)

		localctx.(*FloatembebidaContext)._expr = _x
	}
	{
		p.SetState(1026)
		p.Match(SwiftGrammarParserPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*FloatembebidaContext).floemb = instructions.NewFuncionFloatEmbebida(localctx.(*FloatembebidaContext).Get_expr().GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringembebidaContext is an interface to support dynamic dispatch.
type IStringembebidaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expr returns the _expr rule contexts.
	Get_expr() IExprContext

	// Set_expr sets the _expr rule contexts.
	Set_expr(IExprContext)

	// GetStremb returns the stremb attribute.
	GetStremb() interfaces.Expression

	// SetStremb sets the stremb attribute.
	SetStremb(interfaces.Expression)

	// Getter signatures
	STRING() antlr.TerminalNode
	PARIZQ() antlr.TerminalNode
	Expr() IExprContext
	PARDER() antlr.TerminalNode

	// IsStringembebidaContext differentiates from other interfaces.
	IsStringembebidaContext()
}

type StringembebidaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	stremb interfaces.Expression
	_expr  IExprContext
}

func NewEmptyStringembebidaContext() *StringembebidaContext {
	var p = new(StringembebidaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_stringembebida
	return p
}

func InitEmptyStringembebidaContext(p *StringembebidaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = SwiftGrammarParserRULE_stringembebida
}

func (*StringembebidaContext) IsStringembebidaContext() {}

func NewStringembebidaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringembebidaContext {
	var p = new(StringembebidaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = SwiftGrammarParserRULE_stringembebida

	return p
}

func (s *StringembebidaContext) GetParser() antlr.Parser { return s.parser }

func (s *StringembebidaContext) Get_expr() IExprContext { return s._expr }

func (s *StringembebidaContext) Set_expr(v IExprContext) { s._expr = v }

func (s *StringembebidaContext) GetStremb() interfaces.Expression { return s.stremb }

func (s *StringembebidaContext) SetStremb(v interfaces.Expression) { s.stremb = v }

func (s *StringembebidaContext) STRING() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserSTRING, 0)
}

func (s *StringembebidaContext) PARIZQ() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARIZQ, 0)
}

func (s *StringembebidaContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *StringembebidaContext) PARDER() antlr.TerminalNode {
	return s.GetToken(SwiftGrammarParserPARDER, 0)
}

func (s *StringembebidaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringembebidaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringembebidaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.EnterStringembebida(s)
	}
}

func (s *StringembebidaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(SwiftGrammarListener); ok {
		listenerT.ExitStringembebida(s)
	}
}

func (p *SwiftGrammarParser) Stringembebida() (localctx IStringembebidaContext) {
	localctx = NewStringembebidaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, SwiftGrammarParserRULE_stringembebida)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(SwiftGrammarParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1030)
		p.Match(SwiftGrammarParserPARIZQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1031)

		var _x = p.expr(0)

		localctx.(*StringembebidaContext)._expr = _x
	}
	{
		p.SetState(1032)
		p.Match(SwiftGrammarParserPARDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	localctx.(*StringembebidaContext).stremb = instructions.NewFuncionStringEmbebida(localctx.(*StringembebidaContext).Get_expr().GetE())

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *SwiftGrammarParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 9:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 32:
		var t *Listavaloresmat2Context = nil
		if localctx != nil {
			t = localctx.(*Listavaloresmat2Context)
		}
		return p.Listavaloresmat2_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *SwiftGrammarParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 16)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *SwiftGrammarParser) Listavaloresmat2_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
